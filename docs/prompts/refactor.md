通用输出约束（必须遵守）：
- 最终产出是一份 Markdown 审计报告（不是聊天回复/提纲），可直接保存到 `docs/reports/`。
- 文件名 MUST 使用英文 `kebab-case.md`，并建议带日期前缀：`YYYY-MM-DD_refactor-audit-report.md`。
- 报告结构 MUST 遵守 `docs/Obsidian/standards/doc/documentation-standards.md` 的 `reports/*` 最小结构: 摘要结论(先给结论)/范围与方法/发现清单(按 P0/P1/P2)/建议与后续行动/证据与数据来源(可链接到 `docs/reports/artifacts/`).
- 标题下 MUST 包含元信息块：状态/负责人/创建/更新/范围/关联（用相对路径链接标准文档）。
- 每条发现 MUST 给出可定位证据（文件:行号/调用链/重复点），并包含迁移/回滚与验证方法。

你现在是“资深软件架构师 + 重构负责人 + Python/Flask 工程专家 + 代码质量与可维护性工程师”的组合角色。请基于我给你的仓库代码，对项目做一次“查漏补缺式”的重构评审，目标是：减少重复代码、抽取公共组件、统一工程规范，并给出可落地的渐进式改造方案（可滚动发布/可回滚/可验证）。

输入材料（本地仓库）：

服务端代码：app/**（重点：app/routes/**、app/services/**、app/utils/**、app/models/**、app/tasks/**、scheduler.py）
前端模板与静态资源：templates/**、static/**
测试：tests/**
脚本与文档：scripts/**、docs/**
规范与门禁（如有）：pyproject.toml、ruff/pyright 配置、Makefile、CI 配置
（可选但强烈建议你先向我确认/补齐）

Top 10 业务用例/接口路径（读写链路）
质量目标：重构后允许的行为变化边界（必须完全兼容/允许轻微调整）
性能与稳定性目标：QPS、延迟、关键页面/任务链路 SLO
近期迭代节奏：是否允许拆分多 PR、是否支持 feature flag
你的目标：

识别“可删代码/重复代码/散落逻辑/不一致模式”，并量化：重复热点、可能的公共组件边界。
识别“架构与分层问题”：职责混杂、路由/服务/工具层耦合、跨模块循环依赖、隐式全局状态。
给出可落地的抽取与重构方案：短期止血/中期重构/长期演进，并明确迁移策略（兼容/回滚/灰度）。
给出可验证的检查方法：单测建议、契约测试点、静态检查门禁、运行时验证清单。
工作方法（必须按步骤输出）：
A. 先做“代码地图”：列出关键模块边界、依赖方向、入口点（routes/tasks/scheduler）、跨层调用概览（文字版架构图即可）。
B. 做“重复与债务热力图”：从 routes/services/utils/templates 中找出 Top 15 重复/相似片段与模式（拷贝粘贴、同名不同义、同义不同名），标注证据位置与可抽取点。
C. 做“公共组件抽取设计”：为每个高价值抽取点给出组件方案（组件名/放置目录/API 设计/输入输出类型/错误处理/日志），并给出调用侧如何改造（渐进式）。
D. 做“迁移与兼容审查”：找出任何会导致不可回滚/不可灰度/一次性大改的重构方式，并给出替代路径（adapter/facade/wrapper、deprecation、双写/双读、开关）。
E. 输出问题清单与路线图：按 P0/P1/P2 排序，给出最小可执行改进计划（最多 8 条行动项），每条写清楚“改哪里、怎么验、如何回滚”。

检查维度（逐项过一遍，不得跳过）：

分层与边界（Architecture）
routes 是否包含业务规则/数据访问？services 是否变成“万能层”？utils 是否承担业务含义？
是否存在循环依赖/隐式依赖（全局对象、current_app、模块级单例）？
是否需要引入明确的边界：domain/service/repository/adapter/serializer？
重复与抽象（DRY & Abstraction）
是否存在同类逻辑在多个文件重复实现：分页、过滤、排序、鉴权、校验、序列化、错误映射、日志埋点？
是否存在“参数/字段名漂移”导致的重复 if/else 与兼容判断？
抽象是否过度（为抽象而抽象）？是否需要保持可读性优先？
API 与类型（Interfaces & Types）
公共组件 API 是否稳定、是否最小化输入输出、是否易测？
是否缺少统一的类型别名/TypedDict/Protocol（避免 dict[str, Any] 扩散）？
是否存在“同一概念多种结构表示”的问题（DTO/ORM/JSON 混用）？
错误处理与日志（Errors & Observability）
是否存在各处 try/except 风格不一致、错误 message schema 漂移、日志字段不统一？
是否应抽取统一的 route wrapper、service 返回结构、错误码映射与埋点？
是否需要对兼容/兜底路径加统计（命中率）？
数据访问与查询组织（Data Access）
services 是否散落 SQLAlchemy 查询拼装，难以复用与测试？
是否需要抽取 repository/query builder、通用过滤器、预加载策略（避免 N+1）？
是否存在重复的联表/聚合/统计计算，适合封装或预计算？
测试与可回归（Testing）
重构是否有“契约点”（输入输出、HTTP schema、任务参数）可用来锁行为？
是否缺少单测/集成测试的关键断言？是否需要 golden tests（序列化结果快照）？
是否能在不改行为的前提下先补测试再重构？
性能与资源（Performance）
抽取公共组件是否引入额外开销（反射、过度包装、多层转换）？
热路径（Top 10 请求/任务）是否会因重构变慢？是否需要基准点与对比方法？
是否存在可降本的重复计算、重复 IO、无缓存的频繁查询？
兼容/防御/回退/适配（重点关注兜底）
是否存在 x or y / data.get('new') or data.get('old') / 多版本参数 / 旧接口兜底？
是否存在为了兼容长期保留的旧函数/旧字段/旧路径，但没有迁移计划与埋点？
是否存在“环境差异回退”（例如不同配置/不同数据库/不同运行模式）导致分支逻辑膨胀？
任何需要保留的兼容层：请用 adapter/facade 明确隔离，并给出删除时间表与条件。
输出格式(严格遵守; 按 `docs/Obsidian/standards/doc/documentation-standards.md` 的 `reports/*` 模板组织):
- 建议报告路径：`docs/reports/YYYY-MM-DD_refactor-audit-report.md`
- 标题下必须包含元信息块：状态/负责人/创建/更新/范围/关联

报告必须包含以下一级标题（顺序固定）：
I. 摘要结论（先给结论）
II. 范围与方法
III. 发现清单（按 P0/P1/P2）
IV. 建议与后续行动
V. 证据与数据来源

“范围与方法”中必须包含：
- 代码地图（文字架构图）：模块分层与职责/关键入口点与调用链/主要依赖方向与违反点
- 重复与债务热力图：Top 15 重复点（含证据：文件:行号）+ 重复类型归类 + 可删代码估算

“发现清单（按 P0/P1/P2）”中必须包含公共组件抽取清单（每条包含）：
- 标题（一句话）
- 证据：文件:行号（至少 2 处重复点）
- 影响：维护成本/缺陷风险/一致性/性能（最坏情况 + 最可能发生方式）
- 根因：为什么会重复（边界不清/缺少基础设施/历史包袱/兼容压力）
- 方案：组件名 + 放置目录 + API 草案（输入/输出/异常/日志）+ 迁移步骤（先引入后替换）
- 验证：测试点（单测/集成/契约）、静态检查门禁、关键回归清单
- 回滚：如何快速回退（feature flag/保留旧实现/双实现切换）

“建议与后续行动”中必须包含：
- 迁移与发布策略（渐进式重构）：分阶段策略/风险点与缓解/兼容与兜底路径的埋点统计方案（命中率阈值 → 删除条件）
- 最小可执行路线图（<=8 条行动项）：每条包含改动范围 + 验证方式 + 预估收益，按 P0→P2 排序
约束（必须遵守）：

优先“小步重构、可回滚、可验证”，禁止一次性大爆改。
新增/修改代码必须保持命名一致、结构化日志一致、避免 print。
任何兼容/兜底逻辑必须明确标注“删除条件与时间表”，并建议加入命中率埋点。
