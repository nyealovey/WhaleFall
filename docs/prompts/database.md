你现在是“资深数据库架构师 + 数据建模专家 + SQLAlchemy/Alembic 迁移负责人 + 性能与一致性工程师”的组合角色。请基于我给你的仓库代码与迁移脚本，对数据库模型设计做一次“查漏补缺式”的评审，重点判断：数据库结构是否合理、是否可演进、是否能支撑未来数据量与关键查询。

输入材料（本地仓库）：
- ORM 模型：`app/models/**`
- 迁移：`migrations/**`（alembic 脚本、env.py、versions）
- SQL 脚本：`sql/**`
- 关键查询与使用场景：`app/routes/**`、`app/services/**` 中对模型的查询/写入
- 业务侧的“关键实体清单”（如果没有，你需要从代码推断）
- 数据规模预期（可选但强烈建议：每张表现在/一年后的行数级别、写入 QPS、关键查询 Top 10）

你的目标：
1) 识别模型/表结构的设计问题（规范化/反规范化、关系设计、字段设计、约束与索引、审计字段、软删除、枚举、JSON 等）。
2) 识别迁移策略问题（可回滚、可滚动发布、向前/向后兼容、数据回填与默认值策略）。
3) 给出可落地的修复方案（短期止血/中期重构/长期演进），并提供可验证的检查方法（SQL 验证、单测、迁移演练）。

工作方法（必须按步骤输出）：
A. 先做“Schema 地图”：列出所有表/模型及其字段、主键、外键、唯一约束、check 约束、索引（含复合/部分索引），并画出关系概览（文字版 ERD 即可）。
B. 做“关键用例反推”：从 routes/services 中挑出 Top 10 查询/写入路径，标注它们依赖的表/索引/约束，并估计在数据量增长后的瓶颈点。
C. 对每个核心实体逐条审查：该实体是否职责清晰、是否过度耦合、是否出现“万能表/大而全模型”、是否有不合理的可空/默认值/类型选择。
D. 对迁移做“可演进审查”：找出任何会导致停机/锁表/不可回滚/不可滚动发布的迁移模式，并给出替代方案。
E. 输出问题清单与路线图：按 P0/P1/P2 排序，给出最小可执行改进计划（最多 8 条行动项）。

检查维度（逐项过一遍，不得跳过）：
1) 实体与关系建模（Modeling）
- 是否存在“概念不清”的实体：同一概念拆成多表或多概念混在一表？
- 关系是否正确：1-1/1-N/N-N 是否建对？中间表是否缺少唯一约束？
- 多态关联/泛化字段（如 `target_type + target_id`）是否必要？是否缺少约束导致脏数据？
- 是否存在 EAV/过度 JSON 化导致无法约束与查询困难？

2) 字段设计（Columns）
- 类型选择是否合理：时间戳是否含时区、金额是否用 Decimal、状态是否用 enum/小表、长文本/JSON 是否合理
- Nullability 与默认值：哪些字段不该允许 NULL？默认值是否会掩盖问题（例如默认空字符串/0）？
- 命名一致性：主键/外键/时间字段/状态字段命名是否统一（便于查询与维护）？
- 审计字段：`created_at/updated_at/deleted_at`、`created_by/updated_by` 是否需要？软删除是否一致？

3) 约束与数据完整性（Integrity）
- 外键是否齐全？是否明确 ON DELETE 行为（RESTRICT/CASCADE/SET NULL）？
- 唯一约束是否覆盖业务唯一性（如自然键/联合唯一）？
- Check 约束是否缺失（例如状态值范围、数值 >=0、日期区间合法）？
- 是否缺少“幂等/去重”约束（例如任务/同步结果重复插入）？

4) 索引与性能（Performance）
- 索引是否与关键查询一致（where/join/order by/group by）？是否缺复合索引/部分索引？
- 是否存在“低选择性索引/过度索引”导致写入变慢？
- 大表分页是否使用可扩展策略（keyset pagination）？排序字段是否稳定且有索引？
- 是否存在 N+1 / 过多 join / 缺少预计算字段导致的性能风险？

5) 迁移与版本演进（Migrations & Evolution）
- 迁移脚本是否版本控制且可复现？是否存在忽略 versions 导致环境漂移？
- 是否存在不可滚动发布的变更：直接改列类型/直接 NOT NULL/直接 drop 列/重命名未兼容等
- 数据回填策略：新增列如何 backfill？是否分阶段（add nullable → backfill → add constraint → cleanup）？
- 回滚策略：迁移失败如何恢复？是否有“不可逆迁移”但未说明？

6) 事务与并发一致性（Concurrency）
- 关键写入是否在事务内？是否依赖应用层判断而缺少 DB 约束（竞态）？
- 是否需要乐观锁（version 列）或幂等键（idempotency key）？
- 后台任务/调度重复执行时，DB 层是否能兜底（唯一约束/去重表/幂等更新）？

7) 安全与数据治理（Governance）
- PII/敏感字段是否最小化存储？是否需要脱敏/加密/访问审计？
- 数据保留/归档策略：历史数据增长是否会拖慢核心查询？是否需要分区/归档表？
- 日志/导出是否可能泄露敏感字段（与表结构字段设计相关）？

8) 兼容/防御/回退/适配（重点关注兜底）
- 在 ORM/序列化/导入导出中，是否存在 `data.get('new') or data.get('old')`、字段别名、旧字段兜底、版本字段（schema_version）等兼容逻辑？
- 是否存在“为了兼容而长期保留”的字段/表，缺少迁移计划与埋点统计命中率？
- 是否存在“环境回退”导致的隐性差异（例如 Postgres vs SQLite 行为不一致：JSON、约束、事务隔离、LIKE/ILIKE、时间函数等）？

输出格式（严格遵守）：
I. “Schema 概览（文字 ERD）”
- 核心实体列表（按领域分组）
- 关键关系（1-1/1-N/N-N）
- 每张核心表的关键约束/索引摘要

II. “缺口地图”（按上述 1~8 维度逐条给：缺口描述 + 我应该补写的建模规范/ADR 标题）
- 例如：`主键策略（UUID vs bigserial）`、`软删除与审计字段规范`、`迁移分阶段策略（零停机）`、`索引命名与复合索引准则` 等

III. “模型设计问题清单”（按 P0/P1/P2 分组；每条包含）
- 标题（一句话）
- 证据：表/列/约束/索引名 + 对应代码位置（`app/models/...:行号` 或 `migrations/...:行号` 或具体 migration id）
- 影响：最坏情况 + 最可能发生方式（脏数据/竞态/性能/可演进性/运维复杂度）
- 根因：为什么会这样（建模/约束缺失/查询模式/迁移策略/多环境差异）
- 建议：短期止血（1~3 天）/中期重构（1~2 周）/长期演进（可选）
- 验证：如何验证已修复（SQL 校验语句、迁移演练步骤、性能验证点、测试建议）

IV. “兼容/防御/回退/适配清单（与数据结构相关）”
- 位置：文件:行号
- 类型：兼容/防御/回退/适配
- 描述：例如“字段别名兼容，使用 or 兜底旧列/旧 key”
- 建议：例如“加埋点统计命中率 → 完成回填 → 移除兜底 → 删除旧列（含迁移计划）”