# 账户模型重构方案

## 一、问题分析

### 1.1 当前架构存在的问题

经过对现有代码的分析，发现账户同步功能和数据库容量同步功能在模型设计上存在不一致性：

#### 问题1：缺少实例-账户关系表
- **现状**：账户数据直接存储在 `current_account_sync_data` 表中，通过 `instance_id` 和 `username` 关联
- **对比**：数据库容量功能有 `instance_databases` 表，专门维护实例与数据库的关系
- **影响**：
  - 无法独立追踪账户的生命周期（首次发现、最后发现、删除时间）
  - 账户状态变更与权限数据混在一起，职责不清晰
  - 难以实现账户级别的统计和分析

#### 问题2：账户数据模型职责过重
`current_account_sync_data` 表承担了过多职责：
- 账户基本信息（username, is_superuser, is_active）
- 四种数据库类型的权限数据（MySQL、PostgreSQL、SQL Server、Oracle）
- 同步状态管理（last_sync_time, last_change_type）
- 删除标记（is_deleted, deleted_time）
- 变更追踪（last_change_time）

这导致：
- 表结构臃肿，包含大量 JSON 字段
- 查询性能受影响
- 维护困难，职责不清

#### 问题3：架构不一致
- **数据库容量同步**：`instances` → `instance_databases` → `database_size_stat`
- **账户同步**：`instances` → `current_account_sync_data`（缺少中间关系表）

这种不一致性导致：
- 代码理解成本高
- 新功能开发时缺乏统一的设计模式
- 难以维护和扩展

### 1.2 具体场景问题

#### 场景1：账户删除检测
当前实现：
```python
# 在 current_account_sync_data 中标记 is_deleted=True
account.is_deleted = True
account.deleted_time = now()
```

问题：
- 无法区分"账户从未存在"和"账户已删除"
- 难以统计账户的存活时长
- 无法追踪账户的完整生命周期

#### 场景2：账户统计分析
需求：统计每个实例有多少个活跃账户、历史账户总数、账户增长趋势

当前实现困难：
- 需要扫描所有 `current_account_sync_data` 记录
- 无法快速获取账户的首次发现时间
- 删除的账户和活跃账户混在一起

#### 场景3：跨实例账户分析
需求：查找在多个实例中都存在的账户（如 root、admin）

当前实现：
- 需要按 username 分组查询 `current_account_sync_data`
- 无法快速定位账户的分布情况

## 二、重构方案

### 2.1 新增 `instance_accounts` 表

参考 `instance_databases` 的设计，新增实例-账户关系表：

```python
class InstanceAccount(db.Model):
    """实例-账户关系模型"""
    
    __tablename__ = "instance_accounts"
    
    id = db.Column(db.Integer, primary_key=True)
    instance_id = db.Column(db.Integer, db.ForeignKey("instances.id"), nullable=False, index=True)
    username = db.Column(db.String(255), nullable=False, comment="账户名称")
    is_active = db.Column(db.Boolean, default=True, nullable=False, comment="账户是否活跃（未删除）")
    first_seen_date = db.Column(db.Date, nullable=False, default=date.today, comment="首次发现日期")
    last_seen_date = db.Column(db.Date, nullable=False, default=date.today, comment="最后发现日期")
    deleted_at = db.Column(db.DateTime(timezone=True), nullable=True, comment="删除时间")
    created_at = db.Column(db.DateTime(timezone=True), default=time_utils.now, nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), default=time_utils.now, onupdate=time_utils.now, nullable=False)
    
    # 关系
    instance = db.relationship("Instance", back_populates="instance_accounts")
    
    __table_args__ = (
        db.UniqueConstraint("instance_id", "username", name="uq_instance_account_instance_username"),
        db.Index("ix_instance_accounts_username", "username"),
        db.Index("ix_instance_accounts_active", "is_active"),
        db.Index("ix_instance_accounts_last_seen", "last_seen_date"),
        {
            "comment": "实例-账户关系表，维护账户的存在状态",
        },
    )
```

### 2.2 重构 `current_account_sync_data` 表

将职责简化，专注于权限数据存储：

```python
class CurrentAccountSyncData(BaseSyncData):
    """账户权限数据表（仅存储权限信息）"""
    
    __tablename__ = "current_account_sync_data"
    
    __table_args__ = (
        db.UniqueConstraint("instance_id", "db_type", "username", name="uq_current_account_sync"),
        db.Index("idx_instance_dbtype", "instance_id", "db_type"),
        db.Index("idx_username", "username"),
        # 移除 is_deleted 索引
    )
    
    username = db.Column(db.String(255), nullable=False)
    is_superuser = db.Column(db.Boolean, default=False)
    is_active = db.Column(db.Boolean, default=True, nullable=True)
    
    # 权限字段保持不变
    global_privileges = db.Column(db.JSON, nullable=True)
    database_privileges = db.Column(db.JSON, nullable=True)
    # ... 其他权限字段
    
    # 简化的时间戳字段
    last_sync_time = db.Column(db.DateTime(timezone=True), default=time_utils.now, index=True)
    last_change_type = db.Column(db.String(20), default="add")
    last_change_time = db.Column(db.DateTime(timezone=True), default=time_utils.now, index=True)
    
    # 移除删除标记字段
    # is_deleted = db.Column(db.Boolean, default=False, index=True)  # 删除
    # deleted_time = db.Column(db.DateTime(timezone=True), nullable=True, index=True)  # 删除
    
    # 关联实例账户
    instance = db.relationship("Instance", backref="current_account_sync_data")
```

### 2.3 新的数据流程

#### 账户同步流程
```
1. 从数据库获取账户列表
2. 更新 instance_accounts 表（维护账户存在状态）
   - 新账户：创建记录，设置 first_seen_date
   - 已存在账户：更新 last_seen_date
   - 检测删除：标记 is_active=False, 设置 deleted_at
3. 更新 current_account_sync_data 表（存储权限数据）
   - 比对权限变化
   - 记录变更日志到 account_change_log
```

#### 账户删除检测
```python
@classmethod
def detect_deleted_accounts(cls, instance_id: int) -> int:
    """
    检测并标记已删除的账户
    
    Args:
        instance_id: 实例ID
        
    Returns:
        int: 标记为已删除的账户数量
    """
    try:
        # 获取该实例最新的同步时间
        latest_sync = db.session.query(
            func.max(CurrentAccountSyncData.last_sync_time)
        ).filter_by(instance_id=instance_id).scalar()
        
        if not latest_sync:
            return 0
        
        # 查找在最新同步中没有更新的活跃账户
        active_accounts = cls.query.filter(
            cls.instance_id == instance_id,
            cls.is_active == True
        ).all()
        
        deleted_count = 0
        for instance_account in active_accounts:
            # 检查该账户在最新同步中是否有数据
            has_recent_data = CurrentAccountSyncData.query.filter(
                CurrentAccountSyncData.instance_id == instance_id,
                CurrentAccountSyncData.username == instance_account.username,
                CurrentAccountSyncData.last_sync_time == latest_sync
            ).first() is not None
            
            if not has_recent_data:
                # 标记为已删除
                instance_account.is_active = False
                instance_account.deleted_at = time_utils.now()
                instance_account.updated_at = time_utils.now()
                deleted_count += 1
        
        db.session.commit()
        return deleted_count
        
    except Exception as e:
        db.session.rollback()
        raise e
```

#### 账户状态更新
```python
@classmethod
def update_account_status(cls, instance_id: int, username: str, sync_date: date) -> None:
    """
    更新账户状态（当有新的同步时调用）
    
    Args:
        instance_id: 实例ID
        username: 账户名称
        sync_date: 同步日期
    """
    try:
        instance_account = cls.query.filter_by(
            instance_id=instance_id,
            username=username
        ).first()
        
        if instance_account:
            # 更新最后发现日期
            instance_account.last_seen_date = sync_date
            instance_account.updated_at = time_utils.now()
            
            # 如果之前被标记为删除，现在重新激活
            if not instance_account.is_active:
                instance_account.is_active = True
                instance_account.deleted_at = None
        else:
            # 创建新记录
            instance_account = cls(
                instance_id=instance_id,
                username=username,
                first_seen_date=sync_date,
                last_seen_date=sync_date,
                is_active=True
            )
            db.session.add(instance_account)
        
        db.session.commit()
        
    except Exception as e:
        db.session.rollback()
        raise e
```

### 2.4 修改同步服务

在 `account_data_manager.py` 中集成新的关系表：

```python
def sync_accounts(self, instance: Instance, connection: Any, session_id: str) -> dict[str, Any]:
    """
    统一的账户同步入口
    """
    try:
        # 获取对应的数据库适配器
        adapter = self._get_adapter(instance.db_type)
        if not adapter:
            return {"success": False, "error": f"不支持的数据库类型: {instance.db_type}"}
        
        # 使用适配器执行同步
        result = adapter.sync_accounts(instance, connection, session_id)
        
        # 同步成功后，更新 instance_accounts 表
        if result.get("success"):
            from app.models.instance_account import InstanceAccount
            from app.utils.time_utils import time_utils
            
            sync_date = time_utils.now_china().date()
            
            # 获取本次同步的所有账户
            synced_accounts = CurrentAccountSyncData.query.filter_by(
                instance_id=instance.id,
                session_id=session_id
            ).all()
            
            # 更新 instance_accounts 表
            for account_data in synced_accounts:
                InstanceAccount.update_account_status(
                    instance.id,
                    account_data.username,
                    sync_date
                )
            
            # 检测删除的账户
            deleted_count = InstanceAccount.detect_deleted_accounts(instance.id)
            if deleted_count > 0:
                self.sync_logger.info(
                    f"检测到 {deleted_count} 个已删除的账户",
                    instance_id=instance.id,
                    instance_name=instance.name
                )
        
        return result
        
    except Exception as e:
        self.sync_logger.error(
            "账户同步执行失败",
            instance_name=instance.name,
            error=str(e)
        )
        return {"success": False, "error": f"同步执行失败: {str(e)}"}
```

## 三、迁移计划

### 3.1 数据库迁移步骤

#### 步骤1：创建新表
```python
# migrations/versions/xxx_add_instance_accounts.py
def upgrade():
    # 创建 instance_accounts 表
    op.create_table(
        'instance_accounts',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('instance_id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(255), nullable=False),
        sa.Column('is_active', sa.Boolean(), nullable=False, default=True),
        sa.Column('first_seen_date', sa.Date(), nullable=False),
        sa.Column('last_seen_date', sa.Date(), nullable=False),
        sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.ForeignKeyConstraint(['instance_id'], ['instances.id']),
        sa.UniqueConstraint('instance_id', 'username', name='uq_instance_account_instance_username')
    )
    
    # 创建索引
    op.create_index('ix_instance_accounts_username', 'instance_accounts', ['username'])
    op.create_index('ix_instance_accounts_active', 'instance_accounts', ['is_active'])
    op.create_index('ix_instance_accounts_last_seen', 'instance_accounts', ['last_seen_date'])
```

#### 步骤2：迁移现有数据
```python
def upgrade():
    # ... 创建表的代码 ...
    
    # 从 current_account_sync_data 迁移数据到 instance_accounts
    connection = op.get_bind()
    
    # 获取所有唯一的 (instance_id, username) 组合
    result = connection.execute("""
        SELECT DISTINCT
            instance_id,
            username,
            MIN(sync_time) as first_seen,
            MAX(last_sync_time) as last_seen,
            CASE WHEN is_deleted THEN deleted_time ELSE NULL END as deleted_at,
            is_deleted
        FROM current_account_sync_data
        GROUP BY instance_id, username, is_deleted, deleted_time
    """)
    
    # 插入到 instance_accounts
    for row in result:
        connection.execute("""
            INSERT INTO instance_accounts 
            (instance_id, username, is_active, first_seen_date, last_seen_date, 
             deleted_at, created_at, updated_at)
            VALUES 
            (%s, %s, %s, %s, %s, %s, NOW(), NOW())
        """, (
            row.instance_id,
            row.username,
            not row.is_deleted,
            row.first_seen.date() if row.first_seen else date.today(),
            row.last_seen.date() if row.last_seen else date.today(),
            row.deleted_at
        ))
```

#### 步骤3：移除冗余字段（可选，建议保留一段时间）
```python
def upgrade():
    # 移除 current_account_sync_data 表中的删除标记字段
    # 注意：建议先保留这些字段，确认新架构稳定后再删除
    # op.drop_column('current_account_sync_data', 'is_deleted')
    # op.drop_column('current_account_sync_data', 'deleted_time')
    pass
```

### 3.2 代码迁移步骤

#### 阶段1：新增功能（不影响现有功能）
1. 创建 `instance_account.py` 模型文件
2. 在 `account_data_manager.py` 中添加 `instance_accounts` 更新逻辑
3. 添加单元测试验证新功能

#### 阶段2：并行运行（双写）
1. 同步时同时更新 `current_account_sync_data.is_deleted` 和 `instance_accounts.is_active`
2. 监控数据一致性
3. 修复发现的问题

#### 阶段3：切换到新架构
1. 修改所有查询账户状态的代码，从 `instance_accounts` 读取
2. 停止更新 `current_account_sync_data.is_deleted`
3. 验证功能正常

#### 阶段4：清理（可选）
1. 移除 `current_account_sync_data` 中的 `is_deleted` 和 `deleted_time` 字段
2. 清理相关的索引
3. 更新文档

## 四、收益分析

### 4.1 架构一致性
- 账户同步和数据库容量同步使用统一的设计模式
- 降低代码理解成本
- 便于新功能开发

### 4.2 性能提升
- `instance_accounts` 表结构简单，查询效率高
- 账户状态查询不需要扫描大量 JSON 字段
- 可以快速统计账户数量和分布

### 4.3 功能增强
- 支持账户生命周期追踪
- 支持账户存活时长统计
- 支持跨实例账户分析
- 支持账户增长趋势分析

### 4.4 维护性提升
- 职责分离，`instance_accounts` 管理存在状态，`current_account_sync_data` 管理权限数据
- 代码逻辑更清晰
- 便于扩展新功能

## 五、风险评估

### 5.1 数据迁移风险
- **风险**：现有数据迁移可能出现数据丢失或不一致
- **缓解措施**：
  - 在测试环境充分测试迁移脚本
  - 迁移前备份数据库
  - 采用双写策略，保留旧字段一段时间
  - 添加数据一致性检查脚本

### 5.2 兼容性风险
- **风险**：现有代码依赖 `is_deleted` 字段
- **缓解措施**：
  - 全局搜索所有使用 `is_deleted` 的代码
  - 逐步迁移，保持向后兼容
  - 添加过渡期的兼容层

### 5.3 性能风险
- **风险**：新增表可能影响同步性能
- **缓解措施**：
  - 批量更新 `instance_accounts`
  - 添加合适的索引
  - 监控同步性能指标

## 六、实施建议

### 6.1 优先级
- **高优先级**：创建 `instance_accounts` 表和基础功能
- **中优先级**：迁移现有数据，双写验证
- **低优先级**：清理旧字段

### 6.2 时间规划
- **第1周**：设计评审，创建新表和模型
- **第2周**：实现同步逻辑，编写单元测试
- **第3周**：数据迁移，双写验证
- **第4周**：切换到新架构，监控运行
- **第5周**：清理旧代码（可选）

### 6.3 回滚计划
如果新架构出现问题：
1. 停止使用 `instance_accounts` 表
2. 恢复使用 `current_account_sync_data.is_deleted`
3. 分析问题原因
4. 修复后重新部署

## 七、总结

通过引入 `instance_accounts` 关系表，可以：
1. 统一账户同步和数据库容量同步的架构设计
2. 分离账户存在状态和权限数据的管理职责
3. 提升查询性能和代码可维护性
4. 支持更丰富的账户分析功能

建议采用渐进式迁移策略，确保系统稳定性的同时完成架构升级。
