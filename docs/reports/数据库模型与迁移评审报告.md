# 数据库模型与迁移“查漏补缺式”评审报告

- 生成日期：2025-12-19
- 覆盖范围：`app/models/**`、`app/routes/**`、`app/services/**`、`migrations/**`、`sql/**`
- 阅读提示：仓库同时存在 ORM / Alembic / 初始化 SQL 三份 Schema 描述，且存在明显漂移；本报告以“当前代码在用的 ORM 模型”为主 ERD，并在每个对象后标注迁移/脚本差异点与风险。

> 更新说明（2025-12-19）：
> - 已以 `docs/reports/artifacts/public.sql` 为权威基准，重置 `sql/init_postgresql.sql` 并清空/重建 Alembic 历史（基线 revision：`20251219161048`）。
> - 因此，文中关于“初始化 SQL 与生产结构漂移/顺序错误”的部分结论与行号引用可能已过时；后续请以新基线与实际 ORM/查询差异为主。

I. “Schema 概览（文字 ERD）”
  （前置说明：仓库里同时存在三份 Schema 描述：ORM（app/models/**）、Alembic（migrations/**）、Postgres 初始化
  SQL（sql/init_postgresql.sql）。三者存在明显漂移；以下先以“当前代码在用的 ORM 模型”绘制主 ERD，并在每个对象后标
  注“脚本/迁移侧的差异点/额外对象”。）

  - 核心实体列表（按领域分组）
      - 账号与鉴权：users
      - 连接与资产：credentials、instances、database_type_configs
      - 标签：tags、instance_tags(M2M)
      - 账户清单与权限快照：instance_accounts、account_permission、account_change_log
      - 数据库清单：instance_databases
      - 同步会话：sync_sessions、sync_instance_records
      - 分类与规则：account_classifications、classification_rules、account_classification_assignments
      - 容量时序/聚合：database_size_stats、instance_size_stats、database_size_aggregations、
        instance_size_aggregations
      - 统一日志：unified_logs
      - 配置字典：permission_configs
  - 关键关系（1-1/1-N/N-N）
      - credentials (1) -> instances (N)：instances.credential_id -> credentials.id
      - instances (N) <-> tags (N)：经 instance_tags(instance_id, tag_id)
      - instances (1) -> instance_accounts (N)：instance_accounts.instance_id -> instances.id
      - instance_accounts (1) -> account_permission (0/1)：account_permission.instance_account_id ->
        instance_accounts.id（代码逻辑按“应当 1:1”使用）
      - instances (1) -> instance_databases (N)：instance_databases.instance_id -> instances.id
      - instances (1) -> database_size_stats (N)：database_size_stats.instance_id -> instances.id
      - instances (1) -> instance_size_stats (N)：instance_size_stats.instance_id -> instances.id
      - instances (1) -> database_size_aggregations (N)：database_size_aggregations.instance_id -> instances.id
      - instances (1) -> instance_size_aggregations (N)：instance_size_aggregations.instance_id -> instances.id
      - sync_sessions (1) -> sync_instance_records (N)：sync_instance_records.session_id ->
        sync_sessions.session_id（注意不是 FK 到 sync_sessions.id）
      - account_permission (1) -> account_classification_assignments (N)：
        account_classification_assignments.account_id -> account_permission.id
      - account_classifications (1) -> classification_rules (N)：classification_rules.classification_id ->
        account_classifications.id
      - account_classifications (1) -> account_classification_assignments (N)：
        account_classification_assignments.classification_id -> account_classifications.id
      - classification_rules (1) -> account_classification_assignments (0..N)：
        account_classification_assignments.rule_id -> classification_rules.id（可空）
      - users (1) -> account_classification_assignments (0..N)：account_classification_assignments.assigned_by ->
        users.id（可空）
  - 每张核心表的字段/约束/索引摘要（含分区/部分索引/Check）
      - users
          - 字段：id int PK；username varchar(255) NOT NULL UNIQUE；password varchar(255) NOT NULL；role
            varchar(50) NOT NULL DEFAULT 'user'；created_at timestamptz NOT NULL；last_login timestamptz NULL；
            is_active bool NOT NULL DEFAULT true
          - 索引：username（ORM：app/models/user.py:36；SQL 脚本也有 ix_users_username）
      - credentials
          - 字段：id int PK；name varchar(255) NOT NULL UNIQUE；credential_type varchar(50) NOT NULL；db_type
            varchar(50) NULL；username varchar(255) NOT NULL；password varchar(255) NOT NULL（密文）；
            description text NULL；instance_ids JSON NULL；category_id int NULL；is_active bool NOT NULL DEFAULT
            true；
            created_at/updated_at/deleted_at timestamptz
          - 索引：name(UNIQUE)、credential_type、db_type（见 app/models/credential.py:78-92）
          - 差异：sql/init_postgresql.sql 用 JSONB 存 instance_ids；迁移初始表结构（migrations/
            versions/52b93de0b351_创建初始表结构.py:21-40）也是 JSON（非 JSONB）。
      - instances
          - 字段：id int PK；name varchar(255) NOT NULL UNIQUE；db_type varchar(50) NOT NULL；host varchar(255) NOT
            NULL；port int NOT NULL；
            database_name varchar(255) NULL；database_version varchar(1000) NULL；main_version varchar(20) NULL；
            detailed_version varchar(50) NULL；
            sync_count int NOT NULL DEFAULT 0；credential_id int NULL FK credentials.id；description text NULL；
            is_active bool NOT NULL DEFAULT true；last_connected timestamptz NULL；created_at/updated_at/deleted_at
            timestamptz
          - 索引：name(UNIQUE)、db_type（app/models/instance.py:84-100）
          - 差异：
              - 迁移里曾引入 instances.environment（migrations/versions/add_environment_field_to_instances.py:21-
                23），ORM 当前未建模。
              - 旧 schema 曾有 instances.tags JSON（初始迁移 migrations/versions/52b93de0b351_创建初始表结
                构.py:117-120），后续迁移删除（migrations/
                versions/20250918122800_remove_old_tags_json_column.py:19-26）。
      - tags
          - 字段：id int PK；name varchar(50) NOT NULL UNIQUE；display_name varchar(100) NOT NULL；category
            varchar(50) NOT NULL；
            color varchar(20) NOT NULL DEFAULT 'primary'；is_active bool NOT NULL DEFAULT true；created_at/
            updated_at timestamptz
          - 索引：name(UNIQUE)、category（app/models/tag.py:28-35）
          - 差异：迁移曾创建 description/sort_order/deleted_at（migrations/
            versions/20250918120309_add_tags_table_and_instance_tags_relationship.py:20-36），后续仅删除
            description/sort_order（migrations/versions/20251208090000_remove_tag_description_and_sort_order.py:19-
            23）；ORM 当前不含 deleted_at。
      - instance_tags（M2M 关联表）
          - 字段：instance_id int PK+FK instances.id；tag_id int PK+FK tags.id；created_at timestamptz
          - 约束：复合主键 (instance_id, tag_id)（app/models/tag.py:182-188）
          - 索引：仅靠 PK（无 tag_id 单列索引）
      - instance_accounts
          - 字段：id int PK；instance_id int NOT NULL FK instances.id；username varchar(255) NOT NULL；db_type
            varchar(50) NOT NULL；
            is_active bool NOT NULL DEFAULT true；first_seen_at/last_seen_at timestamptz NOT NULL；deleted_at
            timestamptz NULL；created_at/updated_at timestamptz NOT NULL
          - 约束：UNIQUE(instance_id, db_type, username)（app/models/instance_account.py:49-57）
          - 索引：instance_id、username、is_active、last_seen_at
          - 差异：sql/init_postgresql.sql 额外有 attributes JSONB（sql/init_postgresql.sql:900-912），ORM 未建模。
      - account_permission
          - 基类字段（来自 BaseSyncData）：id int PK；instance_id int NOT NULL FK instances.id (index)；db_type
            varchar(20) NOT NULL (index)（app/models/base_sync_data.py:21-41）
          - 自有字段：instance_account_id int NOT NULL FK instance_accounts.id (index)；username varchar(255) NOT
            NULL；
            is_superuser bool DEFAULT false；is_locked bool NOT NULL DEFAULT false (index)；
            大量权限字段（按 db_type 拆列）：global_privileges/database_privileges/... + type_specific（均为 JSON）
            last_sync_time timestamptz (index)；last_change_type varchar(20) DEFAULT 'add'；last_change_time
            timestamptz (index)
          - 约束：UNIQUE(instance_id, db_type, username)（app/models/account_permission.py:40-44）
          - 索引：(instance_id, db_type)、username、is_locked、last_sync_time、last_change_time
          - 差异：SQL 脚本用 JSONB，且脚本版本未包含 is_locked（见 sql/init_postgresql.sql:152-195）。
      - account_change_log
          - 字段：id int PK；instance_id int NOT NULL FK instances.id (index)；db_type varchar(20) NOT NULL
            (index)；username varchar(255) NOT NULL (index)；
            change_type varchar(50) NOT NULL；change_time timestamptz (index)；session_id varchar(36) NULL；status
            varchar(20) DEFAULT 'success'；message text NULL；
            privilege_diff JSON NULL；other_diff JSON NULL
          - 索引：(instance_id, db_type, username, change_time)、(change_type, change_time)、(username,
            change_time)（app/models/account_change_log.py:54-61）
          - 差异：脚本用 JSONB（sql/init_postgresql.sql:388-409）；且 session_id 未 FK 到
            sync_sessions.session_id。
      - instance_databases
          - 字段：id int PK；instance_id int NOT NULL FK instances.id；database_name varchar(255) NOT NULL；
            is_active bool NOT NULL DEFAULT true；first_seen_date date NOT NULL DEFAULT today；last_seen_date date
            NOT NULL DEFAULT today；
            deleted_at timestamptz NULL；created_at/updated_at timestamptz NOT NULL
          - 约束：UNIQUE(instance_id, database_name)（app/models/instance_database.py:52-58）
          - 索引：instance_id、database_name、is_active、last_seen_date
      - account_classifications
          - 字段：id int PK；name varchar(100) NOT NULL UNIQUE；description text NULL；risk_level varchar(20) NOT
            NULL DEFAULT 'medium'；
            color varchar(20) NULL；icon_name varchar(50) NULL DEFAULT 'fa-tag'；priority int DEFAULT 0；
            is_system bool NOT NULL DEFAULT false；is_active bool NOT NULL DEFAULT true；created_at/updated_at
            timestamptz
          - 关系：classification_rules、account_classification_assignments（app/models/
            account_classification.py:58-79）
      - classification_rules
          - 字段：id int PK；classification_id int NOT NULL FK account_classifications.id；db_type varchar(20) NOT
            NULL；
            rule_name varchar(100) NOT NULL；rule_expression text NOT NULL（JSON 字符串）；
            is_active bool NOT NULL DEFAULT true；created_at/updated_at timestamptz
          - 差异：用 TEXT 存 JSON，缺少 schema_version / 校验约束。
      - account_classification_assignments
          - 字段：id int PK；account_id int NOT NULL FK account_permission.id；classification_id int NOT NULL FK
            account_classifications.id；
            rule_id int NULL FK classification_rules.id；assigned_by int NULL FK users.id；
            assignment_type varchar(20) NOT NULL DEFAULT 'auto'；confidence_score float NULL；notes text NULL；
            batch_id varchar(36) NULL；
            is_active bool NOT NULL DEFAULT true；assigned_at timestamptz；created_at/updated_at timestamptz
          - 约束：UNIQUE(account_id, classification_id, batch_id)（注意 batch_id NULL 时不去重）（app/models/
            account_classification.py:231-238）
          - 迁移：assigned_at 是后加列并回填（migrations/
            versions/9b3c2f1e8b70_add_assigned_at_to_account_classification_assignments.py:22-41）。
      - sync_sessions
          - 字段：id int PK；session_id varchar(36) NOT NULL UNIQUE；sync_type varchar(20) NOT NULL；sync_category
            varchar(20) NOT NULL DEFAULT 'account'；
            status varchar(20) NOT NULL DEFAULT 'pending'；started_at/completed_at timestamptz NULL；
            total_instances/successful_instances/failed_instances int DEFAULT 0；created_by int NULL；created_at/
            updated_at timestamptz
          - 差异：SQL 脚本对 sync_type/sync_category/status 有 CHECK（sql/init_postgresql.sql:236-259），ORM/迁移侧
            未统一体现。
      - sync_instance_records
          - 字段：id int PK；session_id varchar(36) NOT NULL FK sync_sessions.session_id (index)；instance_id int
            NOT NULL FK instances.id (index)；
            instance_name varchar(255)；sync_category varchar(20) NOT NULL DEFAULT 'account'；status varchar(20)
            NOT NULL DEFAULT 'pending'；
            started_at/completed_at timestamptz NULL；items_synced/items_created/items_updated/items_deleted int
            DEFAULT 0；
            error_message text NULL；sync_details JSON NULL；created_at timestamptz
          - 差异：SQL 脚本为该 FK 设了 ON DELETE CASCADE（sql/init_postgresql.sql:262-274），ORM 未显式声明。
      - database_size_stats（时序明细，宣称分区）
          - ORM 字段：id bigint PK(index)；instance_id int NOT NULL FK instances.id；database_name varchar(255) NOT
            NULL；
            size_mb bigint NOT NULL；data_size_mb/log_size_mb bigint NULL；
            collected_date date NOT NULL；collected_at/created_at/updated_at timestamptz NOT NULL
          - ORM 约束/索引：UNIQUE(instance_id, database_name, collected_date)；索引 collected_date、(instance_id,
            collected_date)（app/models/database_size_stat.py:47-103）
          - SQL 脚本：父表是 PARTITION BY RANGE (collected_date) 且没有主键，仅有 UNIQUE(instance_id,
            database_name, collected_date)（sql/init_postgresql.sql:615-627）；并存在自动建分区触发器与视图（sql/
            init_postgresql.sql:1109-1157）。
      - instance_size_stats（时序汇总，宣称分区）
          - ORM 字段：id int PK；instance_id int NOT NULL FK instances.id(index)；total_size_mb int NOT NULL
            DEFAULT 0；database_count int NOT NULL DEFAULT 0；
            collected_date date NOT NULL(index)；collected_at timestamptz NOT NULL；is_deleted bool NOT NULL
            DEFAULT false(index)；deleted_at timestamptz NULL；
            created_at/updated_at timestamptz
          - SQL 脚本：父表 PARTITION BY RANGE(collected_date) 且 PRIMARY KEY(id, collected_date)（sql/
            init_postgresql.sql:630-642）；并额外依赖部分唯一索引：
            UNIQUE(instance_id, collected_date) WHERE is_deleted = FALSE（sql/init_postgresql.sql:854-856），代码
            upsert 也依赖该索引（app/services/database_sync/persistence.py:165-180）。
          - 迁移：存在一个“非分区版”的建表迁移（migrations/versions/add_instance_size_stats_table.py:21-47），与脚
            本/分区服务不一致。
      - database_size_aggregations（聚合明细，宣称分区）
          - ORM 字段：id bigint PK(index)；instance_id int NOT NULL FK instances.id；database_name varchar(255) NOT
            NULL；
            period_type varchar(20) NOT NULL；period_start/period_end date NOT NULL；
            各类统计字段（avg/max/min/data_count + change_* + growth_rate）；
            calculated_at/created_at timestamptz NOT NULL
          - ORM 约束：UNIQUE(instance_id, database_name, period_type, period_start)；索引 (instance_id,
            period_type, period_start)、(period_type, period_start)（app/models/database_size_aggregation.py:100-
            122）
          - SQL 脚本：父表 PARTITION BY RANGE(period_start)，但脚本中未看到对应唯一约束/外键/时区一致性（sql/
            init_postgresql.sql:645-671 + sql/init_postgresql.sql:776-778）。
      - instance_size_aggregations（聚合明细，宣称分区）
          - ORM 约束：UNIQUE(instance_id, period_type, period_start)（app/models/instance_size_aggregation.py:110-
            122）
          - SQL 脚本：父表 PARTITION BY RANGE(period_start)，脚本用 ALTER TABLE ... ADD CONSTRAINT
            uq_instance_size_aggregation UNIQUE(...)（sql/init_postgresql.sql:848-852）。
      - permission_configs
          - 字段：id int PK；db_type varchar(50) NOT NULL；category varchar(50) NOT NULL；permission_name
            varchar(255) NOT NULL；
            description text NULL；is_active bool DEFAULT true；sort_order int DEFAULT 0；created_at/updated_at
            timestamptz
          - 约束：UNIQUE(db_type, category, permission_name)；索引：db_type、category（app/models/
            permission_config.py:46-51）
      - database_type_configs
          - 字段：id int PK；name varchar(50) NOT NULL UNIQUE；display_name varchar(100) NOT NULL；driver
            varchar(50) NOT NULL；
            default_port int NOT NULL；default_schema varchar(50) NOT NULL；connection_timeout int DEFAULT 30；
            description text；icon/color；features text(JSON 字符串)；
            is_active/is_system bool；sort_order int；created_at/updated_at timestamptz
          - 差异：迁移里大量列是 nullable=True（migrations/
            versions/7f722a6f9bcf_add_database_type_config_table.py:21-40），ORM 侧缺少一致的 NOT NULL/默认值约束。
      - unified_logs
          - ORM：level 是 Postgres Enum（app/models/unified_log.py:60）
          - SQL 脚本：level varchar + CHECK（sql/init_postgresql.sql:363-371）
          - 索引：timestamp/level/module + 复合索引 idx_timestamp_level_module 等（ORM：app/models/
            unified_log.py:68-72；脚本：sql/init_postgresql.sql:375-381）
  - 迁移/脚本中额外出现但当前 ORM 未建模（需作为“遗留/漂移风险”纳入）
      - classification_batches（迁移创建：migrations/versions/1e673649d16b_添加classification_batches表.py:21-42；
        脚本创建：sql/init_postgresql.sql:331-349；当前无 ORM 模型/无引用）
      - apscheduler_jobs（脚本创建：sql/init_postgresql.sql:416-420；迁移曾 drop_table：migrations/
        versions/1e673649d16b_添加classification_batches表.py:43-46；存在“调度持久化表”治理问题）
      - 历史表（迁移仍出现）：logs/accounts/sync_data/account_changes/tasks/global_params/...（当前代码基本不引用，
        但可能仍在生产库中占空间/带来迁移锁表风险）

  ———

  II. “缺口地图”（按 1~8 维度逐条给：缺口描述 + 我应该补写的建模规范/ADR 标题）

  1. 实体与关系建模（Modeling）

  - 缺口：同一业务概念同时存在“旧表/新表/脚本对象”（例如账户相关：accounts/sync_data/account_changes vs
    instance_accounts/account_permission/account_change_log），导致领域边界不清、清理困难。
  - 缺口：account_permission 同时持有 (instance_id, db_type, username) 与 instance_account_id，但缺少“跨字段一致性
    约束”（无法防止 instance_account_id 指向别的实例）。
  - 缺口：容量聚合/明细在 ORM 中按“普通表”建模，但运行时依赖“分区 + 触发器 + Python 分区管理服务”，建模层没有显式表
    达（分区键、复合主键、分区约束）。
  - ADR 建议：
      - ADR: 领域模型边界与表生命周期（Legacy→Current）
      - ADR: 分区时序表的键设计与ORM映射规范（PK/UK/分区键）

  2. 字段设计（Columns）

  - 缺口：JSON/JSONB 混用（ORM 多为 db.JSON，脚本多为 JSONB），并且部分 JSON 以 TEXT 存储
    （classification_rules.rule_expression、database_type_configs.features）。
  - 缺口：时区字段不一致（例如脚本的聚合表 calculated_at/created_at 使用 TIMESTAMP WITHOUT TIME ZONE，ORM 用
    timezone=True）。
  - 缺口：Nullability/默认值不统一（迁移中大量 nullable=True，ORM/脚本则期望 NOT NULL + default）。
  - ADR 建议：
      - ADR: 时间字段与时区统一策略（UTC存储/展示转换）
      - ADR: JSON 字段规范（JSONB + schema_version + 校验/索引策略）
      - ADR: NULL/默认值与软删除字段规范（避免默认值掩盖数据问题）

  3. 约束与数据完整性（Integrity）

  - 缺口：关键唯一性约束在“脚本/ORM/迁移”之间不一致（database_size_aggregations 脚本侧疑似缺失唯一约束；
    instance_size_stats 的部分唯一索引只在脚本/迁移存在，ORM 未声明）。
  - 缺口：外键 ON DELETE 行为未统一（脚本对部分表设 CASCADE，ORM/迁移未显式；批量删除依赖手工删除链）。
  - 缺口：缺少 CHECK 约束（risk_level、assignment_type、sync_status、change_type、size>=0 等），脚本侧部分有，ORM/
    迁移缺。
  - ADR 建议：
      - ADR: 数据完整性约束基线（FK/UK/CHECK/部分唯一索引）
      - ADR: 删除语义（硬删/软删/级联/RESTRICT）的统一决策

  4. 索引与性能（Performance）

  - 缺口：存在多处“加载全量→Python 去重/计数”的模式，数据量增长后必炸（OOM/慢查询）。
  - 缺口：instance_tags 仅有 (instance_id, tag_id) PK，缺少 tag_id 侧索引，按标签过滤实例可能退化。
  - 缺口：日志检索使用 LIKE '%term%' + cast(context as text)，缺少全文/Trigram 索引与保留策略。
  - ADR 建议：
      - ADR: 查询/分页/聚合规范（避免 .all()、窗口函数、keyset分页）
      - ADR: 索引命名与复合/部分索引准则（含分区表索引策略）
      - ADR: 日志检索与归档方案（FTS/pg_trgm/分区/TTL）
  - B. 关键用例反推（Top 10 查询/写入路径）
      1. 实例列表（筛选+排序+标签）
          - 位置：app/routes/instances/manage.py:93（last_sync 子查询）/app/routes/instances/
            manage.py:119（filters）/app/routes/instances/manage.py:174（指标聚合）
          - 表：instances、instance_tags、tags、instance_databases、instance_accounts、sync_instance_records
          - 依赖索引：tags.name、instance_tags（建议补 tag_id 索引）、sync_instance_records(instance_id,
            completed_at)、instance_databases(instance_id,is_active)、instance_accounts(instance_id,is_active)
          - 风险：标签筛选 join 方向不稳定；last_sync group_by 在大库上耗时；多处 count/group_by 需复合索引支撑。
      2. 实例详情-容量“最新一条/每库最新”（当前实现全量拉取再去重）
          - 位置：app/routes/instances/detail.py:600-669
          - 表：database_size_stats（分区大表）、instance_databases
          - 风险：records = query.order_by(...).all() 会拉取该实例所有历史容量行；数据库数×天数增长后必 OOM/超时；
            且用 lower() 去重但 DB 侧唯一约束是大小写敏感，存在数据不一致窗口。
      3. 实例详情-容量历史分页（count + offset/limit）
          - 位置：app/routes/instances/detail.py:701-723
          - 表：同上
          - 风险：分区大表 count() 成本高；offset 深分页退化；建议 keyset。
      4. 分区页“核心指标窗口”（四张大表 .all()）
          - 位置：app/routes/partition.py:185-209
          - 表：database_size_stats、instance_size_stats、database_size_aggregations、instance_size_aggregations
          - 风险：窗口稍大就全量拉；应改为按天/周期 COUNT(*) GROUP BY，只取统计数不取明细。
      5. 仪表盘-账户汇总（.all() 后 Python 统计）
          - 位置：app/services/statistics/account_statistics_service.py:83-109
          - 表：account_permission、instance_accounts、instances
          - 风险：账户量大时直接打爆；应改 SQL 侧聚合（COUNT + CASE）。
      6. 仪表盘-容量汇总（最近 N 天 .all() 后取每实例最新）
          - 位置：app/services/statistics/instance_statistics_service.py:92-107
          - 表：instance_size_stats（分区表）
          - 风险：按实例数×天数拉取；应使用 DISTINCT ON(instance_id) ORDER BY collected_date desc 或窗口函数。
      7. 容量采集写入（数据库明细 upsert）
          - 位置：app/services/database_sync/persistence.py:82-97
          - 表：database_size_stats
          - 依赖约束：UNIQUE(instance_id, database_name, collected_date)（迁移也在加：migrations/
            versions/20251106090000_add_unique_constraint_database_size_stats.py:39-45）
          - 风险：高写入时冲突检查与分区路由；需要稳定分区创建策略 + 合理索引（(instance_id, database_name)、
            (instance_id, collected_date)）。
      8. 容量采集写入（实例汇总 upsert，依赖部分唯一索引）
          - 位置：app/services/database_sync/persistence.py:165-180
          - 表：instance_size_stats
          - 依赖约束：UNIQUE(instance_id, collected_date) WHERE is_deleted = FALSE（脚本：sql/
            init_postgresql.sql:854-856；迁移：migrations/versions/add_instance_size_stats_table.py:44-47）
          - 风险：一旦换 DB/换建表方式缺失该索引，upsert 直接失败（不可移植）。
      9. 数据库聚合写入（查询后更新/插入）
          - 位置：app/services/aggregation/database_aggregation_runner.py:404-451
          - 表：database_size_aggregations、database_size_stats
          - 风险：若唯一约束缺失会产生重复聚合；多实例多库循环写入，需批处理与幂等 upsert。
     10. 日志检索（LIKE + JSON cast）
      - 位置：app/routes/history/logs.py:175-198
      - 表：unified_logs
      - 风险：LIKE '%xxx%' + cast(context as text) 基本不走索引；日志量大后只能靠 TTL/分区/FTS。

  5. 迁移与版本演进（Migrations & Evolution）

  - 缺口：Alembic 版本链存在多个 down_revision=None 的“伪 merge”节点，导致历史不可线性复现（例如 migrations/
    versions/149e99b0e628_merge_heads.py:13-16、migrations/versions/23ac7130f35d_.py:13-16、migrations/
    versions/631ec553cf2e_merge_heads.py:13-16）。
  - 缺口：分区/触发器/视图等 DB 对象主要在 sql/init_postgresql.sql 中定义，迁移未纳管；且脚本自身存在顺序/缺表问题
    （例如先建 account_permission 却引用后建的 instance_accounts：sql/init_postgresql.sql:152-156 vs sql/
    init_postgresql.sql:899-905；脚本还插入 global_params 但未创建表）。
  - 缺口：存在“直接 drop 列/直接 alter 类型/大表上直接加约束 + 全表去重 DML”的模式，缺少零停机分阶段模板（参考
    migrations/versions/20251106090000_add_unique_constraint_database_size_stats.py:21-45）。
  - ADR 建议：
      - ADR: 迁移分阶段策略（add nullable → backfill → add constraint → cleanup）
      - ADR: 分区表/触发器/视图的 Alembic 纳管方式（op.execute + 可回滚策略）
      - ADR: Schema Source of Truth 与 Drift Guard（CI 演练/对账）

  6. 事务与并发一致性（Concurrency）

  - 缺口：账户权限写入走“先查再插/改”的模式，依赖唯一约束兜底但未做 ON CONFLICT，并发时可能出现
    IntegrityError（app/services/accounts_sync/permission_manager.py:240-252 + db.session.add）。
  - 缺口：聚合写入同样是“先查再写”，缺少幂等键/唯一约束时会重复。
  - 缺口：批量删除/清理依赖应用侧手工删除链，缺少 DB 级 CASCADE/RESTRICT 明确策略（app/services/instances/
    batch_service.py:359-405）。
  - ADR 建议：
      - ADR: 幂等写入与并发冲突处理（ON CONFLICT、幂等键、乐观锁）
      - ADR: 后台任务重复执行的 DB 兜底策略（唯一约束/去重表）

  7. 安全与数据治理（Governance）

  - 缺口：credentials 与 unified_logs.context 均可能承载敏感信息，缺少“字段级脱敏/红线字段禁止落库/访问审计”规范。
  - 缺口：unified_logs、account_change_log、database_size_stats 等增长型表缺少统一的保留/归档策略（容量表有分区清理
    服务；日志/变更日志没有同等级策略）。
  - ADR 建议：
      - ADR: 敏感数据治理（加密/脱敏/访问审计/最小化存储）
      - ADR: 增长型表的保留与归档（分区/TTL/冷热分层）

  8. 兼容/防御/回退/适配（重点关注兜底）

  - 缺口：大量“空值兜底/旧字段推导/旧数据回填”散落在业务代码，缺少命中率埋点与退场计划；例如锁定状态从
    type_specific 推导到 is_locked，但各处 key 不统一。
  - 缺口：强依赖 Postgres 特性（分区、部分索引、ON CONFLICT、JSONB 操作），但在代码/配置层缺少“明确声明仅支持
    Postgres”的防御门禁。
  - ADR 建议：
      - ADR: 字段兼容与回填退场流程（埋点→回填→强约束→移除兜底）
      - ADR: 数据库方言边界（Postgres-only）与多环境一致性策略

  ———

  III. “模型设计问题清单”（按 P0/P1/P2 分组；每条包含）
  （C. 核心实体逐条审查：先给“职责/耦合/可演进性”结论，再在问题清单里落证据与方案）

  - Instance：职责清晰（资产主表），但存在历史字段漂移（environment/status/tags JSON），建议用“状态机字段规范 + 软
    删除规范”收敛。
  - Credential：加密思路正确，但 instance_ids(JSON) 与 instances.credential_id 存在冗余与一致性风险；建议只保留关系
    一侧或引入关系表。
  - Tag/instance_tags：模型简洁，但索引设计对“按 tag 找 instance”的查询不友好（缺 tag_id 索引）。
  - InstanceAccount/AccountPermission：一个是“清单”，一个是“快照”，方向正确；但两者之间缺少一致性约束（可能跨实例串
    联）；同时 JSON/JSONB 与 is_locked 演进不一致。
  - DatabaseSizeStat/InstanceSizeStat/聚合表：明确是“时序大表”，但 PK/分区/索引/迁移纳管不统一，属于当前最大演进风
    险点。
  - UnifiedLog：索引布局尚可，但检索需求（模糊/全文）与存储类型（Enum vs varchar+check）和归档策略不匹配。
  - SyncSession/SyncInstanceRecord：实体划分合理；但 FK 指向 session_id 而非 id，需要明确这是“业务主键”并补齐约束/
    索引策略。
  - AccountClassification*：拆分合理；但 assignment 的唯一性语义（batch_id NULL）与 assigned_at/default 的写入方式
    （bulk_insert）需要规范。

  （D. 迁移可演进审查摘要：停机/锁表/不可复现/不可滚动发布模式）

  - 多个迁移文件 down_revision=None 造成多根分支，必须依赖手工 merge 才能收敛（但目前还存在“空 merge 节点”）。
  - 分区表与触发器/视图主要靠 sql/init_postgresql.sql，迁移仅覆盖局部列变更 → 新环境无法仅靠 Alembic 复现。
  - 大表上直接 DELETE ... 去重 + ALTER TABLE ADD CONSTRAINT（migrations/
    versions/20251106090000_add_unique_constraint_database_size_stats.py:21-45）可能长时间锁表；需要分批/并发友好策
    略。

  P0

  1. 标题：Schema “三头管理 + 迁移链断裂”导致不可复现、不可滚动发布

	  - 证据：
	      - 迁移头节点无父：migrations/versions/149e99b0e628_merge_heads.py:13、migrations/
	        versions/23ac7130f35d_.py:13、migrations/versions/631ec553cf2e_merge_heads.py:13
	      - 迁移版本脚本被 .gitignore 排除，存在未版本控制风险：.gitignore:44（migrations/versions/*.py）
	      - SQL 初始化脚本承担大量 DDL/触发器/视图：sql/init_postgresql.sql:615、sql/init_postgresql.sql:1127
  - 影响：
      - 最坏：新环境无法 alembic upgrade head 成功；老环境无法安全升级；出现“同代码不同库结构”的隐性事故。
      - 最可能：某次新增列/索引只改了脚本或只改了迁移，导致线上/测试环境行为不一致。
  - 根因：没有单一 Source of Truth；Alembic 版本线被多次错误生成/提交；脚本与迁移职责混淆。
  - 建议：
      - 短期（1~3 天）：冻结 schema 入口，明确“生产变更只能走 Alembic”；补一个“schema drift 检查清单”（至少：表是否
        存在、关键约束/索引是否存在、分区父表是否分区）。
      - 中期（1~2 周）：做一次“迁移重整/压缩（squash）”：生成一个“当前可复现基线迁移”+ 线性 down_revision；把
        init_postgresql.sql 缩减为“扩展/角色/种子数据”，禁止再放 DDL。
      - 长期：CI 增加“空库演练：建库→alembic upgrade head→跑关键查询 EXPLAIN 基线”。
  - 验证：
      - 演练：新建空库，执行 alembic upgrade head，确认 0 error，且分区父表 \d+ database_size_stats 显示 PARTITION
        BY。
      - 对账 SQL：导出 pg_catalog（表/约束/索引/触发器/视图）并与“期望清单”diff。

  2. 标题：分区时序表的 PK/分区键/ORM 映射不一致，存在 ORM identity 与数据约束隐患

  - 证据：
      - ORM 把 database_size_stats.id 作为 PK：app/models/database_size_stat.py:47
      - 脚本把 database_size_stats 定义为分区父表且未定义 PK：sql/init_postgresql.sql:615-627
      - 脚本把 instance_size_stats 定义为分区父表且 PK 为 (id, collected_date)：sql/init_postgresql.sql:630-642；但
        ORM 只标 id：app/models/instance_size_stat.py:33
      - 代码运行期依赖 CREATE TABLE ... PARTITION OF ...：app/services/partition_management_service.py:165-168
  - 影响：
      - 最坏：分区创建失败（父表非分区表）；或出现“同 id 不同分区键”的重复导致 ORM 更新/删除误命中；或 upsert/唯一
        约束与实际 DDL 不匹配。
      - 最可能：测试库（非分区版）与生产库（分区版）行为不一致，线上才暴露慢查询/约束错误。
  - 根因：分区设计没有被 Alembic/ORM 同步表达；脚本与迁移存在两套建表方式。
  - 建议：
      - 短期：明确分区表“主键策略”——推荐二选一：
          - 方案A（更贴合业务）：用业务唯一键做 PK（例如 database_size_stats 用 (instance_id, database_name,
            collected_date)），去掉 id 或仅保留非 PK 的 surrogate id；
          - 方案B（保留 surrogate）：PK 设为 (collected_date, id)/(period_start, id)，并额外保留业务唯一约束。
      - 中期：把分区父表 DDL 纳入 Alembic（用 op.execute 创建 PARTITION BY RANGE），并把 ORM primary_key 与 DB 保持
        一致（必要时使用复合 PK）。
      - 长期：抽象“分区表变更模板”（加列/改类型/加索引如何在 parent+partitions 上零停机执行）。
  - 验证：
      - SQL：SELECT conname, pg_get_constraintdef(oid) FROM pg_constraint WHERE
        conrelid='instance_size_stats'::regclass;
      - ORM：对同一张表做 session.get(Model, pk) 验证是否唯一命中；对分区插入跨月数据验证 PK/UK 行为。

  3. 标题：database_size_aggregations 脚本侧疑似缺失业务唯一约束，聚合写入存在重复风险

  - 证据：
      - ORM 要求唯一：app/models/database_size_aggregation.py:115-121（uq_database_size_aggregation）
      - 脚本建表未看到对应 UNIQUE：sql/init_postgresql.sql:645-671
      - 写入逻辑按“唯一”使用 .first()：app/services/aggregation/database_aggregation_runner.py:404-409
  - 影响：
      - 最坏：同一实例同一库同一周期出现多条聚合，报表/趋势误判；后续修复需要全量去重与回填，成本很高。
      - 最可能：并发/重跑任务时产生重复聚合，UI 取到随机一条（.first() 无序）。
  - 根因：唯一约束在脚本/迁移未统一；写入缺少幂等 upsert。
  - 建议：
      - 短期：补齐 DB 侧 UNIQUE(instance_id, database_name, period_type, period_start)（分区表注意必须包含分区
        键）；并在写入前加“重复检测告警”。
      - 中期：写入改为 Postgres upsert（ON CONFLICT ... DO UPDATE），彻底幂等。
      - 长期：为聚合任务引入 idempotency_key = hash(instance_id+db+period_type+period_start) 并在 DB 侧唯一。
  - 验证：
      - 查重 SQL：
          - SELECT instance_id,database_name,period_type,period_start,count(*) FROM database_size_aggregations
            GROUP BY 1,2,3,4 HAVING count(*)>1;
      - 压测：并发跑同一聚合窗口，确认最终行数不增长且数据一致。

  4. 标题：多条关键路径使用 .all() 拉全量再 Python 计算，数据量增长后会 OOM/超时

  - 证据：
      - 分区页拉四张表全量：app/routes/partition.py:185-207
      - 容量最新记录“全量拉取再去重”：app/routes/instances/detail.py:607-626
      - 账户汇总 .all()：app/services/statistics/account_statistics_service.py:83-106
      - 容量汇总 .all()：app/services/statistics/instance_statistics_service.py:92-107
  - 影响：数据量到百万级行后，单次请求可能占用 GB 级内存/CPU；导致 API 超时、worker 被 OOM kill。
  - 根因：缺少“查询下推规范”；未使用窗口函数/聚合查询；分页用 offset+count。
  - 建议：
      - 短期：把“计数/最新一条”改为 SQL 聚合（COUNT、MAX、DISTINCT ON/row_number）。
      - 中期：对大表接口统一 keyset pagination；对仪表盘类查询增加缓存与预聚合表。
      - 长期：建立“Top SQL 观测 + 慢查询基线 + 索引回归测试”。
  - 验证：
      - 为每条 Top 查询补 EXPLAIN (ANALYZE, BUFFERS) 基线；确保 rows/loops/时间随数据增长近似线性或被分区剪枝。
      - 在 staging 造数据：database_size_stats 至少千万行量级演练。

  P1
  5) 标题：标签筛选缺少 instance_tags(tag_id) 索引，按标签过滤实例可能退化

  - 证据：
      - 关联表仅复合 PK：app/models/tag.py:182-188
      - 查询路径按 tag 过滤：app/routes/instances/manage.py:140-147
      - SQL 脚本同样无 tag_id 索引：sql/init_postgresql.sql:138-144
  - 影响：instance_tags 行数增长（实例×标签）后，标签筛选变慢；影响实例列表与批量操作。
  - 根因：索引列顺序未覆盖“从 tag_id 驱动 join”的访问路径。
  - 建议：
      - 短期：增加 CREATE INDEX ... ON instance_tags(tag_id, instance_id)（不改 PK，风险最小）。
      - 中期：若标签筛选成为核心场景，再评估是否要把 PK 顺序调整为 (tag_id, instance_id) 并给 instance_id 加二级索
        引。
  - 验证：
      - EXPLAIN (ANALYZE, BUFFERS) 对比加索引前后，观察是否从 Seq Scan 变 Index Scan/Bitmap Index Scan。

  6. 标题：account_permission.is_locked 回填逻辑与应用侧 fallback key 不一致（SQLServer 场景）

  - 证据：
      - 回填用 type_specific->>'is_disabled'：migrations/
        versions/20251109090000_add_is_locked_to_account_permission.py:36-39
      - SQLServer adapter 写入 type_specific.is_disabled：app/services/accounts_sync/adapters/
        sqlserver_adapter.py:174-177
      - 统计 fallback 读取 type_specific.is_locked：app/services/statistics/account_statistics_service.py:48-49
  - 影响：在 is_locked 为空/旧数据未回填时，锁定统计与展示可能错误。
  - 根因：字段命名未统一、缺少“数据字典/协议版本”。
  - 建议：
      - 短期：把 SQLServer fallback 改为读 is_disabled（并保留兼容读 is_locked）。
      - 中期：引入 type_specific.schema_version 并在写入端统一键名。
  - 验证：
      - 构造一条 type_specific={"is_disabled": true} 的账号记录，跑统计逻辑应计入 locked。

  7. 标题：instance_size_stats upsert 强依赖“部分唯一索引”，但 ORM 未显式声明，易产生环境差异

  - 证据：
      - upsert 依赖 index_where is_deleted=false：app/services/database_sync/persistence.py:165-180
      - 索引在脚本/迁移里有：sql/init_postgresql.sql:854-856、migrations/versions/
        add_instance_size_stats_table.py:44-47
      - ORM 模型未声明该唯一性：app/models/instance_size_stat.py:31-44
  - 影响：在非脚本初始化的环境（或迁移链断裂环境）会出现 upsert 运行时报错；或产生重复行导致统计错误。
  - 根因：约束不在同一个“声明面”维护。
  - 建议：
      - 短期：把该部分唯一索引写进 Alembic（若已存在则确保迁移可幂等），并在 ORM 中用注释/显式 Index（Postgres-
        only）声明。
      - 中期：统一“建库方式”，保证所有环境一致具备该索引。
  - 验证：
      - SQL：SELECT indexdef FROM pg_indexes WHERE tablename='instance_size_stats' AND
        indexname='uq_instance_size_stats_instance_date';

  8. 标题：unified_logs.level 在 ORM(Enum) 与脚本(varchar+check)不一致，迁移与反射风险高

  - 证据：
      - ORM Enum：app/models/unified_log.py:60
      - 脚本 varchar+check：sql/init_postgresql.sql:363-371
  - 影响：Alembic autogenerate/反射可能反复产生“改类型”迁移；不同环境写入/比较行为差异。
  - 根因：缺少“枚举字段落库策略”统一 ADR。
  - 建议：
      - 短期：二选一统一：
          - 统一用 native enum（脚本也改为 CREATE TYPE log_level ... + column enum）
          - 或统一用 varchar+check（ORM Enum 设置 native_enum=False/create_constraint=True）
      - 中期：为日志表增加检索/归档策略（FTS/pg_trgm/分区/TTL）。
  - 验证：
      - \d unified_logs 对比各环境 column type；确保一致。

  9. 标题：account_permission(instance_id, username) 等高频查询缺少更贴合的复合索引

  - 证据：
      - 常用查询：app/services/accounts_sync/account_query_service.py:28-33
      - 现有索引是 (instance_id, db_type) 与 username：app/models/account_permission.py:40-44
  - 影响：大实例下按 instance_id 拉列表需要额外排序/回表；性能波动。
  - 根因：索引按“理论唯一键”建，但没覆盖“按实例展示”访问模式。
  - 建议：
      - 短期：增加 (instance_id, username)（或 (instance_id, username text_pattern_ops)/trgm 视搜索需求）
      - 中期：若 db_type 与 instance 强一致，可评估去冗余并调整唯一键。
  - 验证：
      - EXPLAIN (ANALYZE, BUFFERS) 对比 ORDER BY username 是否能走 Index Only Scan。

  10. 标题：日志检索使用 LIKE '%term%' + JSON cast，缺少可扩展检索方案

  - 证据：app/routes/history/logs.py:175-198
  - 影响：日志量上来后几乎必全表扫；页面/接口超时。
  - 根因：未引入全文索引/Trigram；context JSON 未做可检索字段抽取。
  - 建议：
      - 短期：对 module/message 上 pg_trgm GIN；对 context 至少抽取常用 key 做列。
      - 中期：引入 to_tsvector 全文检索 + 归档/分区。
  - 验证：
      - EXPLAIN 验证从 Seq Scan 变 Bitmap Index Scan；并压测高并发搜索。

  P2
  11) 标题：Credential.instance_ids(JSON) 与 instances.credential_id 冗余，存在一致性与演进成本

  - 证据：app/models/credential.py:84（instance_ids） + app/models/instance.py:94（credential_id）
  - 影响：未来做“凭据授权/回收/审计”时，双写/回填复杂；更容易出现脏数据。
  - 根因：早期为方便展示引入冗余字段，未形成退场计划。
  - 建议：
      - 短期：确认是否仍被使用（全仓搜索为 0 命中则进入 deprecate）；新增写入埋点统计命中率。
      - 中期：迁移到关系表（如 credential_instances）或仅保留 instances.credential_id 这一侧。
  - 验证：
      - SQL 校验：对比 credentials.instance_ids 与 SELECT array_agg(instances.id) ... 是否一致；并在回填后下线字
        段。

  12. 标题：大小写规范化缺失（database_name/username）可能造成“唯一约束/去重/Join”语义不一致

  - 证据：容量最新去重按 lower()：app/routes/instances/detail.py:618-623；但唯一约束是原始 database_name（app/
    models/database_size_stat.py:91-96）
  - 影响：同名不同大小写在库中共存，UI/统计结果与真实数据不一致。
  - 根因：缺少 canonicalization 规范与入库前清洗。
  - 建议：
      - 短期：写入侧统一 lower（或按 db_type 规范）；并补“冲突检测告警”。
      - 中期：引入 *_canonical 列 + 以其做唯一/索引（注意分区唯一约束限制）。
  - 验证：
      - 查重 SQL：SELECT instance_id, lower(database_name), collected_date, count(*) ... HAVING count(*)>1;

  （E. 最小可执行改进计划（<=8 条行动项））

  1. 统一 Schema Source of Truth：以 Alembic 为唯一 DDL 入口；sql/init_postgresql.sql 仅保留“扩展/角色/种子数据”，
     并补“空库演练”CI。
  2. 重整迁移链：清理所有 down_revision=None 的伪头节点，产出线性基线迁移（可考虑 squash），保证新环境可一键升级到
     head。
  3. 分区表规范化：把父表 PARTITION BY、关键 UK/PK、必要索引、触发器/视图纳入迁移；同时把 ORM primary_key 与真实
     DDL 对齐（必要时复合 PK）。
  4. 补齐 database_size_aggregations 的业务唯一约束 + 幂等写入（upsert），并提供历史去重脚本与回填演练。
  5. 针对 Top 查询做“下推改造”：移除 .all()+Python 去重/计数，改用窗口函数/聚合；关键接口切到 keyset 分页。
  6. 索引补齐：优先加 instance_tags(tag_id, instance_id)、account_permission(instance_id, username)、
     sync_instance_records(instance_id, sync_category, status, completed_at)（按 EXPLAIN 驱动）。
  7. 统一锁定/权限字典字段：规范 type_specific key（SQLServer is_disabled vs is_locked），加 schema_version 与回填
     退场计划。
  8. 日志治理：引入可扩展检索（FTS/pg_trgm）+ 保留/归档（分区或 TTL），并明确 context 红线字段脱敏策略。

  ———

	  IV. “兼容/防御/回退/适配清单（与数据结构相关）”

	  - 位置：migrations/env.py:30
	      - 类型：兼容
	      - 描述：兼容 Flask-SQLAlchemy <3 与 >=3 的 Engine 获取方式，try/except 回退到 engine 属性。
	      - 建议：明确项目依赖版本矩阵；若已统一版本，删掉分支并加 smoke test 覆盖（至少保证 alembic 能取到 Engine）。
	  - 位置：migrations/versions/20251109090000_add_is_locked_to_account_permission.py:30
	      - 类型：兼容/迁移回填
	      - 描述：新增 account_permission.is_locked 后，通过 COALESCE 从 type_specific 推导不同数据库的锁定语义并回填。
	      - 建议：把“锁定语义映射表”收敛为单一实现（TypedDict + schema_version + 单测）；回填后对旧 key 做命中率统计→退场→删旧字段路径。
	  - 位置：app/models/credential.py:186
	      - 类型：兼容/回退
	      - 描述：仅支持解密新格式密文；遇到旧格式密码时回退空字符串，避免连接阶段误用未知格式。
	      - 建议：对旧格式命中做计数与告警；补一次性数据迁移将历史密码重加密并在完成后强约束“只允许 encrypted”。
	  - 位置：app/models/account_classification.py:183
	      - 类型：防御
	      - 描述：rule_expression(TEXT JSON) 解析失败回退 {}，避免规则解析崩溃。
	      - 建议：入库前强校验 JSON schema + schema_version；对解析失败/{} 回退做告警并驱动数据修复。
	  - 位置：app/routes/instances/detail.py:458
	      - 类型：兼容/防御
	      - 描述：account_permission 的 JSON 字段可能为 NULL，使用 `or []/{}` 兜底，保证前端稳定展示。
	      - 建议：在写入侧统一“空集合语义”（NULL vs 空对象/数组）；能确定的字段改为 NOT NULL + DEFAULT，并补历史回填。
	  - 位置：app/services/accounts_sync/permission_manager.py:240
	      - 类型：兼容/迁移回填
	      - 描述：优先按 instance_account_id 查权限；找不到再按 (instance_id, db_type, username) 兜底，并补写 instance_account_id。
	      - 建议：把回填变成一次性迁移（带索引/批处理）并最终把 instance_account_id 设为 NOT NULL；同时加一致性校验（instance_id 对齐）。
	  - 位置：app/services/accounts_sync/adapters/mysql_adapter.py:178
	      - 类型：适配/防御
	      - 描述：permissions/type_specific 缺失时用 `or {}` 兜底，并从 username@host 拆分补齐 type_specific，统一跨库字段结构。
	      - 建议：把 type_specific 结构定义为 TypedDict（`app/types/`）并加入 schema_version；字段映射集中管理，避免各 adapter 漂移。
	  - 位置：app/services/accounts_sync/adapters/postgresql_adapter.py:184
	      - 类型：适配/兼容
	      - 描述：将 can_login 从顶层字段回填进 type_specific，并用默认 True 兜底，统一“可登录/锁定”语义。
	      - 建议：明确 PG 的 canonical 字段（例如 is_locked）；回填完成后移除旧字段读取路径并加命中率埋点。
	  - 位置：app/services/accounts_sync/adapters/sqlserver_adapter.py:172
	      - 类型：适配/兼容
	      - 描述：将 is_disabled 回填到 type_specific，并据此计算 is_locked，兼容不同来源的字段命名。
	      - 建议：统一 key 命名（is_locked）并把 is_disabled 降级为历史字段，规划退场。
	  - 位置：app/services/accounts_sync/adapters/oracle_adapter.py:138
	      - 类型：适配/防御
	      - 描述：permissions 缺失时构造 Oracle 默认权限结构；同时从 account_status 推导锁定状态。
	      - 建议：把 account_status→is_locked 的映射固化为可测试函数，并在 type_specific 中保留原始状态与 schema_version。
	  - 位置：app/services/account_classification/repositories.py:221
	      - 类型：兼容
	      - 描述：从缓存 hydrate 规则时对 is_active 缺失用默认 True（data.get("is_active", True)），兼容旧缓存结构。
	      - 建议：缓存 payload 加 schema_version；新版本缓存覆盖后移除默认兜底并对必填字段强校验。
	  - 位置：app/tasks/accounts_sync_tasks.py:90
	      - 类型：防御/兼容
	      - 描述：对分阶段 summary（inventory/collection）缺失用 `{}` 兜底，避免任务链路因返回结构差异崩溃。
	      - 建议：为任务返回结构定义 TypedDict 并在入口强校验；对缺失字段做告警以推动上游修正。
	  - 位置：app/routes/partition.py:424
	      - 类型：防御
	      - 描述：分区统计服务返回 dict 结构不稳定时，使用 `or []/0` 兜底，保证页面可用。
	      - 建议：为 PartitionStatisticsService 返回结构加版本号/契约测试；把“必填键”在服务层统一补齐。
