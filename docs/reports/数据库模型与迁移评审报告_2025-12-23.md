# 数据库模型与迁移“查漏补缺式”评审报告(ORM 可扩展性侧重)

- 生成日期: 2025-12-23
- 覆盖范围: `app/models/**`, `app/routes/**`, `app/services/**`, `migrations/**`, `sql/**`
- DB 基线: `migrations/versions/20251219161048_baseline_production_schema.py` (Revision `20251219161048`, Create Date 2025-12-19)
- 评审关注点: 以 ORM 建模合理性与表间关系的可扩展性为主,同时标注 DB/ORM 漂移与迁移演进风险.

> 说明:
> - 仓库目前以“单一基线迁移 + 若干 SQL 脚本”描述 schema,后续演进建议补齐增量迁移与演练规范(见 II/III).
> - 本报告的证据行号以 2025-12-23 工作区文件为准,若后续文件变更请以实际行号复核.

---

## I. “Schema 概览(文字 ERD)”

### A. Schema 地图(按领域分组)

#### 账号与权限域

- `users`: 系统用户
- `account_permission`: 账户权限快照(宽表,多 JSONB 字段)
- `instance_accounts`: 实例账户清单(账户存在性/生命周期)
- `account_change_log`: 账户变更日志(差异/会话关联)
- `account_classifications`: 账户分类
- `classification_rules`: 分类规则(表达式)
- `account_classification_assignments`: 账户分类分配(人工/自动/批次)
- `permission_configs`: 权限字典(前端展示/解释用)

#### 资产与连接域

- `instances`: 数据库实例
- `credentials`: 连接凭据(含密文密码)
- `database_type_configs`: 数据库类型配置(驱动/默认端口/特性)

#### 标签域

- `tags`: 标签
- `instance_tags`: 实例-标签多对多关联表

#### 容量与指标域(分区表族)

- `database_size_stats`: 数据库级容量明细(按 `collected_date` 月分区)
- `instance_size_stats`: 实例级容量明细(按 `collected_date` 月分区)
- `database_size_aggregations`: 数据库级聚合(按 `period_start` 月分区)
- `instance_size_aggregations`: 实例级聚合(按 `period_start` 月分区)

> 分区子表(当前基线内置):
> - `database_size_stats_2025_07` ... `database_size_stats_2026_02`
> - `instance_size_stats_2025_07` ... `instance_size_stats_2026_02`
> - `database_size_aggregations_2025_07` ... `database_size_aggregations_2026_02`
> - `instance_size_aggregations_2025_07` ... `instance_size_aggregations_2026_02`

#### 同步与任务域

- `sync_sessions`: 同步会话(批次级)
- `sync_instance_records`: 同步实例记录(实例级)

#### 可观测性域

- `unified_logs`: 统一日志(结构化上下文)

### 关键关系(文字版 ERD)

- `credentials (1) -> instances (N)`: `instances.credential_id -> credentials.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4181`, ORM: `app/models/instance.py:94`)
- `instances (N) <-> tags (N)`: via `instance_tags(instance_id, tag_id)` (DB PK: `migrations/versions/20251219161048_baseline_production_schema.py:3696`, ORM: `app/models/tag.py:183`)
- `instances (1) -> instance_accounts (N)`: `instance_accounts.instance_id -> instances.id` (DB 表: `migrations/versions/20251219161048_baseline_production_schema.py:808`, ORM: `app/models/instance_account.py:34`)
- `instance_accounts (1) -> account_permission (0/1, 逻辑上趋向 1:1)`: `account_permission.instance_account_id -> instance_accounts.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4035`, ORM: `app/models/account_permission.py:46`)
- `instances (1) -> instance_databases (N)`: `instance_databases.instance_id -> instances.id` (DB 表: `migrations/versions/20251219161048_baseline_production_schema.py:825`, ORM: `app/models/instance_database.py:35`)
- `instances (1) -> database_size_stats (N)`: `database_size_stats.instance_id -> instances.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4192`, ORM: `app/models/database_size_stat.py:48`)
- `instances (1) -> instance_size_stats (N)`: `instance_size_stats.instance_id -> instances.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4202`, ORM: `app/models/instance_size_stat.py:34`)
- `instances (1) -> database_size_aggregations (N)`: ORM 有 FK `database_size_aggregations.instance_id -> instances.id`, 但 DB 基线缺失 FK (ORM: `app/models/database_size_aggregation.py:60`, DB 需补齐)
- `instances (1) -> instance_size_aggregations (N)`: `instance_size_aggregations.instance_id -> instances.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4197`, ORM: `app/models/instance_size_aggregation.py:57`)
- `sync_sessions (1) -> sync_instance_records (N)`: `sync_instance_records.session_id -> sync_sessions.session_id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4187`, ORM: `app/models/sync_instance_record.py:44`)
- `account_permission (1) -> account_classification_assignments (N)`: `account_classification_assignments.account_id -> account_permission.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4026`, ORM: `app/models/account_classification.py:214`)
- `account_classifications (1) -> classification_rules (N)`: `classification_rules.classification_id -> account_classifications.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4040`, ORM: `app/models/account_classification.py:142`)
- `account_classifications (1) -> account_classification_assignments (N)`: `account_classification_assignments.classification_id -> account_classifications.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4028`, ORM: `app/models/account_classification.py:215`)
- `classification_rules (1) -> account_classification_assignments (0..N)`: `account_classification_assignments.rule_id -> classification_rules.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4029`, ORM: `app/models/account_classification.py:216`)
- `users (1) -> account_classification_assignments (0..N)`: `account_classification_assignments.assigned_by -> users.id` (DB FK: `migrations/versions/20251219161048_baseline_production_schema.py:4027`, ORM: `app/models/account_classification.py:217`)

### 每张核心表的关键约束/索引摘要(含分区/部分索引/Check)

> 说明: 下述以 DB 基线为主,并在关键处标注 ORM 漂移点.

- `users`
  - 字段: `id`, `username`, `password`, `role`, `created_at`, `last_login`, `is_active` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:1355`, ORM: `app/models/user.py:35`)
  - PK: `users_pkey(id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3906`)
  - UQ: `users_username_key(username)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3901`)
  - 索引: `ix_users_username` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3893`)

- `credentials`
  - 字段: `id`, `name`, `credential_type`, `db_type`, `username`, `password`, `description`, `instance_ids(jsonb)`, `category_id`, `is_active`, `created_at`, `updated_at`, `deleted_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:363`, ORM: `app/models/credential.py:78`)
  - PK: `credentials_pkey(id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:2352`)
  - UQ: `credentials_name_key(name)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:2345`)
  - 索引: `idx_credential_type`, `idx_db_type` 等(见 DB 索引段, ORM: `app/models/credential.py:79-90`)
  - 漂移: ORM 使用 `db.JSON` 但 DB 为 `jsonb` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:371`, ORM: `app/models/credential.py:85`)

- `instances`
  - 字段: `id`, `name`, `db_type`, `host`, `port`, `database_name`, `database_version`, `main_version`, `detailed_version`, `sync_count`, `credential_id`, `description`, `is_active`, `last_connected`, `created_at`, `updated_at`, `deleted_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:1236`, ORM: `app/models/instance.py:82`)
  - PK: `instances_pkey(id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3723`)
  - UQ: `instances_name_key(name)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3718`)
  - FK: `instances_credential_id_fkey(credential_id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:4181`)
  - 索引: `ix_instances_name`(UNIQUE), `ix_instances_db_type` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3701`)

- `tags` / `instance_tags`
  - `tags` 字段: `id`, `name`, `display_name`, `category`, `color`, `is_active`, `created_at`, `updated_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:1325`, ORM: `app/models/tag.py:26`)
  - `instance_tags` 字段: `instance_id`, `tag_id`, `created_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:1226`, ORM: `app/models/tag.py:183`)
  - `instance_tags` PK: `(instance_id, tag_id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3696`)
  - `instance_tags` FK: `instance_tags_instance_id_fkey`, `instance_tags_tag_id_fkey` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:4175`)

- `database_type_configs`
  - 字段: `id`, `name`, `display_name`, `driver`, `default_port`, `default_schema`, `connection_timeout`, `description`, `icon`, `color`, `features`, `is_active`, `is_system`, `sort_order`, `created_at`, `updated_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:785`, ORM: `app/models/database_type_config.py:39`)
  - PK: `database_type_configs_pkey(id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3007`)
  - UQ: `database_type_configs_name_key(name)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:2996`)

- `permission_configs`
  - 字段: `id`, `db_type`, `category`, `permission_name`, `description`, `is_active`, `sort_order`, `created_at`, `updated_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:1260`, ORM: `app/models/permission_config.py:29`)
  - PK: `permission_configs_pkey(id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3750`)
  - UQ: `uq_permission_config(db_type, category, permission_name)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3745`, ORM: `app/models/permission_config.py:48`)

- `instance_databases`
  - 字段: `id`, `instance_id`, `database_name`, `is_active`, `first_seen_date`, `last_seen_date`, `deleted_at`, `created_at`, `updated_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:825`, ORM: `app/models/instance_database.py:32`)
  - PK: `instance_databases_pkey(id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3050`)
  - UQ: `uq_instance_databases(instance_id, database_name)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3045`, ORM: `app/models/instance_database.py:48`)

- `instance_accounts`
  - 字段: `id`, `instance_id`, `username`, `db_type`, `is_active`, `first_seen_at`, `last_seen_at`, `deleted_at`, `created_at`, `updated_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:808`, ORM: `app/models/instance_account.py:31`)
  - PK: `instance_accounts_pkey(id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3024`)
  - UQ: `uq_instance_accounts(instance_id, db_type, username)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3019`, ORM: `app/models/instance_account.py:50`)

- `account_permission`
  - 字段: `id`, `instance_id`, `db_type`, `username`, `instance_account_id`, `is_superuser`, `is_locked`, `last_sync_time`, `last_change_type`, `last_change_time`, 以及多组权限 `jsonb` 字段(略) (DB: `migrations/versions/20251219161048_baseline_production_schema.py:317`, ORM: `app/models/account_permission.py:38`)
  - PK: `account_permission_pkey(id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:2309`)
  - UQ: `uq_current_account_sync(instance_id, db_type, username)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:2300`, ORM 侧同语义但命名不同: `app/models/account_permission.py:41`)
  - FK: `fk_account_permission_instance(instance_id)`, `fk_account_permission_instance_account(instance_account_id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:4034`)
  - 索引: `idx_instance_dbtype`, `idx_username`, `idx_last_sync_time`, `idx_last_change_time`, `ix_account_permission_is_locked` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:2284`)
  - 漂移: ORM 声明 `instance_account_id index=True`, 但 DB 索引清单缺失该索引(见 III-P0-3)

- `account_change_log`
  - 字段: `id`, `instance_id`, `db_type`, `username`, `change_type`, `change_time`, `session_id`, `status`, `message`, `privilege_diff(jsonb)`, `other_diff(jsonb)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:261`, ORM: `app/models/account_change_log.py:29`)
  - PK: `account_change_log_pkey(id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:2232`)
  - FK: `account_change_log_instance_id_fkey(instance_id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:4021`)

- `account_classifications` / `classification_rules` / `account_classification_assignments`
  - `account_classifications` PK/UQ: `account_classifications_pkey(id)`, `account_classifications_name_key(name)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:2274`)
  - `classification_rules` PK: `classification_rules_pkey(id)`; FK: `classification_rules_classification_id_fkey(classification_id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:4040`)
  - `account_classification_assignments` PK: `account_classification_assignments_pkey(id)`; UQ: `unique_account_classification_batch(account_id, classification_id, batch_id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:2257`)

- `sync_sessions` / `sync_instance_records`
  - `sync_sessions` 字段: `id`, `session_id`, `sync_type`, `sync_category`, `status`, `started_at`, `completed_at`, `total_instances`, `successful_instances`, `failed_instances`, `created_by`, `created_at`, `updated_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:1303`, ORM: `app/models/sync_session.py:34`)
  - `sync_sessions` PK: `sync_sessions_pkey(id)`; UQ: `sync_sessions_session_id_key(session_id)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3811`)
  - `sync_sessions` CHECK: `sync_sessions_status_check`, `sync_sessions_sync_type_check`, `sync_sessions_sync_category_check` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3816`)
  - 漂移: ORM 默认 `pending`, DB 默认/Check 不包含 `pending` (见 III-P0-4)

- `unified_logs`
  - 字段: `id`, `timestamp`, `level(enum log_level)`, `module`, `message`, `traceback`, `context(jsonb)`, `created_at` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:1340`, ORM: `app/models/unified_log.py:56`)
  - PK: `unified_logs_pkey(id)`; CHECK: `unified_logs_level_check` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3884`)

- 分区表族摘要
  - `database_size_stats`(按月分区,父表无 PK):
    - UQ: `uq_daily_database_size(instance_id, database_name, collected_date)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3954`, ORM: `app/models/database_size_stat.py:91`)
    - 索引(父表): `ix_database_size_stats_collected_date`, `ix_database_size_stats_instance_date`, `ix_database_size_stats_instance_db` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3932`)
    - Trigger: `trg_update_instance_database_last_seen` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3947`)
  - `instance_size_stats`(按月分区,父表有复合 PK):
    - PK: `instance_size_stats_pkey(id, collected_date)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:4016`)
    - 部分唯一索引: `uq_instance_size_stats_instance_date(instance_id, collected_date) WHERE is_deleted=false` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:4001`)
    - Trigger: `instance_size_stats_partition_trigger` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:4009`)
  - `database_size_aggregations`(按月分区,父表无 PK 且 DB 缺 FK):
    - UQ: `uq_database_size_aggregation(instance_id, database_name, period_type, period_start)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3927`, ORM: `app/models/database_size_aggregation.py:115`)
    - 索引(父表): `ix_database_size_aggregations_id`, `ix_database_size_aggregations_instance_period`, `ix_database_size_aggregations_period_type` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3911`)
  - `instance_size_aggregations`(按月分区,父表复合 PK):
    - PK: `instance_size_aggregations_pkey(id, period_start)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3980`)
    - UQ: `uq_instance_size_aggregation(instance_id, period_type, period_start)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3975`, ORM: `app/models/instance_size_aggregation.py:108`)

### 数据规模预估(需要业务确认)

> 下述用于“是否能支撑未来数据量”评估,请按真实规模校准.

- `instances`: 现状 10^2~10^3; 1 年后 10^3~10^4
- `instance_databases`: 约 `instances * 每实例数据库数`; 若 1000 实例 * 100 DB = 10^5
- `database_size_stats`: 约 `instances * 每实例数据库数 * 采集频率`
  - 日采集: 10^5/天 => 3.6 * 10^7/年
  - 小时采集: 2.4 * 10^6/天 => 8.7 * 10^8/年
- `instance_size_stats`: 约 `instances * 采集频率` (日采集 10^3/天)
- `account_permission`/`instance_accounts`: 约 `instances * 每实例账户数`; 若 1000 * 500 = 5 * 10^5
- `unified_logs`: 取决于日志量与保留策略,若无归档很容易成为增长型大表

### B. 关键用例反推(Top 10 查询/写入路径)

> 目标: 从 routes/services 反推“数据量增长后最可能爆的点”,并映射到索引/约束/迁移策略.

1) 容量采集写入(数据库级明细 upsert)
- 位置: `app/services/database_sync/persistence.py:31`
- 写入表: `database_size_stats` (分区), 依赖 UQ: `(instance_id, database_name, collected_date)` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:3954`)
- 风险: 分区触发器/重复索引导致写放大,以及后续按实例/日期的查询压力.

2) 容量采集写入(实例级明细 upsert,含部分唯一索引)
- 位置: `app/services/database_sync/persistence.py:127`
- 写入表: `instance_size_stats` (分区), 依赖部分唯一索引 `WHERE is_deleted=false` (DB: `migrations/versions/20251219161048_baseline_production_schema.py:4001`)
- 风险: `instance_size_stats_partition_trigger` 在热路径执行 DDL (见 III-P0-5).

3) 实例详情页 - 最新数据库容量列表(窗口函数 + 回表 join)
- 位置: `app/routes/instances/detail.py:602` (关键 join: `app/routes/instances/detail.py:651`)
- 读表: `database_size_stats` + `instance_databases`
- 依赖索引/约束: 按 `instance_id`/`database_name`/`collected_date` 排序; 当前 join 依赖 `DatabaseSizeStat.id` 但 DB 父表无 `id` 索引/PK (见 III-P0-1).

4) 实例详情页 - 数据库容量历史(分页 + 排序)
- 位置: `app/routes/instances/detail.py:740` (历史查询相关)
- 风险: offset pagination 在大表上退化,且 `database_name ilike` 无法命中 btree 索引.

5) 数据库聚合计算(按实例 + 日期范围 group by)
- 位置: `app/services/aggregation/database_aggregation_runner.py:329`
- 读表: `database_size_stats` (范围扫描 + group by)
- 写表: `database_size_aggregations` (分区)
- 风险: group by 扫描跨度大时 CPU/IO 升高; 聚合表 DB 缺 FK/PK 会加大运维与一致性风险(见 III-P0-2).

6) 实例聚合/汇总查询(容量页)
- 位置: `app/routes/capacity/instances.py:163`
- 读表: `instance_size_aggregations`, `instance_size_stats`
- 风险: ORM/DB 的分区主键不一致时,后续按主键回表/分页容易踩坑(见 III-P1-3).

7) 账户权限同步 - 按 `instance_account_id` 查找权限快照(N+1)
- 位置: `app/services/accounts_sync/permission_manager.py:240`
- 读写表: `account_permission`, `instance_accounts`
- 风险: DB 缺 `account_permission(instance_account_id)` 索引,同步规模上来会变成全表扫描热点(见 III-P0-3).

8) 账户变更日志写入(同步时逐条写)
- 位置: `app/services/accounts_sync/permission_manager.py:281`
- 写表: `account_change_log`
- 风险: 高频写入下索引过多/低选择性索引会拖慢; 同时建议明确保留/归档策略.

9) 分区健康/覆盖检查(按日期统计记录数)
- 位置: `app/routes/partition.py:187`
- 读表: `database_size_stats`, `instance_size_stats`, `*_aggregations`
- 风险: 若缺合适索引或分区裁剪不生效,会扫大量分区.

10) 统一日志查询/统计
- 位置: `app/models/unified_log.py:148`
- 读表: `unified_logs`
- 风险: 日志表增长快,需要保留/归档/分区策略; 结构化 `context` 若需要检索,应配 GIN 索引与字段规范.

---

## II. “缺口地图”(按 1~8 维度逐条)

### 1) 实体与关系建模(Modeling)

- 缺口描述:
  - 分区表族的“主键策略”在 ORM 与 DB 之间不一致/缺失: `database_size_stats`/`database_size_aggregations` DB 侧无 PK,但 ORM 把 `id` 当 PK,且业务查询依赖 `id` 回表.
  - `database_size_aggregations` 在 ORM 有 `instance_id -> instances.id` 外键,但 DB 基线缺 FK,导致模型关系在 DB 层无法兜底.
- 建模规范/ADR 标题:
  - `ADR: 分区表主键与唯一性策略(包含分区键)`
  - `ADR: ORM/DB Schema 单一事实源与漂移治理`

### 2) 字段设计(Columns)

- 缺口描述:
  - 聚合表 `*_aggregations.calculated_at/created_at` DB 为 `timestamp`(无时区),ORM 为 `timestamptz`(含时区),存在语义漂移与跨时区一致性风险(示例 DB: `migrations/versions/20251219161048_baseline_production_schema.py:1393`, ORM: `app/models/database_size_aggregation.py:95`).
  - 多处 JSON 字段 DB 为 `jsonb`,ORM 使用通用 `JSON`,易造成 Alembic autogenerate 漂移与索引策略缺失(示例 DB: `migrations/versions/20251219161048_baseline_production_schema.py:323`, ORM: `app/models/account_permission.py:52`).
- 建模规范/ADR 标题:
  - `ADR: 时间字段统一规范(timestamptz/UTC/展示时区)`
  - `ADR: JSONB 字段规范与 schema_version 约定`

### 3) 约束与数据完整性(Integrity)

- 缺口描述:
  - DB 缺失关键 FK/PK 时,系统一致性完全依赖应用层,在并发/回填/运维脚本场景容易产生孤儿数据与隐性脏数据.
  - `account_permission` 同时持有 `(instance_id, db_type, username)` 与 `instance_account_id`,但缺乏一致性约束(无法从 DB 层防止 `instance_account_id` 指向别的实例的账户).
- 建模规范/ADR 标题:
  - `ADR: 外键与删除策略(RESTRICT/CASCADE/SET NULL)统一约定`
  - `ADR: 账户身份表与权限快照表的关系约束方案`

### 4) 索引与性能(Performance)

- 缺口描述:
  - 高优先级访问路径缺关键索引(例如 `account_permission.instance_account_id`).
  - 分区子表存在重复索引/重复唯一(写放大,膨胀,以及 VACUUM/ANALYZE 压力).
  - 大表分页多处仍是 offset/limit,缺 keyset pagination 规范.
- 建模规范/ADR 标题:
  - `ADR: 分区表索引策略(父表分区索引 vs 子表独立索引)与命名规范`
  - `ADR: 大表分页策略(keyset)与稳定排序字段`

### 5) 迁移与版本演进(Migrations & Evolution)

- 缺口描述:
  - 当前仅有“全量基线迁移”,缺少后续增量迁移与滚动发布套路; 且基线 `downgrade` 不可用(见 `migrations/versions/20251219161048_baseline_production_schema.py:4211`).
  - 分区与索引维护部分通过 SQL 脚本分散在 `sql/**`,存在环境漂移风险.
- 建模规范/ADR 标题:
  - `ADR: 零停机迁移分阶段策略(add nullable -> backfill -> add constraint -> cleanup)`
  - `ADR: 分区生命周期管理(预建/扩容/清理)与迁移脚本化`

### 6) 事务与并发一致性(Concurrency)

- 缺口描述:
  - `instance_size_stats_partition_trigger()` 在 INSERT 热路径执行 `CREATE TABLE` DDL,并发下存在竞争与锁风险(见 `migrations/versions/20251219161048_baseline_production_schema.py:1953`).
  - upsert 写入依赖唯一约束/部分索引,应确保索引存在且与 ORM/DB 一致.
- 建模规范/ADR 标题:
  - `ADR: 幂等写入与去重约束(idempotency key/unique/upsert)`
  - `ADR: 分区创建并发安全与调度策略(禁止热路径 DDL)`

### 7) 安全与数据治理(Governance)

- 缺口描述:
  - `unified_logs`/`account_change_log` 等增长型表缺少统一的保留/归档策略与访问审计规范.
  - 凭据与权限 JSON 中潜在敏感信息(如账号名/角色/权限细节)在导出/日志/调试链路可能泄露,需约束字段与脱敏策略.
- 建模规范/ADR 标题:
  - `ADR: 增长型表保留/归档/分区与脱敏策略`
  - `ADR: 敏感字段最小化与导出审计规范`

### 8) 兼容/防御/回退/适配(兜底)

- 缺口描述:
  - 存在“兼容性回填逻辑”但缺配套埋点与收敛计划(例如 `instance_account_id` 回填,`InstanceDatabase.is_active` 允许 NULL 并按 active 处理).
  - 缺少“旧字段/旧语义命中率统计 -> 完成回填 -> 移除兜底 -> 删除旧结构”的标准流程.
- 建模规范/ADR 标题:
  - `ADR: Schema 兼容期管理(埋点/灰度/收敛/清理)`
  - `ADR: Postgres vs SQLite 差异清单与开发测试约束`

---

## III. “模型设计问题清单”(按 P0/P1/P2)

### P0(高风险/高收益,建议优先处理)

#### P0-1. `database_size_stats` 分区父表无 PK/无 `id` 索引,但业务查询依赖 `id` 回表 join

- 证据:
  - DB: `database_size_stats` 定义含 `id` 列但未定义 PK: `migrations/versions/20251219161048_baseline_production_schema.py:1453`
  - DB: 仅有唯一约束 `uq_daily_database_size(instance_id, database_name, collected_date)`: `migrations/versions/20251219161048_baseline_production_schema.py:3954`
  - DB: 父表索引列表不含 `id`: `migrations/versions/20251219161048_baseline_production_schema.py:3932`
  - ORM: 把 `id` 声明为 PK+index: `app/models/database_size_stat.py:47`
  - 关键查询: 最新容量列表用 `DatabaseSizeStat.id` join 回表: `app/routes/instances/detail.py:627`, `app/routes/instances/detail.py:651`
- 影响:
  - 最坏情况: 最新容量查询在实例/数据库数量上来后产生跨分区大范围扫描 + hash join,延迟飙升,并拖慢容量页与聚合任务.
  - 最可能发生方式: 未限制日期窗口时,对某实例全历史数据做窗口函数排序; join 侧缺 `id` 索引使回表代价上升.
- 根因:
  - 分区表 PK 需要包含分区键; 现有设计既未在 DB 定义 PK,也未在 ORM/迁移侧统一主键策略,导致 ORM 假设与 DB 事实不一致.
- 建议:
  - 短期止血(1~3 天):
    - 增加父表分区索引 `ON database_size_stats(id)` (如果确认 `id` 全局唯一且写入不会插入重复 id).
    - 或改写“最新值”查询避免按 `id` 回表(例如 `DISTINCT ON (lower(database_name))` + 仅选择必要字段).
  - 中期重构(1~2 周):
    - 设计并落地分区表 PK: 方案 A `PRIMARY KEY (id, collected_date)`; 方案 B 业务键 PK `(instance_id, database_name, collected_date)` 并移除对 `id` 的依赖.
    - 同步修正 ORM 主键定义与查询逻辑,确保 SQLAlchemy identity map 与 DB 约束一致.
  - 长期演进(可选):
    - 引入“最新快照表”(例如 `database_size_latest`) 做读优化,明细表只承载时序写入与离线聚合.
- 验证:
  - SQL 校验:
    - `\\d+ database_size_stats` 确认 PK/索引状态.
    - `EXPLAIN (ANALYZE, BUFFERS) ...` 对 `app/routes/instances/detail.py` 的 SQL 进行对比.
  - 迁移演练:
    - 采用 expand/contract: 先加索引(并发),再加约束,最后改代码.
  - 性能验证点:
    - 用 10^7 行级别造数,验证最新容量查询的延迟与 IO.

#### P0-2. `database_size_aggregations` DB 缺 PK 且缺 `instance_id -> instances.id` 外键,与 ORM 漂移

- 证据:
  - DB: 表定义: `migrations/versions/20251219161048_baseline_production_schema.py:1369`
  - DB: 只有唯一约束 `uq_database_size_aggregation(...)`,无 PK 段落: `migrations/versions/20251219161048_baseline_production_schema.py:3927`
  - ORM: `instance_id = ForeignKey("instances.id")`: `app/models/database_size_aggregation.py:60`
  - 路由/统计依赖: `DatabaseSizeAggregation` 用于分区覆盖指标: `app/routes/partition.py:196`
- 影响:
  - 最坏情况: 出现 orphan 聚合数据(实例已删或 id 复用/导入错误),聚合结果不可解释且运维难排查; 同时缺 PK 会影响 ORM 级缓存/更新语义.
  - 最可能发生方式: 通过脚本/修复任务写入聚合表时缺少 FK 兜底; 后续删除实例/回收数据时无法级联处理.
- 根因:
  - 分区表 PK 需要包含分区键; 当前为规避约束限制而未在 DB 定义 PK/FK,但 ORM 仍按“普通表”建模.
- 建议:
  - 短期止血(1~3 天):
    - 在 DB 增加 `FOREIGN KEY (instance_id) REFERENCES instances(id)` (可先对现有数据做 orphan 扫描与清理).
  - 中期重构(1~2 周):
    - 增加分区表 PK: `PRIMARY KEY (id, period_start)` 并同步 ORM 主键定义(避免仅以 `id` 作为 identity).
    - 明确聚合写入的幂等策略: 使用 `ON CONFLICT (instance_id, database_name, period_type, period_start) DO UPDATE`.
  - 长期演进(可选):
    - 将 `period_type` 收敛为 enum/小表并加 check 约束,减少脏值与查询分支.
- 验证:
  - SQL 校验:
    - orphan 扫描: `SELECT a.instance_id FROM database_size_aggregations a LEFT JOIN instances i ON a.instance_id=i.id WHERE i.id IS NULL LIMIT 10;`
    - 重复扫描: `SELECT instance_id,database_name,period_type,period_start,count(*) FROM database_size_aggregations GROUP BY 1,2,3,4 HAVING count(*)>1;`

#### P0-3. `account_permission.instance_account_id` 缺索引,权限同步路径会退化为热点全表扫描

- 证据:
  - 同步查找: `AccountPermission.query.filter_by(instance_account_id=account.id).first()`: `app/services/accounts_sync/permission_manager.py:240`
  - ORM 声明索引: `instance_account_id ... index=True`: `app/models/account_permission.py:46`
  - DB 索引清单缺失该索引: `migrations/versions/20251219161048_baseline_production_schema.py:2284`
- 影响:
  - 最坏情况: 账户数增长后,每次同步产生 N 次全表扫描,同步耗时与 DB CPU/IO 线性膨胀.
  - 最可能发生方式: 批量同步或定时任务对多个实例并发跑,造成 `account_permission` 表持续热点.
- 根因:
  - ORM 与 DB 索引未对齐(漂移),且该列是核心访问路径.
- 建议:
  - 短期止血(1~3 天):
    - 增加索引 `CREATE INDEX CONCURRENTLY ix_account_permission_instance_account_id ON account_permission(instance_account_id);`
  - 中期重构(1~2 周):
    - 降低 N+1: 同步开始时一次性加载该实例的 `account_permission` 映射(按 `instance_id` 或 join `instance_accounts`),内存匹配后批量 upsert.
  - 长期演进(可选):
    - 将权限快照与账户身份进一步解耦: 以 `instance_account_id` 作为唯一键,减少冗余字段与一致性风险.
- 验证:
  - SQL 校验: `EXPLAIN (ANALYZE, BUFFERS) SELECT ... FROM account_permission WHERE instance_account_id = ?;`
  - 性能验证点: 同步 10^5 账户级别时,DB QPS/latency 不应线性恶化.

#### P0-4. `sync_sessions.status` ORM 默认值与 DB 默认/Check 不一致,存在写入失败与语义漂移

- 证据:
  - ORM 默认: `default="pending"`: `app/models/sync_session.py:47`
  - DB 默认: `DEFAULT 'running'`: `migrations/versions/20251219161048_baseline_production_schema.py:1308`
  - DB Check 不含 `pending`,但含 `cancelled`: `migrations/versions/20251219161048_baseline_production_schema.py:3816`
- 影响:
  - 最坏情况: 部分创建路径绕过 `__init__` 时写入 `pending` 导致 DB `CHECK` 失败(500/事务回滚),或出现状态枚举含义不一致导致统计错误.
  - 最可能发生方式: 测试/管理脚本/后台任务直接 `SyncSession()` 构造并 commit; ORM default 生效而触发约束失败.
- 根因:
  - 状态枚举缺少“单一事实源”(DB check vs 代码常量/注释),且缺少迁移层校验.
- 建议:
  - 短期止血(1~3 天):
    - 统一默认值与可选集合: 要么把 ORM default 改为 `running`,要么放宽 DB check 接纳 `pending`(需明确语义).
  - 中期重构(1~2 周):
    - 抽取枚举常量(单处定义)并用于 DB check(迁移)与代码校验,同时补齐 `cancelled` 状态在代码侧的处理路径.
  - 验证:
    - SQL 校验: `INSERT INTO sync_sessions(...) VALUES (...)` 覆盖 default/显式 status 两种路径.

#### P0-5. `instance_size_stats_partition_trigger()` 在写入热路径执行 DDL,且父表/子表重复挂触发器,存在锁与抖动风险

- 证据:
  - Trigger 函数内部执行 `CREATE TABLE ... PARTITION OF ...`: `migrations/versions/20251219161048_baseline_production_schema.py:1953`
  - 父表触发器: `migrations/versions/20251219161048_baseline_production_schema.py:4009`
  - 子表重复触发器(示例): `migrations/versions/20251219161048_baseline_production_schema.py:3392`
- 影响:
  - 最坏情况: 并发写入跨月边界时触发 DDL 锁竞争,造成写入抖动/超时/死锁; 甚至触发器递归/重复创建导致不可预期行为.
  - 最可能发生方式: 定时容量采集在月初集中写入,触发创建新分区; 多 worker 并发 insert 时同时尝试创建.
- 根因:
  - 以触发器承担分区生命周期管理,且未做强并发控制; 同时重复在分区子表挂载相同触发器造成维护复杂度上升.
- 建议:
  - 短期止血(1~3 天):
    - 通过调度器预建未来 2~3 个月分区,减少热路径触发(可复用已有脚本 `sql/init_postgresql_partitions_*.sql`).
  - 中期重构(1~2 周):
    - 移除 INSERT 触发器中的 DDL,改为“定时任务/运维命令”管理分区; 统一只在父表维护触发器(或完全取消).
    - 为分区 DDL 增加 advisory lock 保护(如必须保留触发器方案).
  - 验证:
    - 并发压测: 多进程并发插入跨月日期,观察锁等待与失败率.
    - SQL 校验: 检查触发器仅存在于预期表集合.

### P1(中风险/结构性优化,建议排期)

#### P1-1. 分区子表重复索引/重复唯一导致写放大与维护成本上升

- 证据:
  - 同列重复索引(示例 `database_size_stats_2025_07.collected_date`): `migrations/versions/20251219161048_baseline_production_schema.py:2656` 与 `migrations/versions/20251219161048_baseline_production_schema.py:2672`
  - 同业务键同时存在 UNIQUE INDEX 与 UNIQUE CONSTRAINT(示例): `migrations/versions/20251219161048_baseline_production_schema.py:2663` 与 `migrations/versions/20251219161048_baseline_production_schema.py:2694`
- 影响:
  - 最坏情况: 写入吞吐显著下降,存储膨胀,autovacuum 压力增大,并导致迁移/重建索引窗口变大.
- 根因:
  - 分区索引策略未统一: 既创建了父表分区索引,又在每个分区重复创建同义索引/约束.
- 建议:
  - 短期止血: 先冻结新增重复索引(规范/脚本门禁).
  - 中期重构:
    - 以父表分区索引为主,逐个分区评估并删除重复索引(用 `DROP INDEX CONCURRENTLY`).
    - 建立“索引清单基线”与 CI 检查,避免再次膨胀.
- 验证:
  - SQL: `SELECT tablename, indexname, indexdef FROM pg_indexes WHERE tablename LIKE 'database_size_stats_%' ORDER BY 1,2;`

#### P1-2. 聚合表时间字段 DB/ORM 时区语义不一致,易引入跨时区一致性问题

- 状态:
  - 已采用“中期重构”方案完成落地(2025-12-24).
- 证据(修复前):
  - DB `database_size_aggregations.calculated_at` 为 `timestamp(6)` 无时区: `migrations/versions/20251219161048_baseline_production_schema.py:1393`
  - ORM 为 `DateTime(timezone=True)`: `app/models/database_size_aggregation.py:95`
  - DB `instance_size_aggregations.calculated_at` 为 `timestamp(6)` 无时区: `migrations/versions/20251219161048_baseline_production_schema.py:1543`
  - ORM 为 `DateTime(timezone=True)`: `app/models/instance_size_aggregation.py:88`
- 修复:
  - 迁移: 将 `database_size_aggregations/instance_size_aggregations` 的 `calculated_at/created_at` 迁移为 `timestamptz` 并按 UTC 解释历史值: `migrations/versions/20251224134000_convert_aggregation_timestamps_to_timestamptz.py:23`
  - 初始化脚本: 新环境建库时直接使用 `timestamptz(6)`: `sql/init_postgresql.sql:568`, `sql/init_postgresql.sql:625`
- 影响:
  - 修复前最坏情况: 同一条记录在不同客户端/时区展示不一致,周期边界(周/月/季)计算偏移导致报表错误.
  - 当前: DB/ORM 时区语义对齐,以 UTC `timestamptz` 存储,展示侧按需转换,一致性风险显著降低.
- 建议:
  - 短期止血(1~3 天):
    - 明确当前解释口径: 若 DB 仍为 `timestamp`,约定按 UTC 解释并在读写层统一补齐时区(避免隐式本地时区).
  - 中期重构(1~2 周):
    - ✅ 已落地: 统一使用 `timestamptz` 存 UTC,展示层统一转换(参考 `app/models/unified_log.py:104` 的时区转换实践).
  - 长期演进(可选):
    - 周/月/季边界计算尽量基于 `date` 字段(如 `period_start/period_end`),将 `calculated_at` 仅用于审计与追溯.
- 验证:
  - 用不同时区客户端写入/读取对比,确保周期边界一致.

#### P1-3. 分区表主键在 ORM 与 DB 不一致,存在 identity 冲突与演进迁移隐患

- 状态:
  - 已采用“中期重构”方案完成对齐(2025-12-24).
- 证据:
  - DB `instance_size_stats` PK 为 `(id, collected_date)`: `migrations/versions/20251219161048_baseline_production_schema.py:4016`
  - ORM `InstanceSizeStat` PK 为 `(id, collected_date)`: `app/models/instance_size_stat.py:37`
  - DB `instance_size_aggregations` PK 为 `(id, period_start)`: `migrations/versions/20251219161048_baseline_production_schema.py:3980`
  - ORM `InstanceSizeAggregation` PK 为 `(id, period_start)`: `app/models/instance_size_aggregation.py:61`
  - 分页查询增加稳定排序键: `app/routes/capacity/instances.py:338`
- 影响:
  - 修复前最坏情况: 若出现(哪怕极小概率)跨分区 `id` 重复,SQLAlchemy identity map 会把两行当成同一对象,产生读写错乱.
  - 修复前更现实的风险: autogenerate/migration 会在 PK 层面持续漂移,造成“难以滚动发布”的大改.
  - 当前: ORM 已与 DB 复合主键一致,可显著降低 identity map 冲突与迁移漂移风险.
- 建议:
  - 短期止血(1~3 天):
    - 避免在业务逻辑中“仅按 id”做跨分区定位/回表,优先带上分区键(`collected_date/period_start`)作为过滤条件.
  - 中期重构(1~2 周):
    - ✅ 已落地: 统一 ORM 主键定义与 DB 一致(在 SQLAlchemy 中声明复合主键).
    - ✅ 已落地: 为业务分页查询提供稳定排序键.
  - 长期演进(可选):
    - 对所有分区表族制定统一 PK 模板,并在 Alembic/DDL 侧强制校验(避免未来再出现不一致).
- 验证:
  - 增量迁移演练 + 造数验证 ORM 行为(merge/update/delete).

#### P1-4. JSONB 宽表缺少字段规范与可检索索引策略,未来“按权限检索/统计”会受限

- 证据:
  - `account_permission` 大量权限字段为 `jsonb`: `migrations/versions/20251219161048_baseline_production_schema.py:323`
- 影响:
  - 最坏情况: 未来需求需要按权限/角色检索或统计时,只能全表扫描 JSON,且数据结构不统一导致无法约束.
- 建议:
  - 短期止血(1~3 天):
    - 明确“哪些 JSON 字段允许被检索/过滤”,禁止在 UI/接口中临时新增随意的 JSON 路径查询.
  - 中期重构(1~2 周):
    - 为 JSON 字段引入 `schema_version` 与结构规范(至少约定顶层 key/数组结构).
    - 对热点检索场景引入 GIN 索引或拆分子表(例如 “账户-权限项” 明细表),避免万能 JSON 越长越难维护.
  - 长期演进(可选):
    - 将跨类型通用字段抽到统一结构,减少“每种 DB 一套 JSON 字段”带来的扩展成本.

### P2(可优化项/体验与可维护性)

#### P2-1. `credentials.instance_ids` 以 JSONB 存关联实例列表,关系冗余且难以约束

- 证据:
  - DB: `credentials.instance_ids jsonb`: `migrations/versions/20251219161048_baseline_production_schema.py:371`
  - ORM: `instance_ids = db.Column(db.JSON, ...)`: `app/models/credential.py:85`
  - 同时 `instances.credential_id` 已表达 1:N 关系: `app/models/instance.py:94`
- 影响:
  - 最坏情况: 两处关系来源不一致导致展示/权限判断错误; 且 JSONB 无法 FK 约束实例存在性.
- 建议:
  - 短期止血(1~3 天):
    - 明确 `instance_ids` 是否仍被业务使用; 若仅用于展示,优先改为反向查询 `instances.credential_id` 并停止写入该字段.
  - 中期重构(1~2 周):
    - 若需要“凭据被哪些实例引用”,优先通过反向查询 `instances.credential_id`; 如需多对多,应建立关联表并加 FK/UQ.
  - 长期演进(可选):
    - 给凭据引入生命周期/审计字段规范(启用/停用/删除策略),并补齐引用检查与安全审计.

#### P2-2. 账户/数据库名称存在大小写与规范化风险,影响唯一约束与索引命中

- 证据:
  - 最新容量查询对名称使用 `lower(database_name)` 做分组: `app/routes/instances/detail.py:627`
- 影响:
  - 最坏情况: 同名不同大小写被当成不同对象写入,唯一约束不生效或展示重复; 查询侧 lower() 导致索引无法直接命中.
- 建议:
  - 短期止血(1~3 天):
    - 在写入侧统一规范化(例如入库前 `.lower()` 或按 DB 类型规则处理),减少新增脏数据.
  - 中期重构(1~2 周):
    - 引入规范化列(例如 `database_name_normalized`)并回填; 在唯一约束/索引中使用规范化值.
  - 长期演进(可选):
    - 使用 `citext` 或函数索引(`lower(database_name)`)统一读写与索引命中策略.

### E. 最小可执行改进计划(<= 8 条行动项)

1) (P0) 补齐 `database_size_stats` 的 `id` 索引与主键策略,并同步调整“最新容量”查询: `migrations/versions/20251219161048_baseline_production_schema.py:1453`, `app/routes/instances/detail.py:651`
2) (P0) 为 `database_size_aggregations` 增加 DB FK + 分区表 PK,并统一 ORM 主键定义: `migrations/versions/20251219161048_baseline_production_schema.py:1369`, `app/models/database_size_aggregation.py:60`
3) (P0) 增加 `account_permission(instance_account_id)` 索引,并在同步逻辑中降低 N+1: `app/services/accounts_sync/permission_manager.py:240`
4) (P0) 统一 `sync_sessions.status` 枚举/默认值(ORM 与 DB check 对齐),补齐 `cancelled` 状态语义: `migrations/versions/20251219161048_baseline_production_schema.py:3816`, `app/models/sync_session.py:47`
5) (P0) 移除/替代 `instance_size_stats_partition_trigger` 热路径 DDL,改为预建分区+并发安全方案: `migrations/versions/20251219161048_baseline_production_schema.py:1953`
6) (P1) 清理分区子表重复索引/重复唯一,统一采用父表分区索引,并建立索引基线检查: `migrations/versions/20251219161048_baseline_production_schema.py:2656`
7) (P1) 统一聚合表时间字段时区语义与 ORM JSON/JSONB 类型,减少 autogenerate 漂移与未来检索风险: `migrations/versions/20251219161048_baseline_production_schema.py:1393`, `app/models/account_permission.py:52`
8) (P2) 收敛冗余关系与名称规范化: 处理 `credentials.instance_ids`,引入名称规范化列/策略,降低重复与索引失配风险: `migrations/versions/20251219161048_baseline_production_schema.py:371`

---

## IV. “兼容/防御/回退/适配清单(与数据结构相关)”

> 目标: 列出当前存在的兼容性代码/兜底语义,并给出“如何收敛”的迁移路径.

- 位置: `app/services/accounts_sync/permission_manager.py:240`
  - 类型: 兼容/回填
  - 描述: 优先按 `instance_account_id` 查权限; 查不到再按 `(instance_id, db_type, username)` 兜底并尝试回填 `instance_account_id`.
  - 建议: 增加命中率埋点 -> 一次性回填(批处理) -> 强制走 `instance_account_id` 路径 -> 移除兜底分支(含迁移计划与回滚预案).

- 位置: `app/routes/instances/detail.py:619`
  - 类型: 防御
  - 描述: 将 `InstanceDatabase.is_active IS NULL` 视为 active,兼容历史数据/迁移期空值.
  - 建议: 统计 NULL 命中 -> backfill 为 true/false -> 加 NOT NULL/默认值 -> 移除 `IS NULL` 分支.

- 位置: `app/models/credential.py:186`
  - 类型: 兼容/回退
  - 描述: 凭据密码存在“旧格式非加密”场景,读取时返回空字符串并打日志,避免连接时泄露明文.
  - 建议: 增加旧格式命中统计 -> 提供离线迁移脚本统一加密 -> 移除旧格式兼容分支.

- 位置: `migrations/versions/20251219161048_baseline_production_schema.py:4211`
  - 类型: 回退
  - 描述: 基线迁移不支持 downgrade,回滚需要新建专用迁移脚本/重建库流程.
  - 建议: 建立“迁移演练”SOP(含回滚预案),后续增量迁移强制提供可逆或明确不可逆说明与替代恢复方案.
