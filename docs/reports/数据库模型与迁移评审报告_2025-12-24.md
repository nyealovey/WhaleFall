# 数据库模型与迁移“查漏补缺式”评审报告（2025-12-24）

- 生成日期：2025-12-24
- 覆盖范围：`app/models/**`、`migrations/**`、`sql/**`、`app/routes/**`、`app/services/**`
- Alembic 基线：`migrations/versions/20251219161048_baseline_production_schema.py`（revision `20251219161048`）
- 当前迁移 head：`migrations/versions/20251224164000_add_primary_keys_to_partitioned_capacity_tables.py`（revision `20251224164000`）
- 说明：
  - 本报告按 A~E 的工作方法组织在 I~III 中展开（Schema 地图 → Top10 用例反推 → 核心实体逐条审查 → 迁移演进审查 → 路线图）。
  - “证据”中的行号以本地仓库当前工作区为准（若文件变更请以实际行号复核）。
  - 仓库未提供 `filesystem-mcp`，本次通过本地 shell 读取文件生成报告。

---

## I. Schema 概览（文字 ERD）

### A. 核心实体列表（按领域分组）

#### 资产与连接域

- `instances`：数据库实例（连接目标、版本、状态、软删除）
- `credentials`：连接凭据（密文密码、类型、软删除）
- `database_type_configs`：数据库类型配置（驱动、默认端口、特性）

#### 标签域

- `tags`：标签字典（分类/颜色/启用）
- `instance_tags`：实例-标签关联（N-N）

#### 账户与权限域

- `instance_accounts`：实例账户清单（发现/最后出现/失活）
- `account_permission`：账户权限快照（宽表，多 JSONB 字段）
- `account_change_log`：账户变更日志（差异 JSONB + 会话关联字符串）
- `permission_configs`：权限字典（展示/解释用）
- `account_classifications`：账户分类（风险等级/优先级/启用）
- `classification_rules`：分类规则（表达式，当前以 Text JSON 存储）
- `account_classification_assignments`：账户分类分配（自动/手动/批次）

#### 同步与会话域

- `sync_sessions`：同步会话（批次级）
- `sync_instance_records`：同步实例记录（实例级）

#### 容量与指标域（分区表族）

- `database_size_stats`：数据库级容量明细（按 `collected_date` 月分区）
- `instance_size_stats`：实例级容量明细（按 `collected_date` 月分区）
- `database_size_aggregations`：数据库级聚合（按 `period_start` 月分区）
- `instance_size_aggregations`：实例级聚合（按 `period_start` 月分区）

#### 可观测性域

- `unified_logs`：统一日志（结构化上下文 JSONB）

### B. 关键关系（文字版 ERD）

> 约定：`A (1) -> B (N)` 表示 A 的 1 行可关联 B 的多行；若缺少 DB 外键，将在备注中标明“逻辑关联”。

- `credentials (1) -> instances (N)`：`instances.credential_id -> credentials.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1819`）
- `instances (N) <-> tags (N)`：经 `instance_tags(instance_id, tag_id)`（DB PK：`migrations/versions/20251219161048_baseline_production_schema.py:1454`）
- `instances (1) -> instance_accounts (N)`：`instance_accounts.instance_id -> instances.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1803`）
- `instance_accounts (1) -> account_permission (0/1，业务上趋向 1:1)`：`account_permission.instance_account_id -> instance_accounts.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1793`；缺少 `UNIQUE(instance_account_id)` 约束）
- `instances (1) -> instance_databases (N)`：`instance_databases.instance_id -> instances.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1808`）
- `instances (1) -> database_size_stats (N)`：`database_size_stats.instance_id -> instances.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1830`）
- `instances (1) -> instance_size_stats (N)`：`instance_size_stats.instance_id -> instances.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1840`）
- `instances (1) -> database_size_aggregations (N)`：
  - ORM 侧声明外键：`app/models/database_size_aggregation.py:60`
  - DB 基线缺失外键（仅有唯一约束 `uq_database_size_aggregation`：`migrations/versions/20251219161048_baseline_production_schema.py:1685`）
- `instances (1) -> instance_size_aggregations (N)`：`instance_size_aggregations.instance_id -> instances.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1835`）
- `sync_sessions (1) -> sync_instance_records (N)`：`sync_instance_records.session_id -> sync_sessions.session_id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1825`；缺少 `UNIQUE(session_id, instance_id)` 约束）
- `account_permission (1) -> account_classification_assignments (N)`：`account_classification_assignments.account_id -> account_permission.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1784`）
- `account_classifications (1) -> classification_rules (N)`：`classification_rules.classification_id -> account_classifications.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1798`）
- `account_classifications (1) -> account_classification_assignments (N)`：`account_classification_assignments.classification_id -> account_classifications.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1786`）
- `classification_rules (1) -> account_classification_assignments (0..N)`：`account_classification_assignments.rule_id -> classification_rules.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1787`，`ON DELETE SET NULL`）
- `users (1) -> account_classification_assignments (0..N)`：`account_classification_assignments.assigned_by -> users.id`（DB FK：`migrations/versions/20251219161048_baseline_production_schema.py:1785`）

### C. Schema 地图（全表字段 / PK / FK / Unique / Check / 索引）

> 说明：本节以 Alembic 基线 SQL + 2025-12-24 的增量迁移为准；分区父表的“主键”以 head（`20251224164000`）后的状态描述。

#### 1) `instances`

- 字段（关键）：
  - `id int4`：PK（`instances_pkey`）
  - `name varchar(255) NOT NULL`：业务唯一（`instances_name_key`），同时存在独立唯一索引 `ix_instances_name`（疑似冗余，见 III/P1）
  - `db_type varchar(50) NOT NULL`：索引 `ix_instances_db_type`
  - `host varchar(255) NOT NULL`、`port int4 NOT NULL`、`database_name varchar(255)`
  - `credential_id int4 NULL`：FK `instances_credential_id_fkey -> credentials.id`（ON DELETE NO ACTION）
  - `sync_count int4 NOT NULL DEFAULT 0`
  - `is_active bool NOT NULL DEFAULT true`、`deleted_at timestamptz NULL`（软删除）
  - `created_at timestamptz DEFAULT now()`、`updated_at timestamptz DEFAULT now()`（允许 NULL）
- 触发器：`update_instances_updated_at`（更新 `updated_at`）

#### 2) `credentials`

- 字段（关键）：
  - `id int4`：PK
  - `name varchar(255) NOT NULL`：唯一（`credentials_name_key`），同时存在索引 `ix_credentials_name`（疑似冗余，见 III/P1）
  - `credential_type varchar(50) NOT NULL`：索引 `ix_credentials_credential_type`
  - `db_type varchar(50)`：索引 `ix_credentials_db_type`
  - `username varchar(255) NOT NULL`、`password varchar(255) NOT NULL`（密文）
  - `is_active bool NOT NULL DEFAULT true`、`deleted_at timestamptz NULL`
- 触发器：`update_credentials_updated_at`
- 变更：基线中曾存在 `instance_ids jsonb`，已在迁移中删除（`migrations/versions/20251224120000_drop_credentials_instance_ids.py:32`）。

#### 3) `tags` / `instance_tags`

- `tags`
  - `id int4`：PK
  - `name varchar(50) NOT NULL`：唯一（`tags_name_key`），同时存在索引 `ix_tags_name`（疑似冗余，见 III/P1）
  - `category varchar(50) NOT NULL`：索引 `ix_tags_category`
  - `color varchar(20) NOT NULL DEFAULT 'primary'`
  - `is_active bool NOT NULL DEFAULT true`
  - `created_at/updated_at timestamptz DEFAULT now()`（允许 NULL）
  - 触发器：`update_tags_updated_at`
- `instance_tags`（关联表）
  - `instance_id int4` + `tag_id int4`：复合 PK（`instance_tags_pkey`）
  - FK：`instance_tags_instance_id_fkey`、`instance_tags_tag_id_fkey`（均 ON DELETE NO ACTION）
  - `created_at timestamptz DEFAULT now()`（允许 NULL）

#### 4) `instance_databases`

- 字段（关键）：
  - `id int4`：PK
  - `instance_id int4 NOT NULL`：FK `instance_databases_instance_id_fkey`（ON DELETE CASCADE）
  - `database_name varchar(255) NOT NULL`：与 `instance_id` 联合唯一（`instance_databases_instance_id_database_name_key`）
  - `is_active bool NOT NULL DEFAULT true`、`deleted_at timestamptz NULL`
  - `first_seen_date date NOT NULL DEFAULT CURRENT_DATE`
  - `last_seen_date date NOT NULL DEFAULT CURRENT_DATE`
  - `created_at/updated_at timestamptz DEFAULT now()`（允许 NULL）
- 索引：
  - `ix_instance_databases_instance_id(instance_id)`
  - `ix_instance_databases_database_name(database_name)`
  - `ix_instance_databases_active(is_active)`
  - `ix_instance_databases_last_seen(last_seen_date)`

#### 5) `instance_accounts`

- 字段（关键）：
  - `id int4`：PK
  - `instance_id int4 NOT NULL`：FK `instance_accounts_instance_id_fkey`（ON DELETE NO ACTION）
  - `db_type varchar(50) NOT NULL`
  - `username varchar(255) NOT NULL`
  - 联合唯一：`uq_instance_account_instance_username(instance_id, db_type, username)`
  - `is_active bool NOT NULL DEFAULT true`、`deleted_at timestamptz NULL`
  - `first_seen_at/last_seen_at timestamptz NOT NULL DEFAULT now()`
  - `created_at/updated_at timestamptz NOT NULL DEFAULT now()`
- 索引：
  - `ix_instance_accounts_active(is_active)`
  - `ix_instance_accounts_last_seen(last_seen_at)`
  - `ix_instance_accounts_username(username)`

#### 6) `account_permission`

- 字段（关键）：
  - `id int4`：PK
  - `instance_id int4 NOT NULL`：FK `fk_account_permission_instance`（ON DELETE NO ACTION）
  - `instance_account_id int4 NOT NULL`：FK `fk_account_permission_instance_account`（ON DELETE CASCADE）
  - `db_type varchar(20) NOT NULL`、`username varchar(255) NOT NULL`
  - 宽表 JSONB：`global_privileges`、`database_privileges`、`predefined_roles`、`server_roles`…、`type_specific`
  - `is_superuser bool DEFAULT false`、`is_locked bool NOT NULL`
  - `last_sync_time/last_change_time timestamptz DEFAULT now()`、`last_change_type varchar(20) DEFAULT 'add'`
- 唯一：
  - `uq_current_account_sync(instance_id, db_type, username)`（索引名与 ORM 命名不一致，见 III/P1）
- 索引（现有）：
  - `idx_instance_dbtype(instance_id, db_type)`
  - `idx_username(username)`
  - `idx_last_sync_time(last_sync_time)`
  - `idx_last_change_time(last_change_time)`
  - `ix_account_permission_is_locked(is_locked)`
- 备注：
  - ORM 声明 `instance_account_id` 带 `index=True`（`app/models/account_permission.py:46`），但 DB 基线未见对应索引（同文件中仅出现列定义与外键：`migrations/versions/20251219161048_baseline_production_schema.py:344`、`:1793`）。

#### 7) `account_change_log`

- 字段（关键）：
  - `id int4`：PK
  - `instance_id int4 NOT NULL`：FK `account_change_log_instance_id_fkey`（ON DELETE NO ACTION）
  - `db_type varchar(20) NOT NULL`、`username varchar(255) NOT NULL`
  - `change_type varchar(50) NOT NULL`
  - `change_time timestamptz DEFAULT now()`
  - `session_id varchar(128) NULL`（未 FK 到 `sync_sessions`）
  - `status varchar(20) DEFAULT 'success'`、`message text`
  - `privilege_diff/other_diff jsonb`
- 索引：覆盖 `instance_id/db_type/username/change_time` 等组合（适配变更历史查询）

#### 8) 分类域：`account_classifications` / `classification_rules` / `account_classification_assignments`

- `account_classifications`
  - `id` PK；`name` UNIQUE；`risk_level` 默认 `medium`；`priority`；`is_system/is_active`；`created_at/updated_at`
  - 触发器：`update_account_classifications_updated_at`
- `classification_rules`
  - `id` PK；`classification_id` FK；`db_type`；`rule_name`；`rule_expression text`；`is_active`；`created_at/updated_at`
  - 触发器：`update_classification_rules_updated_at`
  - 备注：缺少面向常用查询的复合索引（见 III/P1）
- `account_classification_assignments`
  - `id` PK；`account_id` FK；`classification_id` FK；`rule_id` FK（ON DELETE SET NULL）；`assigned_by` FK
  - `assignment_type` 默认 `auto`；`batch_id` 可空；`is_active` 默认 true；`assigned_at` NOT NULL
  - UNIQUE：`unique_account_classification_batch(account_id, classification_id, batch_id)`（`batch_id` 可空导致“空批次不去重”，见 III/P1）
  - 索引：`account_id`、`classification_id`、`is_active`
  - 触发器：`update_account_classification_assignments_updated_at`

#### 9) 权限字典：`permission_configs`

- UNIQUE：`uq_permission_config(db_type, category, permission_name)`
- 索引：`idx_permission_config_db_type`、`idx_permission_config_category`
- 触发器：`update_permission_configs_updated_at`

#### 10) 同步域：`sync_sessions` / `sync_instance_records`

- `sync_sessions`
  - `id` PK；`session_id` UNIQUE（`sync_sessions_session_id_key`）
  - `sync_type` / `sync_category` / `status`：均有 CHECK 约束（基线：`migrations/versions/20251219161048_baseline_production_schema.py:1574`~`:1576`）
  - 2025-12-24 增量迁移统一默认值与 CHECK：`migrations/versions/20251224152000_unify_sync_sessions_status_default_and_check.py:34`~`:52`
  - 索引：`created_at`、`session_id`、`status`、`sync_category`、`sync_type`（其中 `session_id` 与 UNIQUE 约束重复，见 III/P1）
  - 触发器：`update_sync_sessions_updated_at`
- `sync_instance_records`
  - `id` PK；`session_id` FK -> `sync_sessions.session_id`（ON DELETE CASCADE）；`instance_id` FK -> `instances.id`（ON DELETE CASCADE）
  - CHECK：`status`、`sync_category`（`migrations/versions/20251219161048_baseline_production_schema.py:1532`~`:1533`）
  - 索引：`session_id`、`instance_id`、`status`、`sync_category`、`created_at`
  - 备注：缺少 `UNIQUE(session_id, instance_id)`（见 III/P1）

#### 11) 容量分区表族：`database_size_stats` / `instance_size_stats` / `database_size_aggregations` / `instance_size_aggregations`

- `database_size_stats`（PARTITION BY RANGE `collected_date`）
  - 业务唯一：`uq_daily_database_size(instance_id, database_name, collected_date)`（`migrations/versions/20251219161048_baseline_production_schema.py:1712`）
  - FK：`database_size_stats_instance_id_fkey -> instances.id`（ON DELETE NO ACTION）
  - 索引（父表）：`ix_database_size_stats_collected_date`、`ix_database_size_stats_instance_date(instance_id, collected_date)`、`ix_database_size_stats_instance_db(instance_id, database_name)`
  - 触发器：`trg_update_instance_database_last_seen`（插入后刷新 `instance_databases.last_seen_date`）
  - 主键（head 后补齐）：`database_size_stats_pkey(id, collected_date)`（`migrations/versions/20251224164000_add_primary_keys_to_partitioned_capacity_tables.py:43`）
- `instance_size_stats`（PARTITION BY RANGE `collected_date`）
  - PK：`instance_size_stats_pkey(id, collected_date)`（基线：`migrations/versions/20251219161048_baseline_production_schema.py:1774`）
  - UNIQUE（部分索引）：`uq_instance_size_stats_instance_date(instance_id, collected_date) WHERE is_deleted = false`（基线：`migrations/versions/20251219161048_baseline_production_schema.py:1759`）
  - FK：`instance_size_stats_instance_id_fkey`（ON DELETE CASCADE）
  - 触发器：`instance_size_stats_partition_trigger`（自动创建缺失分区）
- `database_size_aggregations`（PARTITION BY RANGE `period_start`）
  - UNIQUE：`uq_database_size_aggregation(instance_id, database_name, period_type, period_start)`（基线：`migrations/versions/20251219161048_baseline_production_schema.py:1685`）
  - 主键（head 后补齐）：`database_size_aggregations_pkey(id, period_start)`（`migrations/versions/20251224164000_add_primary_keys_to_partitioned_capacity_tables.py:61`）
  - 索引（父表）：`ix_database_size_aggregations_instance_period(instance_id, period_type, period_start)`、`ix_database_size_aggregations_period_type(period_type, period_start)`、`ix_database_size_aggregations_id(id)`
  - 备注：
    - DB 基线缺失 `instance_id` 外键（见 I.B）
    - 2025-12-24 将 `calculated_at/created_at` 迁移为 `timestamptz`（`migrations/versions/20251224134000_convert_aggregation_timestamps_to_timestamptz.py:37`）
- `instance_size_aggregations`（PARTITION BY RANGE `period_start`）
  - PK：`instance_size_aggregations_pkey(id, period_start)`（基线：`migrations/versions/20251219161048_baseline_production_schema.py:1738`）
  - UNIQUE：`uq_instance_size_aggregation(instance_id, period_type, period_start)`（基线：`migrations/versions/20251219161048_baseline_production_schema.py:1733`）
  - FK：`instance_size_aggregations_instance_id_fkey`（ON DELETE NO ACTION）
  - 2025-12-24 将 `calculated_at/created_at` 迁移为 `timestamptz`（`migrations/versions/20251224134000_convert_aggregation_timestamps_to_timestamptz.py:37`）

#### 12) `unified_logs`

- `level`：枚举类型 `log_level` + CHECK（基线：`migrations/versions/20251219161048_baseline_production_schema.py:1642`）
- 索引：`timestamp`、`level`、`module` 及其复合索引（适合按时间窗过滤）
- 备注：如日志量增长显著，建议考虑分区或归档策略（见 II/7、III/P2）

### D. 关键用例反推（Top 10 查询/写入路径）

> 目标：从 routes/services 反推“未来数据量增长后的瓶颈点”，并对应到表/索引/约束层面。

1. 实例列表（分页 + 统计聚合）
   - 位置：`app/routes/instances/manage.py:595`（`list_instances_data`）+ `app/routes/instances/manage.py:188`（`_collect_instance_metrics`）
   - 依赖表：`instances`、`instance_databases`、`instance_accounts`、`sync_instance_records`、`instance_tags/tags`
   - 风险点：`sync_instance_records` 统计 max(completed_at) 依赖组合过滤（缺少更贴合的复合索引时，数据量上来后可能退化为多次聚合扫描）。

2. 实例详情页（账户汇总）
   - 位置：`app/routes/instances/detail.py:95`（`detail`）
   - 依赖表：`account_permission` JOIN `instance_accounts`
   - 风险点：`account_permission.instance_account_id` 缺失 DB 索引会放大 join/cnt 聚合成本（见 III/P0-4）。

3. 实例详情页（数据库容量：最新一条/每库）
   - 位置：`app/routes/instances/detail.py:602`（`_fetch_latest_database_sizes`，窗口函数 `row_number()`：`app/routes/instances/detail.py:632`）
   - 依赖表：`database_size_stats`（分区大表）LEFT JOIN `instance_databases`
   - 风险点：窗口函数在“未加日期范围”的情况下需要扫描实例所有历史分区；数据库数与天数增长后，成为 P0 级瓶颈（见 III/P0-3）。

4. 实例详情页（数据库容量：历史明细分页）
   - 位置：`app/routes/instances/detail.py:736`（`_fetch_historical_database_sizes`）
   - 风险点：`count()+offset/limit` 的传统分页在大表上昂贵；建议 keyset（见 II/4、III/P2）。

5. 数据库台账列表（数据库维度 + 最新容量）
   - 位置：`app/services/ledgers/database_ledger_service.py:51`（`get_ledger`）+ `app/services/ledgers/database_ledger_service.py:285`（`_with_latest_stats`）
   - 依赖表：`instance_databases`、`instances`、`database_size_stats`
   - 风险点：`_with_latest_stats` 的子查询对 `database_size_stats` 全量 `group_by + max`（`app/services/ledgers/database_ledger_service.py:291`）天然会跨分区扫描，数据规模上来后极易成为“页面级慢查询”（见 III/P0-3）。

6. 数据库台账详情（近 N 天趋势）
   - 位置：`app/services/ledgers/database_ledger_service.py:164`（`get_capacity_trend`）
   - 依赖索引：`database_size_stats(instance_id, collected_date)`（可分区裁剪）
   - 风险点：整体较可控；若后续提升采样频率（一天多点），需要补 `(..., collected_at)` 的排序索引以减少排序开销。

7. 数据库聚合列表/汇总（按周期/实例/库过滤）
   - 位置：`app/services/statistics/database_statistics_service.py:160`（`fetch_aggregations`）+ `app/services/statistics/database_statistics_service.py:265`（`fetch_aggregation_summary`）
   - 风险点：过滤条件使用 `period_end`（`app/services/statistics/database_statistics_service.py:60`、`:62`），不走分区键 `period_start`，导致无法有效分区裁剪（见 III/P0-2）。

8. 容量同步（单实例，含库存同步 + 统计写入 + 聚合刷新）
   - 位置：`app/routes/databases/capacity_sync.py:172`（`sync_instance_capacity`）
   - 写入表：`instance_databases`（库存）、`database_size_stats`（upsert）、`instance_size_stats`（upsert）、`*_aggregations`（写入/更新）
   - 风险点：分区缺失时写入会失败；当前聚合服务的 `_ensure_partition_for_date` 为空实现（`app/services/aggregation/aggregation_service.py:117`），需依赖外部“分区管理任务”兜底（见 III/P0-5）。

9. 数据库容量明细写入（批量 upsert）
   - 位置：`app/services/database_sync/persistence.py:31`（`save_database_stats`）
   - 依赖约束：`uq_daily_database_size(instance_id, database_name, collected_date)`（`migrations/versions/20251219161048_baseline_production_schema.py:1712`）
   - 风险点：字段 `database_name` 为字符串自然键，大小写/空白标准化不一致会造成重复库名与唯一冲突（见 II/2、III/P1）。

10. 账户同步（单实例，含库存 + 权限快照 + 变更日志 + 会话记录）
   - 入口：`app/routes/accounts/sync.py:193`（`sync_instance_accounts`）→ `app/services/accounts_sync/accounts_sync_service.py:71`（`sync_accounts`）
   - 风险点：权限快照表缺少 `instance_account_id` 索引与 1:1 约束，易在数据量增长/并发同步下引入慢查询与重复记录风险（见 III/P0-4、III/P1）。

### E. 数据规模预期（推断）与容量规划建议

> 未提供显式规模参数，本节为“从业务代码反推”的保守估计；建议补齐真实口径（见 II/7）。

- `instances`：10^2 ~ 10^3
- `instance_databases`：10^4 ~ 10^5（取决于每实例库数量）
- `instance_accounts` / `account_permission`：10^4 ~ 10^6（取决于每实例账户数量与同步范围）
- `database_size_stats`：约 `活跃数据库数/天 × 365`，一年可能达到 10^7 级别；月分区合理，但“跨所有历史分区求最新/求 max”会成为核心瓶颈。
- `*_aggregations`：若包含 daily，则量级接近 stats；若仅 weekly/monthly/quarterly，则显著更小。建议明确是否真的需要 daily 聚合。
- `unified_logs`：日志 QPS 取决于写入方式；当前任务按 30 天清理（`app/tasks/log_cleanup_tasks.py:24`），但 LIKE 搜索与大批量 DELETE 仍需关注。

---

## II. 缺口地图（按 1~8 维度逐条；缺口描述 + 建议补写的建模规范/ADR 标题）

### 1) 实体与关系建模（Modeling）

- 缺口：派生数据（容量明细/聚合、权限快照）与主数据（实例/数据库/账户库存）之间缺少“强约束”或“明确解耦策略”，导致出现大量防御性 JOIN/None 兜底与潜在脏数据入口（如 `database_size_aggregations` 缺 FK）。
- 建议 ADR：
  - `ADR: 主数据与派生数据的关系边界（FK/逻辑关联/保留策略）`
  - `ADR: 账户权限快照（宽表 JSONB）与库存表（instance_accounts）的一致性约束`

### 2) 字段设计（Columns）

- 缺口：时间字段与时区语义在历史上存在漂移（已通过 2025-12-24 迁移部分修复），但仍需要“全局规范”（哪些字段必须 `timestamptz`、哪些允许 `date`）。
- 缺口：核心自然键（`database_name`、`username`）未定义标准化策略（大小写/trim/编码），唯一约束与查询行为可能出现“看似相同但不相等”的重复数据。
- 建议 ADR：
  - `ADR: 时间字段规范（timestamptz + UTC + 序列化约定）`
  - `ADR: 自然键规范化（username/database_name）与大小写一致性策略`

### 3) 约束与数据完整性（Integrity）

- 缺口：`database_size_aggregations` 缺失 `instance_id` 外键；`sync_instance_records` 缺少“每会话每实例唯一”约束；`account_permission` 缺少 `UNIQUE(instance_account_id)` 约束。
- 缺口：多处枚举字段仅靠应用层约束（或完全无约束），DB 缺少 CHECK/ENUM 兜底（risk_level、assignment_type、change_type 等）。
- 建议 ADR：
  - `ADR: 外键与 ON DELETE 行为矩阵（RESTRICT/CASCADE/SET NULL）`
  - `ADR: 幂等/去重约束（会话记录、快照记录、批次写入）`

### 4) 索引与性能（Performance）

- 缺口：分区大表存在“未带分区键的聚合/求最新”查询路径，未来数据量上来后会出现页面级慢查询（台账、实例详情容量）。
- 缺口：传统分页（count+offset）与 LIKE 搜索在大表上不可扩展；缺少 keyset pagination、全文检索/pg_trgm 等规划。
- 建议 ADR：
  - `ADR: 分区表查询规范（必须包含分区键/避免跨分区 group by）`
  - `ADR: 大表分页与检索策略（keyset、GIN/pg_trgm、物化视图）`

### 5) 迁移与版本演进（Migrations & Evolution）

- 缺口：存在“多来源 schema”（`migrations` vs `sql/init_postgresql.sql`）且两者在局部已产生漂移，会导致建库/升级路径不可复现或迁移失败（见 III/P0-6）。
- 缺口：分区父表补主键、列类型变更等属于潜在长耗时/锁表操作，缺少“零停机分阶段迁移”模板。
- 建议 ADR：
  - `ADR: Schema Source of Truth（迁移驱动 vs SQL 初始化脚本）`
  - `ADR: 零停机迁移分阶段策略（add nullable → backfill → add constraint → cleanup）`

### 6) 事务与并发一致性（Concurrency）

- 缺口：同步流程多处使用“先查后插/更”的应用层逻辑（库存同步、聚合写入），缺少 DB 层幂等约束兜底与并发冲突策略（如 ON CONFLICT、唯一约束）。
- 建议 ADR：
  - `ADR: 同步任务并发模型与幂等写入策略（ON CONFLICT / advisory lock / 幂等键）`

### 7) 安全与数据治理（Governance）

- 缺口：凭据表存储密文密码，但缺少“密钥轮换/最小化暴露/访问审计”的 DB 侧/应用侧治理约定；日志表可能承载敏感上下文，需要明确脱敏策略。
- 缺口：日志与会话数据 30 天清理是“硬删除 + 全表条件 delete”，长期可能需要分区/归档以降低维护成本。
- 建议 ADR：
  - `ADR: 敏感字段治理（credentials/users/log context）与审计策略`
  - `ADR: 历史数据保留与归档/分区策略（日志、同步记录、容量明细）`

### 8) 兼容/防御/回退/适配（重点关注兜底）

- 缺口：当前存在多处“为了数据漂移而做的防御性兜底”（如将缺失库存行视为 active、旧密文格式返回空密码），但缺少“埋点→回填→移除兜底”的治理闭环。
- 建议 ADR：
  - `ADR: Schema 兼容层清理流程（埋点、命中率、回填、移除、删列计划）`

---

## III. 模型设计问题清单（按 P0/P1/P2 分组）

### P0

#### P0-1：容量分区表主键已变更，但 ORM 未对齐（可能导致 ORM 身份映射不一致与慢查询）

- 证据：
  - DB 侧为分区父表补齐复合主键：`migrations/versions/20251224164000_add_primary_keys_to_partitioned_capacity_tables.py:43`（`database_size_stats_pkey(id, collected_date)`）、`:61`（`database_size_aggregations_pkey(id, period_start)`）
  - ORM 仍将 `id` 作为单列主键：`app/models/database_size_stat.py:47`、`app/models/database_size_aggregation.py:59`
- 影响：
  - 最坏情况：SQLAlchemy 认为 `id` 全局唯一，但 DB 实际主键为复合键，可能出现对象 identity 冲突、`session.get()` 命中错误、更新/删除条件不完整等隐患。
  - 最可能发生方式：在台账/详情等场景未来引入“按主键读取/更新”时触发；或在分区表存在“同 id 不同分区键”的极端情况下产生不可预期行为。
- 根因：PostgreSQL 分区表要求 `PRIMARY KEY/UNIQUE` 包含分区键，迁移已按此补齐，但 ORM 模型仍停留在“单列主键”假设。
- 建议：
  - 短期止血（1~3 天）：
    - 将 ORM 的主键声明改为与 DB 一致（`database_size_stats`: `primary_key=(id, collected_date)`；`database_size_aggregations`: `primary_key=(id, period_start)`），并明确禁止“仅按 id”做对象级访问。
    - 在关键查询中尽量携带分区键（至少带 `collected_date/period_start` 的范围），避免跨分区扫描。
  - 中期重构（1~2 周）：
    - 为“按库/按实例的最新值”引入独立的 latest/snapshot 表或物化视图，减少对分区表的 ORM identity 依赖。
  - 长期演进：
    - 若确实需要 `id` 全局唯一语义，考虑将访问面收敛到自然键（`(instance_id, database_name, collected_date)` 等）并减少对 `id` 的外露。
- 验证：
  - SQL：校验主键存在且为复合键
    - `SELECT conname, conrelid::regclass::text, pg_get_constraintdef(oid) FROM pg_constraint WHERE contype='p' AND conrelid IN ('public.database_size_stats'::regclass,'public.database_size_aggregations'::regclass);`
  - 迁移演练：空库 `flask db upgrade` 后，用 SQLAlchemy 做一次“插入→查询→更新→删除”并确认 WHERE 条件包含复合键且无全表扫描。

#### P0-2：`database_size_aggregations` 缺失外键（DB/ORM 漂移，易产生孤儿数据）

- 证据：
  - ORM 侧声明外键：`app/models/database_size_aggregation.py:60`
  - DB 基线仅有唯一约束，无 `instance_id` 外键：`migrations/versions/20251219161048_baseline_production_schema.py:593`（建表）、`:1685`（唯一约束）；对比同域表 `instance_size_aggregations` 的外键：`migrations/versions/20251219161048_baseline_production_schema.py:1835`
- 影响：
  - 最坏情况：实例被硬删除/数据回收后仍残留聚合数据，导致统计口径错误；或写入错误 instance_id 形成长期脏数据。
  - 最可能发生方式：批量删除实例（`app/services/instances/batch_service.py:256`）以应用层 delete 为主，未必覆盖所有边界；或后续脚本/手工导入绕过应用层。
- 根因：生产导出基线遗漏了该外键；后续迁移未补齐。
- 建议：
  - 短期止血（1~3 天）：补一条增量迁移为 `database_size_aggregations.instance_id` 增加 FK（建议 ON DELETE NO ACTION/RESTRICT，避免大表级联删除造成长事务）。
  - 中期重构（1~2 周）：评估是否需要进一步增加到 `instance_databases` 的复合外键（权衡写入开销与完整性收益）。
  - 长期演进：将“派生表允许脱离主数据存在”的策略写成 ADR，若允许则必须引入明确的清理与审计机制。
- 验证：
  - SQL：查找孤儿聚合
    - `SELECT a.instance_id, count(*) FROM database_size_aggregations a LEFT JOIN instances i ON i.id=a.instance_id WHERE i.id IS NULL GROUP BY a.instance_id;`
  - SQL：校验外键存在
    - `SELECT conname, pg_get_constraintdef(oid) FROM pg_constraint WHERE conrelid='public.database_size_aggregations'::regclass AND contype='f';`

#### P0-3：多条“求最新/求 max”的查询路径跨分区扫描，容量表增长后会成为核心瓶颈

- 证据：
  - 台账“最新容量”子查询：`app/services/ledgers/database_ledger_service.py:285`~`:313`（`max(DatabaseSizeStat.collected_at)`：`app/services/ledgers/database_ledger_service.py:291`）
  - 实例详情“每库最新容量”窗口函数：`app/routes/instances/detail.py:602`~`:734`（`row_number()`：`app/routes/instances/detail.py:632`）
  - 数据库聚合过滤使用 `period_end`（非分区键）：`app/services/statistics/database_statistics_service.py:60`、`:62`
- 影响：
  - 最坏情况：随着 `database_size_stats` 达到 10^7 级别，页面接口出现秒级甚至分钟级响应；数据库 CPU/IO 被长期占满，影响写入与其他查询。
  - 最可能发生方式：台账/实例详情属于高频页面，且查询默认不带严格时间窗口。
- 根因：
  - 分区键是 `collected_date/period_start`，但关键查询没有使用分区键进行裁剪（或使用了不可裁剪字段）。
  - 缺少“latest snapshot”类数据结构，导致每次都从明细/聚合大表中现算“最新”。
- 建议：
  - 短期止血（1~3 天）：
    - 给这些接口增加默认时间窗（例如最近 90 天），并要求前端显式选择更长范围。
    - 将 `database_statistics_service` 的时间过滤从 `period_end` 改为 `period_start`（或同时加 `period_start` 条件）以启用分区裁剪。
  - 中期重构（1~2 周）：
    - 引入 `database_size_latest`（每 `(instance_id, database_name)` 一行）与 `instance_size_latest`，在写入 `*_stats` 时同步 upsert；页面/台账改查 latest 表，历史曲线仍查分区表。
    - 或使用物化视图 + 定时刷新（视数据新鲜度容忍度）。
  - 长期演进：
    - 将“最新值/榜单/汇总”的计算从 OLTP 查询中剥离，落到异步聚合/预计算体系。
- 验证：
  - SQL：对关键查询做 `EXPLAIN (ANALYZE, BUFFERS)`，确认出现分区裁剪（`Partition Pruning`）且避免跨所有分区聚合。
  - 指标：在 10^7 级别模拟数据下，台账与实例详情的 P95 需可控（建议 <500ms）。

#### P0-4：`account_permission.instance_account_id` 缺少 DB 索引与 1:1 约束，既慢又易脏

- 证据：
  - 业务高频 join：`app/routes/instances/detail.py:132`（`AccountPermission.instance_account_id == InstanceAccount.id`）
  - 同步侧按 `instance_account_id` 查找：`app/services/accounts_sync/permission_manager.py:242`
  - ORM 标注 `index=True`：`app/models/account_permission.py:46`；但基线 DDL 仅包含列与外键（`migrations/versions/20251219161048_baseline_production_schema.py:344`、`:1793`），未见 `CREATE INDEX`。
- 影响：
  - 最坏情况：账户规模上来后，实例详情页/账户列表的 join 退化为大范围扫描；同步时每个账户一次查询导致整体同步时间暴涨（隐性 N+1）。
  - 数据一致性：缺少 `UNIQUE(instance_account_id)` 时，理论上可出现多条权限快照指向同一库存账户（应用 bug/并发时更易出现）。
- 根因：表结构从“自然键唯一”演进到“库存 id 关联”过程中，缺少同步补齐索引与 1:1 约束的迁移。
- 建议：
  - 短期止血（1~3 天）：
    - 增加索引：`CREATE INDEX CONCURRENTLY idx_account_permission_instance_account_id ON account_permission(instance_account_id);`
    - 增加约束：`UNIQUE(instance_account_id)`（若存在历史重复先清理；或先加部分唯一 `WHERE last_sync_time IS NOT NULL` 再收敛）。
  - 中期重构（1~2 周）：
    - 评估移除 `account_permission.username/db_type` 的冗余字段（或通过触发器/应用保证与 `instance_accounts` 一致），降低“同一概念多处存储”的漂移面。
- 验证：
  - SQL：`EXPLAIN` join 与 `filter_by(instance_account_id=...)` 的访问路径应走索引。
  - SQL：检查重复
    - `SELECT instance_account_id, count(*) FROM account_permission GROUP BY instance_account_id HAVING count(*)>1;`

#### P0-5：分区依赖外部任务兜底，核心写入路径缺少“分区不存在”时的就地修复

- 证据：
  - 聚合服务分区钩子为空：`app/services/aggregation/aggregation_service.py:117`~`:133`
  - 容量同步会直接触发聚合刷新：`app/routes/databases/capacity_sync.py:141`~`:147`
  - 分区创建由定时任务兜底：`app/tasks/partition_management_tasks.py:48`
- 影响：
  - 最坏情况：在新环境、分区任务停摆或跨月边界时，写入分区表失败导致容量数据/聚合数据缺失，且错误发生在用户操作路径上（同步容量按钮）。
  - 最可能发生方式：系统刚部署、未执行分区任务；或跨月当天凌晨前后发生写入。
- 根因：分区管理被放到独立任务域，但写入路径没有“缺分区→创建→重试”的最小闭环。
- 建议：
  - 短期止血（1~3 天）：在容量写入与聚合写入前，调用 `PartitionManagementService.create_partition(target_date)`（失败则降级为“仅提示需创建分区”）。
  - 中期重构（1~2 周）：统一“分区确保”接口（写入侧/任务侧共用），并补充告警（缺分区即告警）。
- 验证：
  - 迁移演练：删除未来月份分区后触发一次容量同步，验证系统能自动创建并成功写入。

#### P0-6：`migrations` 与 `sql/init_postgresql.sql` 出现可导致迁移失败的漂移（建库/升级不可复现）

- 证据：
  - 基线迁移仍包含 `credentials.instance_ids`：`migrations/versions/20251219161048_baseline_production_schema.py:375`，而初始化脚本已移除：`sql/init_postgresql.sql:343`~`:357`
  - 基线迁移聚合表时间字段为 `timestamp without time zone`：`migrations/versions/20251219161048_baseline_production_schema.py:617`，而初始化脚本已是 `timestamptz`：`sql/init_postgresql.sql:592`
  - 增量迁移直接 `drop_column/alter_column`（无 IF EXISTS/类型判断）：`migrations/versions/20251224120000_drop_credentials_instance_ids.py:32`、`migrations/versions/20251224134000_convert_aggregation_timestamps_to_timestamptz.py:37`
- 影响：
  - 最坏情况：用 `sql/init_postgresql.sql` 建库后再执行 `flask db upgrade` 会在“删列/改类型”阶段失败（因为库已是新结构），导致环境漂移与不可复现。
  - 最可能发生方式：新环境部署按 `docs/reference/database/schema-baseline.md` 方案 A 建库，然后期望升级到 head。
- 根因：初始化脚本被“向前滚动”更新，但 Alembic 迁移链仍假设从旧基线演进；缺少统一的 schema source of truth 与可复现流程。
- 建议：
  - 短期止血（1~3 天）：
    - 明确一条可复现路径：
      1) 仅用 Alembic：空库 `flask db upgrade`；
      2) 或仅用 SQL 脚本：将 `sql/init_postgresql.sql` 补齐到 head（含 PKEY 等），然后 `flask db stamp <head_revision>`。
    - 将“SQL 建库后 stamp 的版本”从 `20251219161048` 更新为“SQL 脚本实际对应的 revision”（或直接要求 stamp head）。
  - 中期重构（1~2 周）：
    - 让增量迁移具备幂等性（`IF EXISTS`、类型判断），至少保证“脚本建库 + upgrade”不会失败。
    - 增加 CI 演练：`sql/init_postgresql.sql` 建库 → `flask db upgrade` → `alembic revision --autogenerate` 应无差异。
- 验证：
  - 演练：新建空库分别走两条路径，确保最终 schema 一致且迁移链可复现。

### P1

#### P1-1：部分唯一约束/索引命名与 ORM 不一致，易引入 autogenerate 漂移与维护成本

- 证据：`account_permission` 的唯一索引名为 `uq_current_account_sync`（`migrations/versions/20251219161048_baseline_production_schema.py:1332`），而 ORM 侧命名为 `uq_account_permission`（`app/models/account_permission.py:28`）。
- 影响：自动生成迁移时易产生“改名/重复建约束”噪声；DBA 排障时需要在代码与库里做额外映射。
- 建议：统一命名（更推荐以 DB 为准，补迁移用 `ALTER INDEX/ALTER TABLE RENAME CONSTRAINT` 或接受历史但在 ADR 中固化映射）。
- 验证：`alembic revision --autogenerate` 不应再反复提示同一约束差异。

#### P1-2：`classification_rules` 缺少贴合业务的复合索引/唯一约束，规则校验易退化为全表扫描

- 证据：
  - 存在“规则名去重”查询：`app/services/form_service/classification_rule_service.py:274`~`:285`
  - `classification_rules` 在基线中无索引（仅 PK/FK）：`migrations/versions/20251219161048_baseline_production_schema.py:352`~`:365`
- 影响：规则数量增长后（尤其多分类、多 DBType），后台校验/列表页面延迟上升。
- 建议：
  - 增加 `UNIQUE(classification_id, db_type, rule_name)`；
  - 增加 `INDEX(classification_id, db_type, is_active)`（或将 `is_active` 纳入查询计划）。
- 验证：规则增删改接口的 `exists()` 查询应走索引。

#### P1-3：`account_classification_assignments` 的联合唯一包含可空 `batch_id`，无法约束“空批次”重复写入

- 证据：唯一约束：`app/models/account_classification.py:232`~`:238`；DB 侧同名约束：`migrations/versions/20251219161048_baseline_production_schema.py:1289`
- 影响：在 `batch_id IS NULL` 的常见路径下，DB 无法阻止重复分配记录，后续统计/展示可能出现重复与口径漂移。
- 建议：
  - 方案 A：新增部分唯一索引 `UNIQUE(account_id, classification_id) WHERE batch_id IS NULL`；
  - 方案 B：将 `batch_id` 设计为非空（例如统一写入“单次操作批次 UUID”）。
- 验证：SQL 检查重复：
  - `SELECT account_id, classification_id, count(*) FROM account_classification_assignments WHERE batch_id IS NULL GROUP BY 1,2 HAVING count(*)>1;`

#### P1-4：`sync_instance_records` 缺少 `UNIQUE(session_id, instance_id)`，会话内幂等性靠应用层，存在并发重复风险

- 证据：表结构仅有 PK/检查约束，无联合唯一：`migrations/versions/20251219161048_baseline_production_schema.py:1532`~`:1538`；模型中也未定义：`app/models/sync_instance_record.py:12`~`:84`
- 影响：并发/重试时可能重复写入同一实例记录，导致进度统计与 UI 展示异常。
- 建议：补充 `UNIQUE(session_id, instance_id)`（如需允许重跑，可引入 `attempt` 字段并纳入唯一键）。
- 验证：以并发触发同步任务进行演练，确认不会出现重复记录。

#### P1-5：多处冗余索引（unique + 单列 index）增加写入成本与维护负担

- 证据（示例）：
  - `instances.name` 同时存在 `CREATE UNIQUE INDEX ix_instances_name` 与 `UNIQUE instances_name_key`：`migrations/versions/20251219161048_baseline_production_schema.py:1462`、`:1476`
  - `sync_sessions.session_id` 同时存在 `idx_sync_sessions_session_id` 与 `UNIQUE sync_sessions_session_id_key`：`migrations/versions/20251219161048_baseline_production_schema.py:1546`、`:1569`
  - `tags.name` 同时存在 `ix_tags_name` 与 `UNIQUE tags_name_key`：`migrations/versions/20251219161048_baseline_production_schema.py:1589`、`:1603`
- 影响：写入/更新成本上升；索引膨胀导致 vacuum/维护成本增加。
- 建议：以“查询是否需要”为标准逐步移除冗余索引（建议先在从库/压测环境对比写入 TPS 与查询计划）。
- 验证：`pg_stat_user_indexes` 观察低使用率索引，结合 `EXPLAIN` 验证移除不影响关键查询。

### P2

#### P2-1：日志检索与 LIKE 搜索缺少全文/三元组索引，长期会成为排障瓶颈

- 证据：日志搜索使用 `LIKE` 与 `cast(context as Text).like`：`app/routes/history/logs.py:190`~`:205`
- 影响：当日志量达到千万级，检索会显著变慢；同时增加 DB 负载影响在线业务。
- 建议：引入 `pg_trgm`（对 `module/message`）或使用 PostgreSQL FTS（对 message/context）并限定时间窗。
- 验证：对典型搜索条件做 `EXPLAIN`，确认走 GIN/GIN(trgm)。

#### P2-2：自然键大小写/编码未统一，建议引入规范化或 `citext` 以减少重复与查询复杂度

- 证据：库存同步使用原始 `database_name` 作为键（`app/services/database_sync/inventory_manager.py:52`~`:112`），容量写入也以该字段作为 upsert key（`app/services/database_sync/persistence.py:78`~`:93`）。
- 影响：跨数据源（MySQL/PG/SQLServer/Oracle）时库名/用户名大小写语义差异会引入重复、唯一冲突与统计口径偏差。
- 建议：定义规范化函数（trim + 统一大小写 + 特殊编码处理），并将唯一约束建立在规范化结果上（例如 `lower(database_name)` 的唯一索引）。
- 验证：对同库名不同大小写输入进行同步演练，应不产生重复记录。

### 路线图（最小可执行改进计划，最多 8 条）

1. 对齐容量分区表 ORM 主键（`database_size_stats`、`database_size_aggregations`）并补充“禁止按 id 单独访问”的规范与检查项。
2. 为 `database_size_aggregations.instance_id` 补齐外键（并明确 ON DELETE 策略）。
3. 将数据库聚合查询的时间过滤从 `period_end` 调整为包含 `period_start`（启用分区裁剪），并为台账/实例详情补默认时间窗。
4. 为 `account_permission(instance_account_id)` 增加索引，并引入 `UNIQUE(instance_account_id)`（或等价约束）确保 1:1。
5. 为 `sync_instance_records` 补 `UNIQUE(session_id, instance_id)` 以保证会话内幂等。
6. 明确 schema source of truth：要么“迁移驱动建库”，要么“SQL 脚本=head 并 stamp head”；修正文档与 CI 演练流程。
7. 为 `classification_rules` 补 `UNIQUE(classification_id, db_type, rule_name)` 与必要索引，避免规则规模增长导致全表扫描。
8. 分阶段治理冗余索引与 LIKE 检索（先基于 `pg_stat` 评估，再压测后移除/引入 pg_trgm）。

---

## IV. 兼容/防御/回退/适配清单（与数据结构相关）

| 位置 | 类型 | 描述 | 建议 |
|---|---|---|---|
| `app/routes/instances/detail.py:551` | 防御 | `_normalize_active_flag` 将 `InstanceDatabase.is_active` 的 NULL 视作 True（源于 stats 与库存 LEFT JOIN 可能缺行） | 通过补齐“库存行必存在”的约束（或引入 `database_id` 外键）降低 NULL 兜底面；同时加埋点统计“缺库存行”的比例 |
| `app/routes/instances/detail.py:683` | 适配 | 对未采集到容量的 inactive 数据库构造 `SimpleNamespace` 伪 `DatabaseSizeStat`（placeholder）以适配旧 UI 行为 | 建议将“库存与最新容量”在服务层统一输出 DTO，避免在 ORM 实体上做强行 cast |
| `app/models/credential.py:180` | 兼容 | `get_plain_password`：遇到旧格式非加密密码，返回空字符串并告警 | 增加命中率统计；完成历史数据回填/重加密后移除分支或强制迁移失败 |
| `app/models/account_classification.py:183` | 防御 | `get_rule_expression` JSON 解析失败返回空字典（rule_expression 为 Text，可能存入脏 JSON） | 将 `rule_expression` 迁移为 `jsonb` 并加 CHECK（json 类型），降低运行时兜底 |
| `migrations/versions/20251224152000_unify_sync_sessions_status_default_and_check.py:34` | 回退/修复 | 将历史 `pending` 状态修正为 `running`，并收紧 CHECK 集合 | 若需滚动发布，建议走“两阶段 CHECK”：先允许 pending → 数据回填 → 再收紧 |
| `app/tasks/log_cleanup_tasks.py:43` | 治理/回退 | 直接对 `unified_logs` 做条件 bulk delete（30 天） | 随日志量增长建议改为分区 + `DROP PARTITION` 或按月归档表，降低 delete/vacuum 压力 |
