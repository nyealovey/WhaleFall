# WhaleFall 架构评审（查漏补缺式，分层专项）

> 评审时间：2025-12-23  
> 评审范围：仓库代码 + 配置/脚本 + 既有评审文档（不做业务正确性审计）  
> 评审目标：补齐“分层/API 层/数据层/契约治理/可运维性”缺口；不重复既有结论，除非补充可定位证据、影响范围或更优落地解。

---

## I. “现有评审覆盖清单”（只列主题，不展开）

- 架构定位：Flask 单体 + Jinja2 SSR + 渐进式增强（页面内 JS 调内部 API）。
- 运行时组件：PostgreSQL/SQLite、缓存（Flask-Caching/Redis 可选）、APScheduler 内嵌调度、前端 Bootstrap 静态资源。
- 目录分层现状：`routes/` → `services/` → `models/`，以及 `types/`、`utils/` 的横切能力。
- 配置 SSOT：`app/settings.py` 收口；`app/config.py` 兼容入口。
- API 路径规范与 CORS/CSRF 的路径覆盖策略（`/*/api/*`）。
- Scheduler 与 Web 同进程耦合的风险与渐进拆分路线。
- 数据访问边界“有 repository 但不统一”的风险与迁移建议。
- Alembic migrations 版本控制与迁移习惯建议。
- 前端脚本加载策略、全局命名空间风险、缺少前端测试的影响。
- 代表性“防御/兼容/回退/适配”模式样例与 ADR backlog（部署拓扑、scheduler、secrets、API 分区、错误封套、健康检查、日志等）。

---

## II. “缺口地图”（按上述 1~9 维度逐条给：缺口描述 + 我应该补写的文档小节标题）

> 说明：`docs/architecture/ARCHITECTURE_REVIEW_SUPPLEMENT_2025-12-20.md` 已给出一版缺口地图；这里仅补充“仍缺失/需要更细的约束与证据链”的部分，重点偏分层与契约治理。

### 1) 需求与边界

- 缺口描述：缺少“核心链路 = 哪些功能必须不出错”的定义（例如：连接测试/账户同步/容量同步/任务调度/日志导出属于高风险能力，应当有最小权限与审计）；边界没有落成可执行约束（哪些是页面路由、哪些是内部 JSON API、哪些未来可能对外）。
- 我应该补写的文档小节标题：
  - `核心用例与关键链路清单（含高风险能力分级）`
  - `系统边界与能力分区（Web 页面 / 内部 API / 未来对外 API / 后台任务 / 外部系统）`

### 2) 运行时拓扑与部署

- 缺口描述：缺少“多 worker / 多实例下”行为的硬证据与约束（scheduler、缓存降级、文件锁、日志落盘路径）；缺少 graceful shutdown/连接池回收/后台任务退出语义。
- 我应该补写的文档小节标题：
  - `进程模型与并发语义（Gunicorn/worker/线程/greenlet）`
  - `多实例部署的单例能力治理（scheduler/锁/jobstore/幂等）`
  - `优雅关闭与资源回收（DB session/连接池/任务中断语义）`

### 3) 配置与环境一致性

- 缺口描述：虽然 Settings 已收口，但“配置变更的弃用窗口/回滚策略/一致性校验”仍缺（例如旧 env var 兜底、默认值回退命中率无指标）；缺少“哪些配置是安全边界（必须由 Secret 注入且不可落日志）”的强约束。
- 我应该补写的文档小节标题：
  - `配置 Schema 与弃用窗口（旧变量兜底的移除策略 + 命中率统计）`
  - `敏感配置边界与日志脱敏规范（Secrets/凭据/密钥）`

### 4) API 设计与契约治理

- 缺口描述：缺少“API 请求识别与未授权语义”的统一规则（JSON API 的 401/403 vs 页面 302 重定向）；缺少“Producer-owned contract”（后端拥有并保证响应 DTO 的稳定），目前前端存在 `message||error` 兜底链条。
- 我应该补写的文档小节标题：
  - `API 请求识别规则（X-Requested-With / Accept / 路径）与 401/403 语义`
  - `统一响应封套与 DTO 稳定性门禁（TypedDict/Schema + 漂移守卫）`
  - `internal API vs public API 的 ADR（版本化、认证方式、CORS/CSRF 对齐）`

### 5) 数据与一致性

- 缺口描述：事务边界未形成“可执行的唯一规则”（当前同时存在 `safe_route_call` 自动 commit、service 内 commit、route 内手动 commit）；复杂查询仍分散在 route/helpers 内，repository 规范未落。
- 我应该补写的文档小节标题：
  - `事务边界 ADR（谁负责 begin/commit/rollback；禁止分层越界提交）`
  - `数据访问层规范（repository/DAO 的目录与命名、可测性要求）`
  - `查询规范（分页/排序白名单、索引与慢查询治理）`

### 6) 可靠性与韧性（Resilience）

- 缺口描述：对外部依赖失败策略虽有点状实现，但缺少“统一策略 + 可观测信号”（例如：缓存降级、远端 DB 超时、连接测试/批量测试的限流与熔断、任务失败告警）。
- 我应该补写的文档小节标题：
  - `外部依赖失败策略（timeout/retry/circuit-break/限流）与指标`
  - `后台任务的幂等/去重/补偿与告警（at-least-once 语义）`

### 7) 安全（必须给出具体证据）

- 缺口描述：已有安全问题清单，但仍缺“架构级安全边界”落地（RBAC 权限模型、API 未授权语义统一、出网能力/SSRF 的网络侧控制与审计）。
- 我应该补写的文档小节标题：
  - `RBAC 与权限模型（数据模型/权限点/审计日志）`
  - `出网边界与 SSRF 防线（allowlist + 网络策略 + 审计）`
  - `模板/前端渲染安全基线（禁止把未转义字符串写入 HTML）`

### 8) 可观测性与可运维性

- 缺口描述：结构化日志能力存在但“贯通一致性”不足（不同入口：function-based route vs MethodView vs service 自行 commit 的日志字段不一致）；缺少“关键能力告警与 Runbook”覆盖（任务未运行/连接测试滥用/迁移失败/DB 连接耗尽）。
- 我应该补写的文档小节标题：
  - `统一日志上下文（module/action/context）在所有入口的一致性要求`
  - `关键告警与 Runbook（任务/迁移/DB/Redis/连接测试滥用）`

### 9) 代码组织与演进成本

- 缺口描述：当前缺少明确的 `app/api/`（端点层）与统一 `repository`（数据访问层）目录，导致“分层虽存在但不够硬”；测试几乎为空，会显著阻碍分层重构。
- 我应该补写的文档小节标题：
  - `分层目录约束（routes=blueprint/pages，api=endpoints，services=use-cases，repositories=data-access）`
  - `测试最小集（分层重构的护栏：权限/事务/DTO/关键查询）`

---

## III. “新增架构问题清单”（按 P0/P1/P2 分组）

### P0

#### P0-1. 事务边界“多头提交”：`safe_route_call` 自动 commit 与 service/route 手动 commit 混用，导致原子性幻觉与部分写入不可回滚

- 标题（一句话）：事务提交职责不唯一，会把一次操作拆成多次不可回滚的提交点。
- 证据：
  - `app/utils/route_safety.py:145`（`safe_route_call` 在业务函数成功后无条件 `db.session.commit()`）
  - `app/services/form_service/resource_service.py:214`（`BaseResourceService.upsert` 内部直接 `db.session.commit()`）
  - `app/routes/instances/detail.py:299`（路由闭包内手动 `db.session.commit()` + `except Exception: rollback`）
  - `app/services/connection_adapters/connection_test_service.py:95`（连接测试在 service 内更新 `last_connected` 并提交）
- 影响：
  - 最坏情况：一次“看似原子”的操作中途失败，前半段已提交、后半段回滚不了，产生脏数据/不一致状态，后续排障只能靠人工修复。
  - 最可能发生方式：service 先 commit（写入状态/审计/会话记录），随后 route 或其他 service 抛错；`safe_route_call` 的 rollback 只能回滚当前事务，无法撤销已提交部分。
- 根因：缺少“事务边界 ADR”，并且框架层（`safe_route_call`）默认承担 commit，但业务层与表单服务又各自 commit。
- 建议：
  - 短期止血（1~3 天）：
    - 定一个硬规则：**“一次用户请求/一次任务执行，只允许一个地方 commit”**，并把规则写入 `docs/architecture/spec.md` 或 ADR。
    - 先挑 1 条写操作最复杂/最常改的接口做示范迁移：把路由内手动 `commit/rollback` 改为 `with db.session.begin():`，并在 `safe_route_call` 增加可选 `auto_commit` 开关（默认保持现状，示范路由显式关闭）。
  - 中期重构（1~2 周）：
    - 统一“事务 owner”：推荐落在 **service/use-case 层**（route 只负责参数/权限/调用），repository 只做查询与写入，不提交。
    - 为“批量/导入导出/删除”等接口统一模板：`safe_route_call` + `with db.session.begin()` + 单条失败日志。
  - 长期演进（可选）：
    - 引入显式 Unit-of-Work（或在 service 层统一封装事务装饰器），并把“禁止跨层 commit”做成 lint/门禁（例如 grep `db.session.commit` 在 routes/ 中阻断）。
- 验证：
  - 人工演练：在写操作中间故意制造异常（例如抛 `ValidationError`），确认数据库无部分写入。
  - 代码扫描门禁：对 `app/routes/**` 与 `app/services/**` 分别统计 `db.session.commit()` 出现位置，确保符合新规则。

#### P0-2. 权限模型为硬编码“伪 RBAC”，默认 `view` 权限过大，导致高风险能力无法被治理与审计

- 标题（一句话）：权限校验目前不可配置、不可审计、不可演进，且默认权限粒度过粗。
- 证据：
  - `app/utils/decorators.py:379`（`user_permissions = {...}` 写死在代码里，并注明“真实应用应查询数据库”）
  - `app/routes/connections.py:123`（高风险的连接测试入口仅使用 `@view_required` 默认权限）
- 影响：
  - 最坏情况：低权限账号可使用连接测试/批量测试等能力做内网探测与凭据滥用；权限变更只能改代码发版，无法快速止血；缺少审计导致事后无法追溯。
  - 最可能发生方式：未来新增功能继续使用默认 `@view_required`，把本应“管理员/特权”能力暴露给普通用户。
- 根因：权限体系缺少数据模型与“权限点清单”，目前仅是演示级逻辑；并且“高风险能力分级”未写入架构约束。
- 建议：
  - 短期止血（1~3 天）：
    - 为高风险能力定义专用权限点（例如 `connections.test`、`connections.batch_test`），并把这些路由从默认 `view` 提升到专用权限或 `@admin_required`。
    - 在结构化日志中记录权限拒绝事件（已有告警日志），补充 `permission_type` 与 `actor_id`，并增加简单的告警规则（单位时间拒绝次数/高频访问）。
  - 中期重构（1~2 周）：
    - 落地 DB-backed RBAC：`roles`/`permissions`/`role_permissions`/`user_roles`（或简单 `user.role` + `role_permissions`）表；管理后台提供权限点可视化。
    - 形成“权限点命名规范与新增流程”（写进 ADR/规范）。
  - 长期演进（可选）：
    - 抽象策略层（Policy）与审计日志（AuditLog），对关键动作（连接测试、导出、删除、调度任务修改）强制留痕。
- 验证：
  - 使用 `user` 角色账户调用 `/connections/api/test`，应返回 403（或统一错误封套）且写入一条权限拒绝审计/日志。
  - 管理员可通过配置/DB 调整权限而无需改代码。

#### P0-3. API 未授权语义不统一：多数 JSON API 的鉴权失败走 302/HTML，前端以字符串兜底，形成“隐性契约漂移 + 安全放大器”

- 标题（一句话）：API 端点在未登录/无权限时可能返回 HTML 重定向页，前端再把它当错误字符串处理，契约与安全都不可控。
- 证据：
  - `app/utils/decorators.py:198`（权限失败仅在 `request.is_json` 时抛异常，否则 `redirect(...)`）
  - `app/static/js/core/http-u.js:270`（所有请求默认带 `X-Requested-With: XMLHttpRequest`，但后端权限判断未使用该信号）
  - `app/routes/tags/manage.py:30`（局部实现 `_prefers_json_response`，使用 `X-Requested-With` 判断，说明“API 请求识别规则”已出现分叉）
- 影响：
  - 最坏情况：前端收到登录页 HTML，被当作错误 message 传播；一旦某些页面用 `innerHTML`/`.html()` 显示错误（安全审计已指出存在此类点位），会把“鉴权失败 HTML/异常字符串”变成 XSS 载体或信息泄露放大器。
  - 最可能发生方式：GET 类 API（无 JSON body）普遍 `request.is_json == False`，导致权限失败走重定向；前端解析失败后进入兜底分支，出现“偶发、难复现”的 UI 错乱与报错。
- 根因：缺少统一的“API 请求识别规则”和“401/403 语义”ADR；同时页面路由与 API 路由物理混在一起，使中间件难以按分区生效。
- 建议：
  - 短期止血（1~3 天）：
    - 新增统一 helper：`is_api_request(request) -> bool`（基于路径包含 `/api/`、`X-Requested-With`、`Accept: application/json`），并在权限装饰器与 Flask-Login 未授权处理处统一使用。
    - 对 API 未授权/无权限统一返回 `jsonify_unified_error_message(..., status_code=401/403)`，页面路由继续使用重定向。
  - 中期重构（1~2 周）：
    - 将内部 JSON API 统一挂载到独立 blueprint（例如 `/internal-api/...` 或 `/api/v1/...`），使鉴权/限流/审计/错误封套可以按蓝图集中配置。
    - 为“未授权/无权限/CSRF 失败”添加最小集集成测试（不需要全量测试框架，也要能阻断回归）。
  - 长期演进（可选）：
    - 引入对外 API（版本化 + OpenAPI + DTO），并与页面 API 完全分区。
- 验证：
  - 未登录访问任意 `*/api/*` 路由：返回 JSON 401，响应体结构固定（而非 302/HTML）。
  - 前端错误提示不再展示整段 HTML，且错误处理只依赖一个 canonical 字段（例如 `error.message`）。

---

### P1

#### P1-1. 缺少显式 `app/api/` 端点层：blueprint/路由与业务端点函数同文件混杂，导致“分层存在但不够硬”

- 标题（一句话）：目前 `routes` 既是 blueprint 也是 endpoint，导致横切能力与分层约束难以沉淀。
- 证据：
  - `app/__init__.py:269`（蓝图注册全部来自 `app.routes.*`，没有独立 `app.api.*` 端点层）
  - `app/routes/instances/detail.py:92`（同一文件同时提供页面路由与 `/api/...` JSON 路由）
- 影响：
  - 最坏情况：权限/限流/审计/DTO 校验在各 route 文件中分散复制，形成“改一处漏一处”；后续想做 `/api/v1` 或对外 API 时迁移成本陡增。
  - 最可能发生方式：新增模块继续在 `routes/*.py` 内堆叠 endpoint 逻辑，routes 变胖并与 services/repositories 相互穿透。
- 根因：缺少对“端点层（API）/页面层（Web）/服务层（Use-case）/数据访问层（Repository）”的目录级约束与示例工程化模板。
- 建议：
  - 短期止血（1~3 天）：
    - 新建 `app/api/`（仅放 JSON 端点函数），`app/routes/` 只保留 blueprint 与 `add_url_rule` 绑定；先迁移 1 个模块（建议 `connections`，因为它最能体现权限/SSRF/错误封套的横切需求）。
  - 中期重构（1~2 周）：
    - 按领域拆分：`app/api/<domain>_api.py`、`app/pages/<domain>_pages.py`（或保留 routes 但严格区分页面/接口）；形成命名与依赖方向门禁（api/pages 只能调用 services）。
  - 长期演进（可选）：
    - 对外 API 独立命名空间与版本（`/api/v1/...`），并按契约治理（OpenAPI + DTO + 兼容窗口）。
- 验证：
  - 迁移后的模块：routes 文件只包含 blueprint 与 URL 绑定；端点函数在 `app/api/`，且所有异常路径仍通过统一错误封套返回。

#### P1-2. 数据访问层不统一：大量复杂查询仍位于 route/helpers，repository 规范未落地

- 标题（一句话）：查询/聚合逻辑分散在 route 层，导致难测、难复用、难做性能治理。
- 证据：
  - `app/routes/instances/manage.py:111`（`_build_last_sync_subquery`、`_collect_instance_metrics` 等在 route 层直接 `db.session.query(...)` 聚合统计）
  - `app/routes/instances/detail.py:123`（页面渲染闭包内直接 join+count 聚合）
- 影响：
  - 最坏情况：慢查询与 N+1 难以系统性治理；同一查询逻辑被多个路由复制，修改一处导致另一处漂移。
  - 最可能发生方式：routes 越来越胖，想加缓存/索引/分页白名单时只能到处打补丁。
- 根因：缺少“repository 的目录、命名、职责边界”硬规范；services 与 routes 的依赖方向未被门禁约束。
- 建议：
  - 短期止血（1~3 天）：
    - 建立 `app/repositories/`（或 `app/services/<domain>/repositories.py` 但要统一），先把最复杂的查询（实例列表聚合统计）抽出为 repository，并给 repository 加 1~2 个单测（不依赖前端/模板）。
  - 中期重构（1~2 周）：
    - 形成性能治理入口：repository 层统一分页/排序白名单、索引建议、慢查询日志字段（query_name、duration_ms、row_count）。
  - 长期演进（可选）：
    - 为跨库/远端 DB 访问引入明确 adapter contract（超时/权限/隔离级别），并把“远端查询”与“本地 ORM”隔离在不同层。
- 验证：
  - routes 文件中不再出现新增的复杂 join/聚合；查询变更可通过 repository 单测快速回归。

#### P1-3. MethodView/表单体系绕开 `safe_route_call`，导致错误封套/日志/回滚一致性被破坏

- 标题（一句话）：部分入口不走统一的 route safety 模板，形成“另一套异常处理世界”。
- 证据：
  - `app/views/scheduler_forms.py:85`（`SchedulerJobFormView.put` 使用 try/except 并直接返回错误响应，未统一记录 module/action/context，也未复用 `safe_route_call`）
  - `app/services/form_service/resource_service.py:214`（表单 service 自行 commit/rollback，并把 `exception` 字符串塞进结果 extra）
- 影响：
  - 最坏情况：异常被吞/被降级成普通消息，排障缺少 request_id/context；错误细节可能被直接回显给前端；事务回滚语义与 `safe_route_call` 不一致。
  - 最可能发生方式：后续更多资源表单走这套逻辑，导致“同样的错误在不同页面表现不同、日志也不同”。
- 根因：`safe_route_call` 只覆盖 function-based route；MethodView 没有统一包装；同时事务/错误封套缺少 ADR 约束。
- 建议：
  - 短期止血（1~3 天）：
    - 为 MethodView 提供统一包装（例如在 `add_url_rule` 前包装 view_func，使其也走 `safe_route_call` 的日志与异常转换），并禁止把原始异常字符串直接下发到客户端。
  - 中期重构（1~2 周）：
    - 统一错误封套：HTML 表单失败走 flash/页面；JSON 表单失败走统一 JSON 错误；两者都必须产生日志事件（module/action/context）。
  - 长期演进（可选）：
    - 用“端点层统一中间件”替代“每个视图自带 try/except”，降低漏网概率。
- 验证：
  - 触发 SchedulerJobFormView 的异常（例如传入非法 trigger 字段），客户端只收到统一错误文案，日志中能定位到 module/action/context（且不泄露 exception 原文）。

#### P1-4. `message/error` 漂移仍在链路中被前后端共同兜底，契约不可治理

- 标题（一句话）：后端与前端都在为“返回格式不一致”写兜底，长期必然形成漂移与维护债。
- 证据：
  - `app/services/connection_adapters/connection_factory.py:84`（明确声明返回 `{error}` 或 `{message}` 二选一）
  - `app/services/connection_adapters/connection_test_service.py:56`（结果同时含 `message`/`error`，且错误时拼接异常字符串）
  - `app/static/js/core/http-u.js:214`（前端错误解析 `body.message || body.error || ...`）
- 影响：
  - 最坏情况：同一错误在不同页面/模块显示不一致；前端兜底掩盖后端漂移，使漂移长期存在且无法量化。
  - 最可能发生方式：新增接口复制旧返回结构，前端继续加新兜底，最后“统一错误封套”名存实亡。
- 根因：缺少 Producer-owned contract 与门禁（DTO/TypedDict/漂移守卫），以及“兼容窗口”的退出机制（兜底命中率统计与删除计划）。
- 建议：
  - 短期止血（1~3 天）：
    - 以 `unified_success_response/unified_error_response` 为唯一出口：服务层返回结构化结果（TypedDict/ServiceResult），端点层负责封套；禁止服务层返回 `{'success':..., 'message':...}` 这种半封套结构。
    - 对前端 `message||error` 增加命中统计（至少 console/日志计数），为移除兜底提供数据。
  - 中期重构（1~2 周）：
    - 为核心 API 写 DTO（TypedDict 或 pydantic）并在端点层做响应校验；引入“错误 schema 漂移守卫”门禁到 CI。
  - 长期演进（可选）：
    - 统一 OpenAPI，形成契约自动化（生成文档/类型/前端 client）。
- 验证：
  - 前端删除 `body.message || body.error` 兜底后，核心页面依旧稳定；CI 中 drift guard 脚本无新增命中。

---

### P2

#### P2-1. 前端服务层普遍存在 `client || global.httpU || global.http` 回退，反映依赖注入/模块边界尚未定型

- 标题（一句话）：依赖从“显式注入”退化为“全局兜底”，会让前端可测试性与可演进性变差。
- 证据：
  - `app/static/js/modules/services/sync_sessions_service.js:14`（`client || global.httpU || global.http || null`）
  - `app/static/js/modules/services/logs_service.js:14`（同类全局回退）
- 影响：
  - 最坏情况：全局命名冲突/加载顺序问题导致线上偶发；重构 http client 或切换实现时难以全局替换。
  - 最可能发生方式：新页面继续复制该模式，最终无法引入更强的工程化（ESM/打包/类型）。
- 根因：缺少“前端模块加载与依赖注入”的统一规范；当前无打包构建，导致全局对象成为事实上的 service locator。
- 建议：
  - 短期止血（1~3 天）：建立单一入口 `window.WF.services.httpClient`（或类似命名空间），其他模块只从一个位置读取；禁止多重回退链。
  - 中期重构（1~2 周）：逐步迁移到 ES Modules（即便不引入重型框架，也可用最小打包/原生 module），用显式 import 替代全局。
  - 长期演进（可选）：引入构建工具（Vite/Rollup）并把 vendor 依赖纳入 lock 与回滚策略。
- 验证：删除 `global.http` 等兜底分支后，关键页面（instances/tags/scheduler/logs）仍可正常调用 API。

#### P2-2. 模板组件使用 `|safe` 注入 HTML 片段，缺少“安全 HTML 合约”会放大误用风险

- 标题（一句话）：`|safe` 是必要能力，但必须有“数据来源约束”，否则很容易把用户可控字符串当成 HTML 注入。
- 证据：
  - `app/templates/components/ui/modal.html:6`（`{{ title | safe }}`、`{{ body | safe }}`、`{{ footer | safe }}`）
  - `app/templates/components/ui/filter_card.html:10`（`{{ fields | safe }}`）
- 影响：
  - 最坏情况：一旦 title/body/fields 被拼接进用户可控字符串，形成存储型/反射型 XSS；且 CSP/安全头缺失时更难缓解。
  - 最可能发生方式：未来为了复用组件，开始把后端异常 message、用户输入、DB 字段直接塞到这些 slot 里。
- 根因：缺少“哪些变量允许 safe、哪些必须 escape”的规范与 review 门禁；组件 API 设计偏灵活但不受控。
- 建议：
  - 短期止血（1~3 天）：为 modal/filter_card 定义显式约束：仅允许传入模板片段（而非任意字符串）；必要时用 `Markup` 明确标记，并在调用处注释数据来源。
  - 中期重构（1~2 周）：对所有错误/提示渲染统一使用 `textContent`/escape；补齐 CSP（先 Report-Only）。
  - 长期演进（可选）：建立安全回归用例（XSS payload）与 lint 规则（禁止 `.innerHTML = error.message`）。
- 验证：用包含 `<img src=x onerror=alert(1)>` 的 payload 走全链路（后端→前端提示→modal），确认不会执行脚本。

#### P2-3. 测试几乎为空，分层重构缺少护栏，会把“架构演进”变成高风险操作

- 标题（一句话）：没有最小测试集，任何分层/权限/事务调整都难以稳定落地。
- 证据：
  - `tests/conftest.py:1`（仅设置环境变量，未见 unit/integration 测试文件）
- 影响：
  - 最坏情况：一次“看似重构”引入权限绕过或数据一致性问题，直到线上才发现。
  - 最可能发生方式：你会因为缺少护栏而不敢推进分层，长期在 routes/services 中继续堆逻辑。
- 根因：缺少“关键链路最小回归集”的约束（至少覆盖：权限/错误封套/事务/核心查询）。
- 建议：
  - 短期止血（1~3 天）：先补 3 类最小测试（不追求覆盖率）：
    - 权限：未登录/无权限访问 `*/api/*` 返回 401/403 JSON；
    - 事务：写操作失败不产生部分写入；
    - 契约：核心 API 响应 schema 基本字段存在（success/message/data/error）。
  - 中期重构（1~2 周）：给 repository/service 补 unit tests；给关键页面的 API 流程补 integration tests。
  - 长期演进（可选）：把 drift guard、ruff/pyright、最小集测试纳入 CI 门禁。
- 验证：重构 routes→api/repository 后，测试能阻断“302/HTML 回到 API、部分 commit、schema 漂移”等回归。

---

### “最小可执行路线图”（最多 6 条行动项，每条可在 1~3 天内独立完成或明确拆分）

1. **事务边界 ADR + 示范改造 1 条写接口**：确定“事务 owner”，给 `safe_route_call` 增加 `auto_commit` 开关并迁移 `app/routes/instances/detail.py:update_instance_detail` 去掉手动 commit/rollback，改用 `with db.session.begin()`。
2. **统一 API 未授权语义**：实现 `is_api_request`（路径 `/api/` + `X-Requested-With` + `Accept`），并改造权限装饰器与 Flask-Login 未授权处理：API 返回 JSON 401/403，页面继续 302。
3. **收口权限点并加固高风险能力**：把 `connections` 等高风险路由从默认 `view` 提升到专用权限（或 admin），并把权限点清单写入文档；同时为拒绝事件加告警（频率/来源 IP）。
4. **落地 `app/api/` 端点层（只迁移 1 个模块）**：新建 `app/api/connections_api.py`，routes 只绑定 URL；验证横切（CSRF/权限/错误封套/日志）能集中治理。
5. **落地 repository（只迁移 1 个复杂查询）**：把实例列表的聚合统计查询从 `app/routes/instances/manage.py` 抽到 `app/repositories/instance_repository.py`（或按领域目录），并加 1~2 个 unit tests。
6. **契约治理止血**：以“连接测试返回”为试点，统一后端错误 schema（移除 `message/error` 二选一），前端 `http-u` 增加兜底命中统计并给出移除计划。

---

## 附加要求：防御/兼容/回退/适配逻辑（扫描命中）

> 说明：本附录聚焦 `or` / `||` / `??` / `get('new') or get('old')` 等信号，第三方 vendor（`app/static/vendor/*`）不纳入扫描。

- 位置：`app/settings.py:177`  
  类型：兼容  
  描述：JWT 刷新 token 过期时间 env var 兼容（新旧变量二选一）。  
  建议：设弃用窗口并统计旧变量命中率，到期移除兜底。

- 位置：`app/utils/route_safety.py:111`  
  类型：防御  
  描述：日志事件名 `options.get("log_event") or f"{action}执行失败"` 回退默认事件名。  
  建议：关键链路显式提供 `log_event`，避免同名聚合导致排障困难。

- 位置：`app/utils/logging/handlers.py:180`  
  类型：回退  
  描述：`module` 字段缺失时回退 logger 名称，再回退 `"app"`。  
  建议：推进业务日志强制填 `module/action`，并对缺失计数告警。

- 位置：`app/routes/connections.py:193`  
  类型：防御/回退  
  描述：连接测试失败时 `result.get("message") or "实例连接测试失败"`。  
  建议：后端统一错误封套后移除兜底；在兜底触发时记录结构漂移指标。

- 位置：`app/services/connection_adapters/connection_factory.py:84`  
  类型：兼容（高治理成本）  
  描述：返回结构声明为 `{error}` 或 `{message}` 二选一。  
  建议：收敛为统一错误 schema（producer-owned），并用门禁阻断新增漂移。

- 位置：`app/services/accounts_sync/accounts_sync_service.py:310`  
  类型：防御  
  描述：同步结果读取 `result.get("message") or "同步失败"` 兜底。  
  建议：把 sync result 结构固化为 TypedDict/DTO，并统计兜底命中率。

- 位置：`app/routes/instances/manage.py:84`  
  类型：防御  
  描述：查询参数 `args.get("search") or ""` 回退空字符串。  
  建议：参数解析集中化（你已在多个模块开始做），并为每个参数定义类型/默认值/白名单。

- 位置：`app/services/database_sync/database_filters.py:74`  
  类型：防御/兼容  
  描述：配置读取 `raw_config.get("database_filters") or {}` 兜底空规则。  
  建议：配置 schema 校验失败应 fail-fast 或至少发告警，避免“静默不生效”。

- 位置：`app/services/form_service/classification_rule_service.py:218`  
  类型：兼容  
  描述：`rule_expression` 缺失时回退到已有资源表达式或默认 `{}`。  
  建议：完成迁移后移除默认 `{}`，并对空表达式做显式校验与提示。

- 位置：`app/static/js/core/http-u.js:221`  
  类型：兼容/回退  
  描述：错误消息解析 `body.message || body.error || ...` 兼容不同后端返回。  
  建议：后端统一错误 schema 后移除互兜底；在移除前统计兜底命中率与来源接口。

- 位置：`app/static/js/common/csrf-utils.js:69`  
  类型：兼容  
  描述：CSRF token 同时兼容 `data.csrf_token` 与 `data.data.csrf_token` 两种返回形态。  
  建议：固定 CSRF token 响应结构并写入 API 契约，完成迁移后删除兼容分支。

- 位置：`app/static/js/modules/services/sync_sessions_service.js:14`  
  类型：适配/回退  
  描述：HTTP 客户端来源 `client || global.httpU || global.http || null`。  
  建议：收敛为单一注入点（全局命名空间或模块 import），避免多重回退掩盖初始化问题。

- 位置：`app/static/js/modules/views/credentials/list.js:222`  
  类型：防御/兼容  
  描述：响应体读取 `response?.data || response || {}` 兼容不同封套/旧接口。  
  建议：后端统一封套后删除 `|| response` 兼容分支，并用测试锁定 schema。

