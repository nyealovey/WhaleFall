ANN202 Missing return type annotation for private function `handle_global_exception`
   --> app/__init__.py:124:9
    |
122 |     # 注册全局错误处理器
123 |     @app.errorhandler(Exception)
124 |     def handle_global_exception(error: Exception):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
125 |         """全局错误处理."""
126 |         payload, status_code = unified_error_response(error, context=ErrorContext(error, request))
    |
help: Add return type annotation

C901 `configure_app` is too complex (11 > 10)
   --> app/__init__.py:145:5
    |
145 | def configure_app(app: Flask, config_name: str | None = None) -> None:  # noqa: ARG001, PLR0915
    |     ^^^^^^^^^^^^^
146 |     """配置 Flask 应用的核心参数.
    |

E501 Line too long (154 > 120)
   --> app/__init__.py:237:121
    |
235 | …
236 | …
237 | …" or request.is_secure or request.headers.get(HttpHeaders.X_FORWARDED_SSL) == "on":
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
238 | …
239 | …
    |

ERA001 Found commented-out code
   --> app/__init__.py:362:5
    |
360 |     csrf.init_app(app)
361 |
362 |     # 初始化速率限制器(使用Flask-Caching)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
363 |     init_rate_limiter(cache)
    |
help: Remove commented-out code

D202 [*] No blank lines allowed after function docstring (found 1)
   --> app/__init__.py:368:5
    |
367 |   def register_blueprints(app: Flask) -> None:
368 | /     """注册所有蓝图以暴露路由.
369 | |
370 | |     Args:
371 | |         app: Flask 应用实例.
372 | |
373 | |     Returns:
374 | |         None: 蓝图全部注册后返回.
375 | |
376 | |     """
    | |_______^
377 |
378 |       blueprint_specs: list[tuple[str, str, str | None]] = [
    |
help: Remove blank line(s) after function docstring

ERA001 Found commented-out code
   --> app/__init__.py:510:1
    |
510 | # 导入模型(确保模型被注册)
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^
511 | from app.models import (  # noqa: F401, E402
512 |     credential,
    |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/config.py:20:5
   |
19 |     # ============================================================================
20 |     # 数据库连接配置(内部使用)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
21 |     # ============================================================================
22 |     CONNECTION_TIMEOUT = int(os.getenv("DB_CONNECTION_TIMEOUT", "30"))
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/config.py:26:5
   |
25 |     # ============================================================================
26 |     # 密码配置(内部使用)
   |     ^^^^^^^^^^^^^^^^^^^^
27 |     # ============================================================================
28 |     PASSWORD_HASH_ROUNDS = int(os.getenv("BCRYPT_LOG_ROUNDS", "12"))
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/config.py:31:5
   |
30 |     # ============================================================================
31 |     # 文件上传配置(内部使用)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
32 |     # ============================================================================
33 |     MAX_FILE_SIZE = int(os.getenv("MAX_FILE_SIZE", str(16 * 1024 * 1024)))  # 16MB
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/config.py:52:5
   |
50 |     # JWT配置
51 |     # ============================================================================
52 |     # 内部使用的秒数值(用于计算timedelta)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
53 |     _JWT_ACCESS_TOKEN_EXPIRES_SECONDS = int(os.getenv("JWT_ACCESS_TOKEN_EXPIRES", "3600"))  # 1小时
54 |     _JWT_REFRESH_TOKEN_EXPIRES_SECONDS = int(os.getenv("JWT_REFRESH_TOKEN_EXPIRES_SECONDS", "2592000"))  # 30天
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/config.py:80:33
   |
78 |           raise ValueError(msg)
79 |       SQLALCHEMY_TRACK_MODIFICATIONS = False
80 |       SQLALCHEMY_ENGINE_OPTIONS = {
   |  _________________________________^
81 | |         "pool_pre_ping": True,
82 | |         "pool_recycle": 300,
83 | |         "pool_timeout": CONNECTION_TIMEOUT,
84 | |         "max_overflow": 10,
85 | |         "pool_size": MAX_CONNECTIONS,
86 | |         "echo": DEBUG,  # 开发环境显示SQL,生产环境不显示
87 | |     }
   | |_____^
88 |
89 |       # ============================================================================
   |

ERA001 Found commented-out code
   --> app/config.py:129:5
    |
128 |     # ============================================================================
129 |     # 缓存TTL配置(秒)
    |     ^^^^^^^^^^^^^^^^^
130 |     # ============================================================================
131 |     CACHE_DEFAULT_TTL = int(os.getenv("CACHE_DEFAULT_TTL", str(7 * 24 * 3600)))  # 7天
    |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/constants/__init__.py:16:1
   |
15 | # 导入颜色常量
16 | # 导入HTTP状态码常量(使用Python标准库)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
17 | from http import HTTPStatus as HttpStatus
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/colors.py:7:17
   |
 6 |       # Flatly主题标准颜色映射
 7 |       COLOR_MAP = {
   |  _________________^
 8 | |         "primary": {
 9 | |             "value": "#18bc9c",
10 | |             "name": "主色绿",
11 | |             "description": "主要操作和重要信息",
12 | |             "css_class": "bg-primary",
13 | |         },
14 | |         "danger": {
15 | |             "value": "#e74c3c",
16 | |             "name": "危险红",
17 | |             "description": "高风险和危险操作",
18 | |             "css_class": "bg-danger",
19 | |         },
20 | |         "warning": {
21 | |             "value": "#f39c12",
22 | |             "name": "警告橙",
23 | |             "description": "需要注意的操作",
24 | |             "css_class": "bg-warning",
25 | |         },
26 | |         "info": {
27 | |             "value": "#3498db",
28 | |             "name": "信息蓝",
29 | |             "description": "普通信息和标准操作",
30 | |             "css_class": "bg-info",
31 | |         },
32 | |         "secondary": {
33 | |             "value": "#95a5a6",
34 | |             "name": "次要灰",
35 | |             "description": "次要信息和禁用状态",
36 | |             "css_class": "bg-secondary",
37 | |         },
38 | |         "success": {
39 | |             "value": "#18bc9c",
40 | |             "name": "成功绿",
41 | |             "description": "成功状态和安全操作",
42 | |             "css_class": "bg-success",
43 | |         },
44 | |         "dark": {
45 | |             "value": "#2c3e50",
46 | |             "name": "深色",
47 | |             "description": "重要信息和标题",
48 | |             "css_class": "bg-dark",
49 | |         },
50 | |         "light": {
51 | |             "value": "#ecf0f1",
52 | |             "name": "浅色",
53 | |             "description": "背景和辅助信息",
54 | |             "css_class": "bg-light",
55 | |         },
56 | |     }
   | |_____^
57 |
58 |       @classmethod
   |

ANN206 Missing return type annotation for classmethod `get_color_value`
  --> app/constants/colors.py:59:9
   |
58 |     @classmethod
59 |     def get_color_value(cls, color_key):
   |         ^^^^^^^^^^^^^^^
60 |         """获取颜色值.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `color_key`
  --> app/constants/colors.py:59:30
   |
58 |     @classmethod
59 |     def get_color_value(cls, color_key):
   |                              ^^^^^^^^^
60 |         """获取颜色值.
   |

ANN206 Missing return type annotation for classmethod `get_color_name`
  --> app/constants/colors.py:72:9
   |
71 |     @classmethod
72 |     def get_color_name(cls, color_key):
   |         ^^^^^^^^^^^^^^
73 |         """获取颜色名称.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `color_key`
  --> app/constants/colors.py:72:29
   |
71 |     @classmethod
72 |     def get_color_name(cls, color_key):
   |                             ^^^^^^^^^
73 |         """获取颜色名称.
   |

ANN206 Missing return type annotation for classmethod `get_color_choices`
  --> app/constants/colors.py:85:9
   |
84 |     @classmethod
85 |     def get_color_choices(cls):
   |         ^^^^^^^^^^^^^^^^^
86 |         """获取表单选择项.
   |
help: Add return type annotation

ANN206 Missing return type annotation for classmethod `get_css_class`
  --> app/constants/colors.py:96:9
   |
95 |     @classmethod
96 |     def get_css_class(cls, color_key):
   |         ^^^^^^^^^^^^^
97 |         """获取 CSS 类名.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `color_key`
  --> app/constants/colors.py:96:28
   |
95 |     @classmethod
96 |     def get_css_class(cls, color_key):
   |                            ^^^^^^^^^
97 |         """获取 CSS 类名.
   |

ANN206 Missing return type annotation for classmethod `is_valid_color`
   --> app/constants/colors.py:109:9
    |
108 |     @classmethod
109 |     def is_valid_color(cls, color_key):
    |         ^^^^^^^^^^^^^^
110 |         """验证颜色键是否有效.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `color_key`
   --> app/constants/colors.py:109:29
    |
108 |     @classmethod
109 |     def is_valid_color(cls, color_key):
    |                             ^^^^^^^^^
110 |         """验证颜色键是否有效.
    |

ANN206 Missing return type annotation for classmethod `get_color_info`
   --> app/constants/colors.py:122:9
    |
121 |     @classmethod
122 |     def get_color_info(cls, color_key):
    |         ^^^^^^^^^^^^^^
123 |         """获取完整颜色信息.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `color_key`
   --> app/constants/colors.py:122:29
    |
121 |     @classmethod
122 |     def get_color_info(cls, color_key):
    |                             ^^^^^^^^^
123 |         """获取完整颜色信息.
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/database_types.py:23:11
   |
22 |     # 所有支持的类型
23 |     ALL = [MYSQL, POSTGRESQL, SQLSERVER, ORACLE, SQLITE]
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
24 |
25 |     # 主流关系型数据库
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/database_types.py:26:18
   |
25 |     # 主流关系型数据库
26 |     RELATIONAL = [MYSQL, POSTGRESQL, SQLSERVER, ORACLE]
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |
28 |     # ============================================================================
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/database_types.py:31:21
   |
29 |       # 显示名称映射
30 |       # ============================================================================
31 |       DISPLAY_NAMES = {
   |  _____________________^
32 | |         MYSQL: "MySQL",
33 | |         POSTGRESQL: "PostgreSQL",
34 | |         SQLSERVER: "SQL Server",
35 | |         ORACLE: "Oracle Database",
36 | |         SQLITE: "SQLite",
37 | |     }
   | |_____^
38 |
39 |       # ============================================================================
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/database_types.py:42:21
   |
40 |       # 默认端口映射
41 |       # ============================================================================
42 |       DEFAULT_PORTS = {
   |  _____________________^
43 | |         MYSQL: 3306,
44 | |         POSTGRESQL: 5432,
45 | |         SQLSERVER: 1433,
46 | |         ORACLE: 1521,
47 | |         SQLITE: None,  # SQLite不需要端口
48 | |     }
   | |_____^
49 |
50 |       # ============================================================================
   |

ERA001 Found commented-out code
  --> app/constants/filter_options.py:13:1
   |
11 | from app.constants.sync_constants import SyncConstants
12 |
13 | # 数据库类型(默认配置,用作兜底或静态展示)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 | DATABASE_TYPES: Final[list[dict[str, str]]] = [
15 |     {"name": "mysql", "display_name": "MySQL", "icon": "fa-database", "color": "primary"},
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/constants/filter_options.py:28:1
   |
26 | ]
27 |
28 | # 同步操作方式(使用已有常量生成,避免重复维护)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
29 | SYNC_TYPES: Final[list[dict[str, str]]] = [
30 |     {"value": item["value"], "label": item["label"]}
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/constants/filter_options.py:78:1
   |
76 | ]
77 |
78 | # 默认分页大小(供表单/路由使用)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
79 | PAGINATION_SIZES: Final[list[int]] = [10, 20, 50, 100]
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/flash_categories.py:26:11
   |
25 |     # 所有类别
26 |     ALL = [SUCCESS, ERROR, WARNING, INFO, DANGER, PRIMARY, SECONDARY]
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |
28 |     # Bootstrap对应的CSS类
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/flash_categories.py:29:25
   |
28 |       # Bootstrap对应的CSS类
29 |       BOOTSTRAP_CLASSES = {
   |  _________________________^
30 | |         SUCCESS: "alert-success",
31 | |         ERROR: "alert-danger",
32 | |         WARNING: "alert-warning",
33 | |         INFO: "alert-info",
34 | |         DANGER: "alert-danger",
35 | |         PRIMARY: "alert-primary",
36 | |         SECONDARY: "alert-secondary",
37 | |     }
   | |_____^
38 |
39 |       # 类别对应的图标
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/flash_categories.py:40:13
   |
39 |       # 类别对应的图标
40 |       ICONS = {
   |  _____________^
41 | |         SUCCESS: "check-circle",
42 | |         ERROR: "exclamation-circle",
43 | |         WARNING: "exclamation-triangle",
44 | |         INFO: "info-circle",
45 | |         DANGER: "times-circle",
46 | |         PRIMARY: "star",
47 | |         SECONDARY: "circle",
48 | |     }
   | |_____^
49 |
50 |       # ============================================================================
   |

ERA001 Found commented-out code
  --> app/constants/http_headers.py:51:5
   |
50 |     # ============================================================================
51 |     # 自定义HTTP头(X-前缀)
   |     ^^^^^^^^^^^^^^^^^^^^^^
52 |     # ============================================================================
   |
help: Remove commented-out code

S105 Possible hardcoded password assigned to: "X_CSRF_TOKEN"
  --> app/constants/http_headers.py:55:20
   |
54 |     # CSRF保护
55 |     X_CSRF_TOKEN = "X-CSRFToken"
   |                    ^^^^^^^^^^^^^
56 |     X_XSRF_TOKEN = "X-XSRF-TOKEN"
   |

S105 Possible hardcoded password assigned to: "X_XSRF_TOKEN"
  --> app/constants/http_headers.py:56:20
   |
54 |     # CSRF保护
55 |     X_CSRF_TOKEN = "X-CSRFToken"
56 |     X_XSRF_TOKEN = "X-XSRF-TOKEN"
   |                    ^^^^^^^^^^^^^^
57 |
58 |     # 速率限制
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:27:11
   |
26 |     # 所有方法
27 |     ALL = [GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS, TRACE, CONNECT]
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
28 |
29 |     # 安全方法(不修改资源)
   |

ERA001 Found commented-out code
  --> app/constants/http_methods.py:29:5
   |
27 |     ALL = [GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS, TRACE, CONNECT]
28 |
29 |     # 安全方法(不修改资源)
   |     ^^^^^^^^^^^^^^^^^^^^^^
30 |     SAFE_METHODS = [GET, HEAD, OPTIONS]
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:30:20
   |
29 |     # 安全方法(不修改资源)
30 |     SAFE_METHODS = [GET, HEAD, OPTIONS]
   |                    ^^^^^^^^^^^^^^^^^^^^
31 |
32 |     # 幂等方法(多次调用结果相同)
   |

ERA001 Found commented-out code
  --> app/constants/http_methods.py:32:5
   |
30 |     SAFE_METHODS = [GET, HEAD, OPTIONS]
31 |
32 |     # 幂等方法(多次调用结果相同)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |     IDEMPOTENT_METHODS = [GET, PUT, DELETE, HEAD, OPTIONS]
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:33:26
   |
32 |     # 幂等方法(多次调用结果相同)
33 |     IDEMPOTENT_METHODS = [GET, PUT, DELETE, HEAD, OPTIONS]
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
34 |
35 |     # 写入方法(会修改资源)
   |

ERA001 Found commented-out code
  --> app/constants/http_methods.py:35:5
   |
33 |     IDEMPOTENT_METHODS = [GET, PUT, DELETE, HEAD, OPTIONS]
34 |
35 |     # 写入方法(会修改资源)
   |     ^^^^^^^^^^^^^^^^^^^^^^
36 |     WRITE_METHODS = [POST, PUT, PATCH, DELETE]
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:36:21
   |
35 |     # 写入方法(会修改资源)
36 |     WRITE_METHODS = [POST, PUT, PATCH, DELETE]
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
37 |
38 |     # 读取方法(不修改资源)
   |

ERA001 Found commented-out code
  --> app/constants/http_methods.py:38:5
   |
36 |     WRITE_METHODS = [POST, PUT, PATCH, DELETE]
37 |
38 |     # 读取方法(不修改资源)
   |     ^^^^^^^^^^^^^^^^^^^^^^
39 |     READ_METHODS = [GET, HEAD, OPTIONS]
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:39:20
   |
38 |     # 读取方法(不修改资源)
39 |     READ_METHODS = [GET, HEAD, OPTIONS]
   |                    ^^^^^^^^^^^^^^^^^^^^
40 |
41 |     # ============================================================================
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:24:11
   |
23 |     # 所有状态
24 |     ALL = [PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, PAUSED]
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |
26 |     # 活动状态(未结束)
   |

ERA001 Found commented-out code
  --> app/constants/status_types.py:26:5
   |
24 |     ALL = [PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, PAUSED]
25 |
26 |     # 活动状态(未结束)
   |     ^^^^^^^^^^^^^^^^^^
27 |     ACTIVE = [PENDING, RUNNING, PAUSED]
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:27:14
   |
26 |     # 活动状态(未结束)
27 |     ACTIVE = [PENDING, RUNNING, PAUSED]
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^
28 |
29 |     # 终止状态(已结束)
   |

ERA001 Found commented-out code
  --> app/constants/status_types.py:29:5
   |
27 |     ACTIVE = [PENDING, RUNNING, PAUSED]
28 |
29 |     # 终止状态(已结束)
   |     ^^^^^^^^^^^^^^^^^^
30 |     TERMINAL = [COMPLETED, FAILED, CANCELLED]
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:30:16
   |
29 |     # 终止状态(已结束)
30 |     TERMINAL = [COMPLETED, FAILED, CANCELLED]
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
31 |
32 |     # 成功状态
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:33:15
   |
32 |     # 成功状态
33 |     SUCCESS = [COMPLETED]
   |               ^^^^^^^^^^^
34 |
35 |     # 失败状态
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:36:13
   |
35 |     # 失败状态
36 |     ERROR = [FAILED, CANCELLED]
   |             ^^^^^^^^^^^^^^^^^^^
37 |
38 |     # ============================================================================
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:112:11
    |
111 |     # 所有状态
112 |     ALL = [SUCCESS, ERROR, WARNING, INFO, PENDING, RUNNING]
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
113 |
114 |     # 完成状态
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:115:17
    |
114 |     # 完成状态
115 |     COMPLETED = [SUCCESS, ERROR, WARNING]
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^
116 |
117 |     # 进行中状态
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:118:19
    |
117 |     # 进行中状态
118 |     IN_PROGRESS = [PENDING, RUNNING]
    |                   ^^^^^^^^^^^^^^^^^^
119 |
120 |     # ============================================================================
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:166:11
    |
165 |     # 所有状态
166 |     ALL = [ACTIVE, INACTIVE, MAINTENANCE, ERROR]
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
167 |
168 |     # ============================================================================
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:201:11
    |
200 |     # 所有状态
201 |     ALL = [SCHEDULED, RUNNING, PAUSED, STOPPED]
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |

D205 1 blank line required between summary line and description
 --> app/constants/sync_constants.py:1:1
  |
1 | / """鲸落 - 同步相关常量定义
2 | | 统一管理同步操作方式和同步分类的常量.
3 | | """
  | |___^
4 |
5 |   from enum import Enum
  |
help: Insert single blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:31:30
   |
30 |       # 操作方式显示名称映射
31 |       OPERATION_TYPE_DISPLAY = {
   |  ______________________________^
32 | |         SyncOperationType.MANUAL_SINGLE: "手动单台",
33 | |         SyncOperationType.MANUAL_BATCH: "手动批量",
34 | |         SyncOperationType.MANUAL_TASK: "手动任务",
35 | |         SyncOperationType.SCHEDULED_TASK: "定时任务",
36 | |     }
   | |_____^
37 |
38 |       # 同步分类显示名称映射
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:39:24
   |
38 |       # 同步分类显示名称映射
39 |       CATEGORY_DISPLAY = {
   |  ________________________^
40 | |         SyncCategory.ACCOUNT: "账户同步",
41 | |         SyncCategory.CAPACITY: "容量同步",
42 | |         SyncCategory.CONFIG: "配置同步",
43 | |         SyncCategory.AGGREGATION: "聚合统计",
44 | |         SyncCategory.OTHER: "其他",
45 | |     }
   | |_____^
46 |
47 |       # 操作方式英文描述
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:48:35
   |
47 |       # 操作方式英文描述
48 |       OPERATION_TYPE_DESCRIPTIONS = {
   |  ___________________________________^
49 | |         SyncOperationType.MANUAL_SINGLE: "Manual Single Instance Operation",
50 | |         SyncOperationType.MANUAL_BATCH: "Manual Batch Operation",
51 | |         SyncOperationType.MANUAL_TASK: "Manual Task Operation",
52 | |         SyncOperationType.SCHEDULED_TASK: "Scheduled Task Operation",
53 | |     }
   | |_____^
54 |
55 |       # 同步分类英文描述
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:56:29
   |
55 |       # 同步分类英文描述
56 |       CATEGORY_DESCRIPTIONS = {
   |  _____________________________^
57 | |         SyncCategory.ACCOUNT: "Account Synchronization",
58 | |         SyncCategory.CAPACITY: "Capacity Synchronization",
59 | |         SyncCategory.CONFIG: "Configuration Synchronization",
60 | |         SyncCategory.AGGREGATION: "Aggregation Statistics",
61 | |         SyncCategory.OTHER: "Other Operations",
62 | |     }
   | |_____^
63 |
64 |       # 数据库约束值列表
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:65:29
   |
64 |     # 数据库约束值列表
65 |     OPERATION_TYPE_VALUES = [t.value for t in SyncOperationType]
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |     CATEGORY_VALUES = [c.value for c in SyncCategory]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:66:23
   |
64 |     # 数据库约束值列表
65 |     OPERATION_TYPE_VALUES = [t.value for t in SyncOperationType]
66 |     CATEGORY_VALUES = [c.value for c in SyncCategory]
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
67 |
68 |     @staticmethod
   |

D205 1 blank line required between summary line and description
 --> app/constants/system_constants.py:1:1
  |
1 | / """鲸落 - 常量定义模块
2 | | 统一管理所有魔法数字、硬编码值和配置常量.
3 | | """
  | |___^
4 |
5 |   # 移除循环导入
  |
help: Insert single blank line

S105 Possible hardcoded password assigned to: "TOKEN_EXPIRED"
  --> app/constants/system_constants.py:62:21
   |
60 |     # 认证错误
61 |     INVALID_CREDENTIALS = "用户名或密码错误"
62 |     TOKEN_EXPIRED = "令牌已过期"
   |                     ^^^^^^^^^^^^
63 |     TOKEN_INVALID = "无效的令牌"
64 |     ACCOUNT_DISABLED = "账户已被禁用"
   |

S105 Possible hardcoded password assigned to: "TOKEN_INVALID"
  --> app/constants/system_constants.py:63:21
   |
61 |     INVALID_CREDENTIALS = "用户名或密码错误"
62 |     TOKEN_EXPIRED = "令牌已过期"
63 |     TOKEN_INVALID = "无效的令牌"
   |                     ^^^^^^^^^^^^
64 |     ACCOUNT_DISABLED = "账户已被禁用"
65 |     ACCOUNT_LOCKED = "账户已被锁定"
   |

S105 Possible hardcoded password assigned to: "PASSWORD_CHANGED"
   --> app/constants/system_constants.py:100:24
    |
 98 |     LOGIN_SUCCESS = "登录成功"
 99 |     LOGOUT_SUCCESS = "登出成功"
100 |     PASSWORD_CHANGED = "密码修改成功"
    |                        ^^^^^^^^^^^^^^
101 |     PROFILE_UPDATED = "资料更新成功"
    |

ERA001 Found commented-out code
  --> app/constants/time_constants.py:14:5
   |
13 |     # ============================================================================
14 |     # 基础时间单位(分钟)
   |     ^^^^^^^^^^^^^^^^^^^^
15 |     # ============================================================================
16 |     ONE_MINUTE = 60
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/constants/time_constants.py:40:5
   |
39 |     # ============================================================================
40 |     # 月和年(近似值)
   |     ^^^^^^^^^^^^^^^^
41 |     # ============================================================================
42 |     ONE_MONTH = 2592000    # 30天
   |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/user_roles.py:21:11
   |
20 |     # 所有角色
21 |     ALL = [ADMIN, USER, VIEWER]
   |           ^^^^^^^^^^^^^^^^^^^^^
22 |
23 |     # ============================================================================
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/user_roles.py:36:19
   |
35 |       # 角色权限映射
36 |       PERMISSIONS = {
   |  ___________________^
37 | |         ADMIN: [PERM_READ, PERM_CREATE, PERM_UPDATE, PERM_DELETE, PERM_ADMIN, PERM_EXECUTE],
38 | |         USER: [PERM_READ, PERM_CREATE, PERM_UPDATE, PERM_DELETE, PERM_EXECUTE],
39 | |         VIEWER: [PERM_READ],
40 | |     }
   | |_____^
41 |
42 |       # 角色显示名称
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/user_roles.py:43:21
   |
42 |       # 角色显示名称
43 |       DISPLAY_NAMES = {
   |  _____________________^
44 | |         ADMIN: "管理员",
45 | |         USER: "用户",
46 | |         VIEWER: "查看者",
47 | |     }
   | |_____^
48 |
49 |       # 角色描述
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/user_roles.py:50:20
   |
49 |       # 角色描述
50 |       DESCRIPTIONS = {
   |  ____________________^
51 | |         ADMIN: "拥有系统所有权限,可以管理用户和系统配置",
52 | |         USER: "可以创建、修改、删除数据,执行同步任务",
53 | |         VIEWER: "只能查看数据,不能进行任何修改操作",
54 | |     }
   | |_____^
55 |
56 |       # ============================================================================
   |

D205 1 blank line required between summary line and description
 --> app/errors/__init__.py:1:1
  |
1 | / """鲸落 - 统一异常定义
2 | | 集中维护业务异常类型、严重度与 HTTP 状态码映射.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

PLR0913 Too many arguments in function definition (6 > 5)
  --> app/errors/__init__.py:69:9
   |
67 |     )
68 |
69 |     def __init__(
   |         ^^^^^^^^
70 |         self,
71 |         message: str | None = None,
   |

D107 Missing docstring in `__init__`
  --> app/errors/__init__.py:69:9
   |
67 |     )
68 |
69 |     def __init__(
   |         ^^^^^^^^
70 |         self,
71 |         message: str | None = None,
   |

E501 Line too long (122 > 120)
   --> app/errors/__init__.py:211:121
    |
209 |         category=ErrorCategory.SECURITY,
210 |         severity=ErrorSeverity.MEDIUM,
211 |         default_message_key="RATE_LIMIT_EXCEEDED" if hasattr(ErrorMessages, "RATE_LIMIT_EXCEEDED") else "INVALID_REQUEST",
    |                                                                                                                         ^^
212 |     )
    |

A001 Variable `SystemError` is shadowing a Python builtin
   --> app/errors/__init__.py:243:7
    |
243 | class SystemError(AppError):
    |       ^^^^^^^^^^^
244 |     """表示系统级未知错误或底层故障.
    |

TC006 [*] Add quotes to type expression in `typing.cast()`
  --> app/forms/definitions/__init__.py:46:17
   |
44 |     value = getattr(module, name)
45 |     globals()[name] = value
46 |     return cast(ResourceFormDefinition, value)
   |                 ^^^^^^^^^^^^^^^^^^^^^^
   |
help: Add quotes

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `resource`
  --> app/forms/definitions/base.py:64:37
   |
62 |     """
63 |
64 |     def __call__(self, *, resource: Any | None) -> Mapping[str, Any]:
   |                                     ^^^^^^^^^^
65 |         """构造模板渲染所需的上下文字典.
   |

ANN202 Missing return type annotation for private function `__getattr__`
  --> app/models/__init__.py:39:5
   |
39 | def __getattr__(name: str):
   |     ^^^^^^^^^^^
40 |     """延迟加载模型, 避免初始化周期引发的循环导入."""
   |
help: Add return type annotation

D202 [*] No blank lines allowed after function docstring (found 1)
  --> app/models/__init__.py:40:5
   |
39 | def __getattr__(name: str):
40 |     """延迟加载模型, 避免初始化周期引发的循环导入."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
41 |
42 |     if name not in __all__:
   |
help: Remove blank line(s) after function docstring

PLC0415 `import` should be at the top-level of a file
  --> app/models/__init__.py:46:5
   |
44 |         raise AttributeError(msg)
45 |
46 |     from importlib import import_module
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
47 |
48 |     module_map = {
   |

ANN201 Missing return type annotation for public function `color_value`
  --> app/models/account_classification.py:75:9
   |
74 |     @property
75 |     def color_value(self):
   |         ^^^^^^^^^^^
76 |         """获取实际颜色值.
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `color_name`
  --> app/models/account_classification.py:85:9
   |
84 |     @property
85 |     def color_name(self):
   |         ^^^^^^^^^^
86 |         """获取颜色名称.
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `css_class`
  --> app/models/account_classification.py:95:9
   |
94 |     @property
95 |     def css_class(self):
   |         ^^^^^^^^^
96 |         """获取 CSS 类名.
   |
help: Add return type annotation

ERA001 Found commented-out code
   --> app/models/account_classification.py:222:5
    |
220 |     updated_at = db.Column(db.DateTime(timezone=True), default=time_utils.now, onupdate=time_utils.now)
221 |
222 |     # 唯一约束:一个账户在同一个批次中只能有一个分类分配
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
223 |     __table_args__ = (
224 |         db.UniqueConstraint(
    |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/models/account_permission.py:67:5
   |
65 |     database_permissions = db.Column(db.JSON, nullable=True)  # SQL Server数据库权限
66 |
67 |     # Oracle权限字段(移除表空间配额)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |     oracle_roles = db.Column(db.JSON, nullable=True)  # Oracle角色
69 |     system_privileges = db.Column(db.JSON, nullable=True)  # Oracle系统权限
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/models/account_permission.py:80:5
   |
78 |     last_change_time = db.Column(db.DateTime(timezone=True), default=time_utils.now, index=True)
79 |
80 |     # 删除标记(不支持恢复)
   |     ^^^^^^^^^^^^^^^^^^^^^^
81 |     # 关联实例与账户
82 |     instance = db.relationship("Instance", backref="account_permissions")
   |
help: Remove commented-out code

PLR0913 Too many arguments in function definition (8 > 5)
  --> app/models/credential.py:46:9
   |
44 |     deleted_at = db.Column(db.DateTime(timezone=True), nullable=True)
45 |
46 |     def __init__(
   |         ^^^^^^^^
47 |         self,
48 |         name: str,
   |

ERA001 Found commented-out code
   --> app/models/credential.py:106:9
    |
105 |         """
106 |         # 如果是bcrypt哈希(旧格式),使用bcrypt验证
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
107 |         if self.password.startswith("$2b$"):
108 |             return bcrypt.check_password_hash(self.password, password)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/models/credential.py:115:9
    |
113 |             return decrypted_password == password
114 |
115 |         # 如果是明文密码(不安全),直接比较
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
116 |         return self.password == password
    |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   --> app/models/credential.py:125:33
    |
124 |         """
125 |         if len(self.password) > 8:
    |                                 ^
126 |             return "*" * (len(self.password) - 4) + self.password[-4:]
127 |         return "*" * len(self.password)
    |

PLC0415 `import` should be at the top-level of a file
   --> app/models/credential.py:142:13
    |
140 |         if self.password.startswith("$2b$"):
141 |             # 对于旧格式,从环境变量获取密码,避免硬编码
142 |             import os
    |             ^^^^^^^^^
143 |             default_password = os.getenv(f"DEFAULT_{self.db_type.upper()}_PASSWORD")
144 |             if default_password:
    |

PLC0415 `import` should be at the top-level of a file
   --> app/models/credential.py:147:13
    |
145 |                 return default_password
146 |             # 如果没有设置环境变量,返回空字符串并记录警告
147 |             from app.utils.structlog_config import get_system_logger
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |             system_logger = get_system_logger()
149 |             system_logger.warning(
    |

G004 Logging statement uses f-string
   --> app/models/credential.py:150:17
    |
148 |             system_logger = get_system_logger()
149 |             system_logger.warning(
150 |                 f"未设置环境变量 DEFAULT_{self.db_type.upper()}_PASSWORD,无法获取密码",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
151 |                 module="credential_model",
152 |                 db_type=self.db_type,
    |
help: Convert to lazy `%` formatting

ERA001 Found commented-out code
   --> app/models/credential.py:160:9
    |
158 |             return get_password_manager().decrypt_password(self.password)
159 |
160 |         # 如果都不是,可能是明文密码(不安全)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
161 |         return self.password
    |
help: Remove commented-out code

D205 1 blank line required between summary line and description
 --> app/models/database_size_aggregation.py:1:1
  |
1 | / """数据库大小聚合统计模型
2 | | 存储每周、每月、每季度的统计信息.
3 | | """
  | |___^
4 |
5 |   from sqlalchemy import (
  |
help: Insert single blank line

ERA001 Found commented-out code
  --> app/models/database_size_aggregation.py:69:5
   |
67 |     data_count = Column(Integer, nullable=False, comment="统计的数据点数量")
68 |
69 |     # 数据大小统计(如果可获取)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
70 |     avg_data_size_mb = Column(BigInteger, nullable=True, comment="平均数据大小(MB)")
71 |     max_data_size_mb = Column(BigInteger, nullable=True, comment="最大数据大小(MB)")
   |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/models/database_size_aggregation.py:111:9
    |
109 |             "period_start",
110 |         ),
111 |         # 唯一约束(在分区表中,唯一约束会自动包含分区键)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |         UniqueConstraint(
113 |             "instance_id",
    |
help: Remove commented-out code

D205 1 blank line required between summary line and description
 --> app/models/database_size_stat.py:1:1
  |
1 | / """数据库大小统计模型
2 | | 存储每个数据库在特定时间点的大小统计信息
3 | | 支持 PostgreSQL 分区表,按日期分区.
4 | | """
  | |___^
5 |
6 |   from sqlalchemy import (
  |
help: Insert single blank line

E501 Line too long (121 > 120)
  --> app/models/database_size_stat.py:64:115
   |
62 |     )
63 |     updated_at = Column(
64 |         DateTime(timezone=True), nullable=False, default=time_utils.now, onupdate=time_utils.now, comment="记录更新时间",
   |                                                                                                                         ^
65 |     )
   |

D205 1 blank line required between summary line and description
 --> app/models/database_type_config.py:1:1
  |
1 | / """鲸落 - 数据库类型配置模型
2 | | 管理数据库类型的配置信息.
3 | | """
  | |___^
4 |
5 |   import json
  |
help: Insert single blank line

PLR0913 Too many arguments in function definition (9 > 5)
  --> app/models/instance.py:95:9
   |
93 |     # sync_data关系已移除,因为SyncData表已删除
94 |
95 |     def __init__(
   |         ^^^^^^^^
96 |         self,
97 |         name: str,
   |

D417 Missing argument description in the docstring for `__init__`: `is_active`
  --> app/models/instance.py:95:9
   |
93 |     # sync_data关系已移除,因为SyncData表已删除
94 |
95 |     def __init__(
   |         ^^^^^^^^
96 |         self,
97 |         name: str,
   |

ARG002 Unused method argument: `tags`
   --> app/models/instance.py:104:9
    |
102 |         credential_id: int | None = None,
103 |         description: str | None = None,
104 |         tags: list | None = None,
    |         ^^^^
105 |         is_active: bool = True,
106 |     ) -> None:
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/models/instance.py:105:9
    |
103 |         description: str | None = None,
104 |         tags: list | None = None,
105 |         is_active: bool = True,
    |         ^^^^^^^^^
106 |     ) -> None:
107 |         """初始化实例.
    |

FBT002 Boolean default positional argument in function definition
   --> app/models/instance.py:105:9
    |
103 |         description: str | None = None,
104 |         tags: list | None = None,
105 |         is_active: bool = True,
    |         ^^^^^^^^^
106 |     ) -> None:
107 |         """初始化实例.
    |

D205 1 blank line required between summary line and description
 --> app/models/instance_account.py:1:1
  |
1 | / """鲸落 - 实例账户关系模型
2 | | 用于维护实例包含哪些账户,以及账户的存在状态.
3 | | """
  | |___^
4 |
5 |   from app import db
  |
help: Insert single blank line

E501 Line too long (121 > 120)
  --> app/models/instance_account.py:37:115
   |
35 |     db_type = db.Column(db.String(50), nullable=False, comment="数据库类型")
36 |     is_active = db.Column(db.Boolean, default=True, nullable=False, comment="账户是否活跃")
37 |     first_seen_at = db.Column(db.DateTime(timezone=True), nullable=False, default=time_utils.now, comment="首次发现时间")
   |                                                                                                                         ^
38 |     last_seen_at = db.Column(db.DateTime(timezone=True), nullable=False, default=time_utils.now, comment="最后发现时间")
39 |     deleted_at = db.Column(db.DateTime(timezone=True), nullable=True, comment="删除时间")
   |

D205 1 blank line required between summary line and description
 --> app/models/instance_database.py:1:1
  |
1 | / """鲸落 - 实例数据库关系模型
2 | | 用于维护实例包含哪些数据库,以及数据库的状态变化.
3 | | """
  | |___^
4 |
5 |   from datetime import date
  |
help: Insert single blank line

D205 1 blank line required between summary line and description
 --> app/models/instance_size_aggregation.py:1:1
  |
1 | / """实例大小聚合统计模型
2 | | 存储实例级别的每周、每月、每季度的统计信息.
3 | | """
  | |___^
4 |
5 |   from sqlalchemy import (
  |
help: Insert single blank line

ERA001 Found commented-out code
   --> app/models/instance_size_aggregation.py:106:9
    |
104 |             "period_start",
105 |         ),
106 |         # 唯一约束(在分区表中,唯一约束会自动包含分区键)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
107 |         UniqueConstraint(
108 |             "instance_id",
    |
help: Remove commented-out code

ANN202 Missing return type annotation for private function `_to_float`
   --> app/models/instance_size_aggregation.py:134:13
    |
133 |         """
134 |         def _to_float(value):
    |             ^^^^^^^^^
135 |             return float(value) if value is not None else None
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `value`
   --> app/models/instance_size_aggregation.py:134:23
    |
133 |         """
134 |         def _to_float(value):
    |                       ^^^^^
135 |             return float(value) if value is not None else None
    |

D205 1 blank line required between summary line and description
 --> app/models/instance_size_stat.py:1:1
  |
1 | / """鲸落 - 实例大小统计模型
2 | | 存储数据库实例的总大小统计数据.
3 | | """
  | |___^
4 |
5 |   from app import db
  |
help: Insert single blank line

E501 Line too long (123 > 120)
  --> app/models/instance_size_stat.py:41:118
   |
39 |     deleted_at = db.Column(db.DateTime(timezone=True), nullable=True, comment="删除时间")
40 |     created_at = db.Column(db.DateTime(timezone=True), default=time_utils.now, comment="创建时间")
41 |     updated_at = db.Column(db.DateTime(timezone=True), default=time_utils.now, onupdate=time_utils.now, comment="更新时间")
   |                                                                                                                          ^^
42 |
43 |     # 关系
   |

ARG002 Unused method argument: `created_by`
  --> app/models/sync_session.py:67:72
   |
65 |     )
66 |
67 |     def __init__(self, sync_type: str, sync_category: str = "account", created_by: int | None = None) -> None:
   |                                                                        ^^^^^^^^^^
68 |         """初始化同步会话.
   |

FBT001 Boolean-typed positional argument in function definition
  --> app/models/tag.py:45:9
   |
43 |         category: str,
44 |         color: str = "primary",
45 |         is_active: bool = True,
   |         ^^^^^^^^^
46 |     ) -> None:
47 |         """初始化标签.
   |

FBT002 Boolean default positional argument in function definition
  --> app/models/tag.py:45:9
   |
43 |         category: str,
44 |         color: str = "primary",
45 |         is_active: bool = True,
   |         ^^^^^^^^^
46 |     ) -> None:
47 |         """初始化标签.
   |

ANN201 Missing return type annotation for public function `color_value`
  --> app/models/tag.py:64:9
   |
63 |     @property
64 |     def color_value(self):
   |         ^^^^^^^^^^^
65 |         """获取实际颜色值.
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `color_name`
  --> app/models/tag.py:74:9
   |
73 |     @property
74 |     def color_name(self):
   |         ^^^^^^^^^^
75 |         """获取颜色名称.
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `css_class`
  --> app/models/tag.py:84:9
   |
83 |     @property
84 |     def css_class(self):
   |         ^^^^^^^^^
85 |         """获取 CSS 类名.
   |
help: Add return type annotation

D205 1 blank line required between summary line and description
 --> app/models/unified_log.py:1:1
  |
1 | / """鲸落 - 统一日志系统数据模型
2 | | 基于structlog的统一日志存储模型.
3 | | """
  | |___^
4 |
5 |   from datetime import datetime, timedelta
  |
help: Insert single blank line

ERA001 Found commented-out code
  --> app/models/unified_log.py:38:5
   |
36 |     id = Column(Integer, primary_key=True, autoincrement=True)
37 |
38 |     # 日志时间戳 (UTC)
   |     ^^^^^^^^^^^^^^^^^^
39 |     timestamp = Column(DateTime(timezone=True), nullable=False, index=True)
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/models/unified_log.py:50:5
   |
48 |     message = Column(Text, nullable=False)
49 |
50 |     # 错误堆栈追踪 (仅ERROR/CRITICAL)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |     traceback = Column(Text, nullable=True)
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/models/unified_log.py:53:5
   |
51 |     traceback = Column(Text, nullable=True)
52 |
53 |     # 附加上下文 (JSON格式)
   |     ^^^^^^^^^^^^^^^^^^^^^^^
54 |     context = Column(JSON, nullable=True)
   |
help: Remove commented-out code

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/models/unified_log.py:98:9
    |
 97 |     @classmethod
 98 |     def create_log_entry(
    |         ^^^^^^^^^^^^^^^^
 99 |         cls,
100 |         level: LogLevel,
    |

PLC0415 `import` should be at the top-level of a file
   --> app/models/unified_log.py:126:13
    |
124 |         elif timestamp.tzinfo is None:
125 |             # 如果没有时区信息,假设为UTC时间
126 |             from app.utils.time_utils import UTC_TZ
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 |
128 |             timestamp = timestamp.replace(tzinfo=UTC_TZ)
    |

PLC0415 `import` should be at the top-level of a file
   --> app/models/unified_log.py:150:9
    |
149 |         """
150 |         from sqlalchemy import func
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
151 |
152 |         start_time = time_utils.now() - timedelta(hours=hours)
    |

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
  --> app/models/user.py:69:28
   |
67 |         """
68 |         # 增加密码强度验证
69 |         if len(password) < 8:
   |                            ^
70 |             error_msg = "密码长度至少8位"
71 |             raise ValueError(error_msg)
   |

F401 `flask.Blueprint` imported but unused
  --> app/routes/__init__.py:22:19
   |
20 | """
21 |
22 | from flask import Blueprint
   |                   ^^^^^^^^^
23 |
24 | # 创建主蓝图
   |
help: Remove unused import: `flask.Blueprint`

INP001 File `app/routes/accounts/classifications.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/accounts/classifications.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/accounts/classifications.py:12:24
   |
10 | from app.constants import HttpStatus
11 | from app.constants.colors import ThemeColors
12 | from app.errors import SystemError, ValidationError
   |                        ^^^^^^^^^^^
13 | from app.models.account_classification import (
14 |     AccountClassification,
   |

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/accounts/classifications.py:376:9
    |
374 |       result = []
375 |       for rule in rules:
376 | /         result.append(
377 | |             {
378 | |                 "id": rule.id,
379 | |                 "rule_name": rule.rule_name,
380 | |                 "classification_id": rule.classification_id,
381 | |                 "classification_name": rule.classification.name if rule.classification else None,
382 | |                 "db_type": rule.db_type,
383 | |                 "rule_expression": rule.rule_expression,
384 | |                 "is_active": rule.is_active,
385 | |                 "matched_accounts_count": 0,
386 | |                 "created_at": rule.created_at.isoformat() if rule.created_at else None,
387 | |                 "updated_at": rule.updated_at.isoformat() if rule.updated_at else None,
388 | |             },
389 | |         )
    | |_________^
390 |
391 |       rules_by_db_type: dict[str, list[dict[str, object]]] = {}
    |
help: Replace for loop with list comprehension

ERA001 Found commented-out code
   --> app/routes/accounts/classifications.py:722:1
    |
721 | # ---------------------------------------------------------------------------
722 | # 表单路由(独立页面)
    | ^^^^^^^^^^^^^^^^^^^^
723 | # ---------------------------------------------------------------------------
724 | _classification_create_view = AccountClassificationFormView.as_view("classification_create_form")
    |
help: Remove commented-out code

PLC0415 `import` should be at the top-level of a file
   --> app/routes/accounts/classifications.py:773:5
    |
772 |     """
773 |     from app.models.permission_config import PermissionConfig
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
774 |
775 |     # 从数据库获取权限配置
    |

INP001 File `app/routes/accounts/ledgers.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/accounts/ledgers.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/accounts/ledgers.py:9:24
   |
 8 | from app.constants import DATABASE_TYPES, DatabaseType
 9 | from app.errors import SystemError
   |                        ^^^^^^^^^^^
10 | from app.models.account_classification import (
11 |     AccountClassification,
   |

C901 `list_accounts` is too complex (18 > 10)
  --> app/routes/accounts/ledgers.py:32:5
   |
30 | @login_required
31 | @view_required
32 | def list_accounts(db_type: str | None = None) -> str | tuple[Response, int]:
   |     ^^^^^^^^^^^^^
33 |     """账户列表页面.
   |

PLR0912 Too many branches (17 > 12)
  --> app/routes/accounts/ledgers.py:32:5
   |
30 | @login_required
31 | @view_required
32 | def list_accounts(db_type: str | None = None) -> str | tuple[Response, int]:
   |     ^^^^^^^^^^^^^
33 |     """账户列表页面.
   |

PLR0915 Too many statements (65 > 50)
  --> app/routes/accounts/ledgers.py:32:5
   |
30 | @login_required
31 | @view_required
32 | def list_accounts(db_type: str | None = None) -> str | tuple[Response, int]:
   |     ^^^^^^^^^^^^^
33 |     """账户列表页面.
   |

PLC0415 `import` should be at the top-level of a file
  --> app/routes/accounts/ledgers.py:76:9
   |
74 |     # 搜索过滤 - 支持用户名、实例名称、IP地址搜索
75 |     if search:
76 |         from app import db
   |         ^^^^^^^^^^^^^^^^^^
77 |         # 通过JOIN实例表来搜索实例名称和IP地址
78 |         query = query.join(Instance, AccountPermission.instance_id == Instance.id)
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/accounts/ledgers.py:104:16
    |
102 |             query = query.join(Instance).join(Instance.tags).filter(Tag.name.in_(tags))
103 |             # 应用标签过滤
104 |         except Exception as e:
    |                ^^^^^^^^^
105 |             log_error(
106 |                 "标签过滤失败",
    |

ERA001 Found commented-out code
   --> app/routes/accounts/ledgers.py:114:5
    |
112 |     # 标签过滤逻辑
113 |
114 |     # 分类过滤 - 使用分配表查询(现在分配表数据是准确的)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
115 |     if classification_filter:
116 |         from app.models.account_classification import AccountClassification, AccountClassificationAssignment
    |
help: Remove commented-out code

PLC0415 `import` should be at the top-level of a file
   --> app/routes/accounts/ledgers.py:116:9
    |
114 |     # 分类过滤 - 使用分配表查询(现在分配表数据是准确的)
115 |     if classification_filter:
116 |         from app.models.account_classification import AccountClassification, AccountClassificationAssignment
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
117 |
118 |         try:
    |

E501 Line too long (123 > 120)
   --> app/routes/accounts/ledgers.py:126:121
    |
124 |                 query.join(AccountClassificationAssignment)
125 |                 .join(AccountClassification)
126 |                 .filter(AccountClassification.id == classification_id, AccountClassificationAssignment.is_active.is_(True))
    |                                                                                                                         ^^^
127 |             )
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/accounts/ledgers.py:169:5
    |
168 |     # 获取账户分类信息
169 |     from app.models.account_classification import AccountClassificationAssignment
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
170 |
171 |     classifications = {}
    |

C901 `list_accounts_data` is too complex (18 > 10)
   --> app/routes/accounts/ledgers.py:313:5
    |
311 | @login_required
312 | @view_required
313 | def list_accounts_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^
314 |     """Grid.js 账户列表 API.
    |

PLR0912 Too many branches (17 > 12)
   --> app/routes/accounts/ledgers.py:313:5
    |
311 | @login_required
312 | @view_required
313 | def list_accounts_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^
314 |     """Grid.js 账户列表 API.
    |

PLR0915 Too many statements (62 > 50)
   --> app/routes/accounts/ledgers.py:313:5
    |
311 | @login_required
312 | @view_required
313 | def list_accounts_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^
314 |     """Grid.js 账户列表 API.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/accounts/ledgers.py:369:16
    |
367 |         try:
368 |             query = query.join(Instance).join(Instance.tags).filter(Tag.name.in_(tags))
369 |         except Exception as exc:
    |                ^^^^^^^^^
370 |             log_error(
371 |                 "标签过滤失败",
    |

INP001 File `app/routes/accounts/statistics.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/accounts/statistics.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
 --> app/routes/accounts/statistics.py:7:24
  |
6 | from app.constants import FlashCategory
7 | from app.errors import SystemError
  |                        ^^^^^^^^^^^
8 | from app.models.instance import Instance
9 | from app.services.statistics.account_statistics_service import (
  |

PLC0415 `import` should be at the top-level of a file
  --> app/routes/accounts/statistics.py:39:5
   |
37 |         flash("获取账户统计信息失败,请稍后重试", FlashCategory.ERROR)
38 |
39 |     from app.models.sync_session import SyncSession
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
40 |
41 |     recent_syncs = SyncSession.query.order_by(SyncSession.created_at.desc()).limit(10).all()
   |

INP001 File `app/routes/accounts/sync.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/accounts/sync.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/accounts/sync.py:11:39
   |
 9 | from app import db
10 | from app.constants.sync_constants import SyncOperationType
11 | from app.errors import NotFoundError, SystemError, ValidationError as AppValidationError
   |                                       ^^^^^^^^^^^
12 | from app.models.instance import Instance
13 | from app.services.accounts_sync import accounts_sync_service
   |

TRY301 Abstract `raise` to an inner function
   --> app/routes/accounts/sync.py:102:13
    |
100 |             )
101 |             msg = "没有找到活跃的数据库实例"
102 |             raise AppValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
103 |
104 |         created_by = getattr(current_user, "id", None)
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/accounts/sync.py:107:13
    |
106 |         def _run_sync_task(captured_created_by: int | None) -> None:
107 |             from app.tasks.accounts_sync_tasks import sync_accounts
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
108 |
109 |             try:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/accounts/sync.py:111:20
    |
109 |             try:
110 |                 sync_accounts(manual_run=True, created_by=captured_created_by)
111 |             except Exception as exc:  # pragma: no cover - 后台线程日志
    |                    ^^^^^^^^^
112 |                 log_error(
113 |                     "后台批量账户同步失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/auth.py:310:5
    |
309 |     """
310 |     from flask_wtf.csrf import generate_csrf
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
311 |     return jsonify_unified_success(
312 |         data={"csrf_token": generate_csrf()},
    |

D205 1 blank line required between summary line and description
 --> app/routes/cache.py:2:1
  |
2 | / """鲸落 - 缓存管理路由
3 | | 提供缓存管理相关的API接口.
4 | | """
  | |___^
5 |
6 |   from flask import Blueprint, Response, request
  |
help: Insert single blank line

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/cache.py:9:39
   |
 7 | from flask_login import current_user, login_required
 8 |
 9 | from app.errors import NotFoundError, SystemError, ValidationError
   |                                       ^^^^^^^^^^^
10 | from app.models import Instance
11 | from app.services.account_classification.orchestrator import AccountClassificationService
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/cache.py:165:16
    |
163 |             if cache_manager.invalidate_instance_cache(instance.id):
164 |                 cleared_count += 1
165 |         except Exception as exc:
    |                ^^^^^^^^^
166 |             log_error(f"清除实例 {instance.id} 缓存失败: {exc}", module="cache")
    |

E501 Line too long (121 > 120)
   --> app/routes/cache.py:174:112
    |
172 |         operator_id=getattr(current_user, "id", None),
173 |     )
174 |     return jsonify_unified_success(message=f"已清除 {cleared_count} 个实例的缓存", data={"cleared_count": cleared_count})
    |                                                                                                                         ^
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/cache.py:281:16
    |
279 |                 "rules_count": len(rules_cache) if rules_cache else 0,
280 |             }
281 |         except Exception as exc:
    |                ^^^^^^^^^
282 |             log_error(f"获取数据库类型 {db_type} 缓存统计失败: {exc}", module="cache")
283 |             db_type_stats[db_type] = {
    |

C901 `aggregate_current` is too complex (28 > 10)
  --> app/routes/capacity/aggregations.py:58:5
   |
56 | @view_required
57 | @require_csrf
58 | def aggregate_current() -> Response:  # noqa: PLR0912, PLR0915
   |     ^^^^^^^^^^^^^^^^^
59 |     """手动触发当前周期数据聚合.
   |

D205 1 blank line required between summary line and description
 --> app/routes/capacity/databases.py:1:1
  |
1 | / """数据库统计 API 路由
2 | | 提供数据库大小监控、历史数据、统计聚合等接口
3 | | 专注于数据库层面的统计功能.
4 | | """
  | |___^
5 |
6 |   import contextlib
  |
help: Insert single blank line

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/capacity/databases.py:13:24
   |
12 | from app.constants import DATABASE_TYPES, PERIOD_TYPES
13 | from app.errors import SystemError, ValidationError
   |                        ^^^^^^^^^^^
14 | from app.models.instance_database import InstanceDatabase
15 | from app.services.database_type_service import DatabaseTypeService
   |

ANN201 Missing return type annotation for public function `list_databases`
  --> app/routes/capacity/databases.py:33:5
   |
31 | @login_required
32 | @view_required
33 | def list_databases():
   |     ^^^^^^^^^^^^^^
34 |     """数据库统计聚合页面(数据库统计层面).
   |
help: Add return type annotation

TRY301 Abstract `raise` to an inner function
   --> app/routes/capacity/databases.py:205:13
    |
203 |         if parsed_dt is None:
204 |             msg = "无法解析日期"
205 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^
206 |         return parsed_dt.date()
207 |     except Exception as exc:
    |

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/capacity/instances.py:12:39
   |
10 | from app.constants import DATABASE_TYPES, PERIOD_TYPES
11 | from app.constants.system_constants import SuccessMessages
12 | from app.errors import NotFoundError, SystemError, ValidationError as AppValidationError
   |                                       ^^^^^^^^^^^
13 | from app.models.instance import Instance
14 | from app.models.instance_size_stat import InstanceSizeStat
   |

DTZ007 Naive datetime constructed using `datetime.datetime.strptime()` without %z
  --> app/routes/capacity/instances.py:60:16
   |
58 |     """
59 |     try:
60 |         return datetime.strptime(value, "%Y-%m-%d").date()
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |     except ValueError as exc:
62 |         msg = f"{field_name} 格式错误,需使用 YYYY-MM-DD"
   |
help: Call `.replace(tzinfo=<timezone>)` or `.astimezone()` to convert to an aware datetime

ANN201 Missing return type annotation for public function `list_instances`
  --> app/routes/capacity/instances.py:70:5
   |
68 | @login_required
69 | @view_required
70 | def list_instances():
   |     ^^^^^^^^^^^^^^
71 |     """实例统计聚合页面.
   |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
  --> app/routes/capacity/instances.py:84:5
   |
82 |     end_date = request.args.get("end_date", "")
83 |
84 |     from app.services.database_type_service import DatabaseTypeService
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
85 |     database_type_configs = DatabaseTypeService.get_active_types()
86 |     if database_type_configs:
   |

C901 `fetch_instance_metrics` is too complex (11 > 10)
   --> app/routes/capacity/instances.py:122:5
    |
120 | @login_required
121 | @view_required
122 | def fetch_instance_metrics():
    |     ^^^^^^^^^^^^^^^^^^^^^^
123 |     """获取实例聚合数据(实例统计层面).
    |

PLR0915 Too many statements (56 > 50)
   --> app/routes/capacity/instances.py:122:5
    |
120 | @login_required
121 | @view_required
122 | def fetch_instance_metrics():
    |     ^^^^^^^^^^^^^^^^^^^^^^
123 |     """获取实例聚合数据(实例统计层面).
    |

ANN201 Missing return type annotation for public function `fetch_instance_metrics`
   --> app/routes/capacity/instances.py:122:5
    |
120 | @login_required
121 | @view_required
122 | def fetch_instance_metrics():
    |     ^^^^^^^^^^^^^^^^^^^^^^
123 |     """获取实例聚合数据(实例统计层面).
    |
help: Add return type annotation

ERA001 Found commented-out code
   --> app/routes/capacity/instances.py:159:9
    |
157 |         page = request.args.get("page", 1, type=int)
158 |         per_page = request.args.get("per_page", 20, type=int)
159 |         # 是否返回所有数据(用于图表显示)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
160 |         get_all = request.args.get("get_all", "false").lower() == "true"
    |
help: Remove commented-out code

PLC0415 `import` should be at the top-level of a file
   --> app/routes/capacity/instances.py:167:9
    |
166 |         # 构建查询 - 查询实例统计聚合表
167 |         from app.models.instance_size_aggregation import InstanceSizeAggregation
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
168 |         query = (
169 |             InstanceSizeAggregation.query.join(Instance)
    |

ERA001 Found commented-out code
   --> app/routes/capacity/instances.py:210:13
    |
208 |             total = len(aggregations)
209 |         else:
210 |             # 用于表格显示:按时间排序分页
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
211 |             query = query.order_by(desc(InstanceSizeAggregation.period_start))
212 |             total = query.count()
    |
help: Remove commented-out code

C901 `fetch_instance_summary` is too complex (13 > 10)
   --> app/routes/capacity/instances.py:253:5
    |
251 | @login_required
252 | @view_required
253 | def fetch_instance_summary():
    |     ^^^^^^^^^^^^^^^^^^^^^^
254 |     """获取实例聚合汇总信息(实例统计层面).
    |

ANN201 Missing return type annotation for public function `fetch_instance_summary`
   --> app/routes/capacity/instances.py:253:5
    |
251 | @login_required
252 | @view_required
253 | def fetch_instance_summary():
    |     ^^^^^^^^^^^^^^^^^^^^^^
254 |     """获取实例聚合汇总信息(实例统计层面).
    |
help: Add return type annotation

ERA001 Found commented-out code
   --> app/routes/capacity/instances.py:292:9
    |
290 |             end_date_obj = _parse_iso_date(end_date, "end_date")
291 |
292 |         # 优先使用实例大小统计表(与容量同步实时同步)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
293 |         stat_query = (
294 |             InstanceSizeStat.query.join(Instance)
    |
help: Remove commented-out code

D205 1 blank line required between summary line and description
 --> app/routes/common.py:1:1
  |
1 | / """通用 API 路由
2 | | 提供跨模块使用的通用接口.
3 | | """
  | |___^
4 |
5 |   from flask import Blueprint, Response, request
  |
help: Insert single blank line

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/common.py:9:24
   |
 7 | from sqlalchemy import func
 8 |
 9 | from app.errors import SystemError, ValidationError
   |                        ^^^^^^^^^^^
10 | from app.models.instance import Instance
11 | from app.models.instance_database import InstanceDatabase
   |

A004 Import `SystemError` is shadowing a Python builtin
 --> app/routes/connections.py:7:39
  |
5 | from flask_login import login_required
6 |
7 | from app.errors import NotFoundError, SystemError, ValidationError
  |                                       ^^^^^^^^^^^
8 | from app.models import Instance
9 | from app.services.connection_adapters.connection_factory import ConnectionFactory
  |

E501 Line too long (251 > 120)
  --> app/routes/connections.py:72:113
   |
70 | …
71 | …
72 | …ersion=result.get("database_version"), main_version=result.get("main_version"), detailed_version=result.get("detailed_version"))
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
73 | …
74 | …
   |

PLR2004 Magic value used in comparison, consider replacing `65535` with a constant variable
   --> app/routes/connections.py:108:28
    |
106 |         msg = "端口号必须是有效的数字"
107 |         raise ValidationError(msg) from exc
108 |     if port <= 0 or port > 65535:
    |                            ^^^^^
109 |         msg = "端口号必须在1-65535之间"
110 |         raise ValidationError(msg)
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/connections.py:111:5
    |
109 |         msg = "端口号必须在1-65535之间"
110 |         raise ValidationError(msg)
111 |     from app.models import Credential
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |     credential = Credential.query.get(connection_params.get("credential_id"))
113 |     if not credential:
    |

E501 Line too long (223 > 120)
   --> app/routes/connections.py:116:121
    |
114 | …
115 | …
116 | …tion_params.get("host"), port=port, credential_id=connection_params.get("credential_id"), description="临时测试连接")
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
117 | …
118 | …
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/connections.py:150:13
    |
148 |         if not ConnectionFactory.is_type_supported(db_type):
149 |             msg = f"不支持的数据库类型: {db_type}"
150 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
151 |         try:
152 |             port = int(data.get("port", 0))
    |

PLR2004 Magic value used in comparison, consider replacing `65535` with a constant variable
   --> app/routes/connections.py:156:32
    |
154 |             msg = "端口号必须是有效的数字"
155 |             raise ValidationError(msg) from exc
156 |         if port <= 0 or port > 65535:
    |                                ^^^^^
157 |             msg = "端口号必须在1-65535之间"
158 |             raise ValidationError(msg)
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/connections.py:158:13
    |
156 |         if port <= 0 or port > 65535:
157 |             msg = "端口号必须在1-65535之间"
158 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
159 |         if data.get("credential_id"):
160 |             from app.models import Credential
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/connections.py:160:13
    |
158 |             raise ValidationError(msg)
159 |         if data.get("credential_id"):
160 |             from app.models import Credential
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
161 |             credential = Credential.query.get(data.get("credential_id"))
162 |             if not credential:
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/connections.py:164:17
    |
162 |             if not credential:
163 |                 msg = "凭据不存在"
164 |                 raise NotFoundError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^
165 |         log_info("连接参数验证通过", module="connections", db_type=db_type)
166 |         return jsonify_unified_success(message="连接参数验证通过")
    |

PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   --> app/routes/connections.py:196:28
    |
194 |         msg = "实例ID列表不能为空"
195 |         raise ValidationError(msg)
196 |     if len(instance_ids) > 50:
    |                            ^^
197 |         msg = "批量测试数量不能超过50个"
198 |         raise ValidationError(msg)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/connections.py:219:20
    |
217 |                     fail_count += 1
218 |                 results.append(result)
219 |             except Exception as e:
    |                    ^^^^^^^^^
220 |                 results.append({"instance_id": instance_id, "success": False, "error": f"测试失败: {e!s}"})
221 |                 fail_count += 1
    |

E501 Line too long (125 > 120)
   --> app/routes/connections.py:223:113
    |
221 |                 fail_count += 1
222 |                 log_error("批量连接测试单实例失败", module="connections", instance_id=instance_id, error=str(e))
223 |         log_info("批量连接测试完成", module="connections", total=len(instance_ids), success=success_count, failed=fail_count)
    |                                                                                                                         ^^^^^
224 |         return jsonify_unified_success(data={"results": results, "summary": {"total": len(instance_ids), "success": success_count, "f…
225 |     except Exception as exc:
    |

E501 Line too long (182 > 120)
   --> app/routes/connections.py:224:121
    |
222 | …d, error=str(e))
223 | …uccess_count, failed=fail_count)
224 | … len(instance_ids), "success": success_count, "failed": fail_count}}, message="批量连接测试完成")
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
225 | …
226 | …
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/connections.py:257:13
    |
255 |         status = "unknown"
256 |         if instance.last_connected:
257 |             from datetime import datetime, timedelta
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
258 |             last_connected_time = instance.last_connected
259 |             if isinstance(last_connected_time, str):
    |

E501 Line too long (293 > 120)
   --> app/routes/connections.py:268:121
    |
266 | …
267 | …
268 | … instance.db_type, "host": instance.host, "port": instance.port, "last_connected": last_connected, "status": status, "is_active": instance.is_active}, message="获取连接状态成功")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
269 | …
270 | …
    |

C901 `index` is too complex (12 > 10)
   --> app/routes/credentials.py:151:5
    |
149 | @login_required
150 | @view_required
151 | def index() -> str:
    |     ^^^^^
152 |     """凭据管理首页.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/credentials.py:212:9
    |
210 |     # 标签筛选
211 |     if tags:
212 |         from app.models.tag import Tag
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
213 |         query = query.join(Credential.tags).filter(Tag.name.in_(tags))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/credentials.py:379:16
    |
377 |             db.session.delete(credential)
378 |             db.session.commit()
379 |         except Exception as exc:
    |                ^^^^^^^^^
380 |             _handle_db_exception("删除凭据", exc)
381 |     except DatabaseError as exc:
    |

C901 `list_credentials` is too complex (11 > 10)
   --> app/routes/credentials.py:410:5
    |
408 | @login_required
409 | @view_required
410 | def list_credentials() -> "Response":
    |     ^^^^^^^^^^^^^^^^
411 |     """获取凭据列表 API.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/credentials.py:470:9
    |
469 |     if tag_params:
470 |         from app.models.tag import Tag
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
471 |         query = query.join(Credential.tags).filter(Tag.name.in_(tag_params))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:219:12
    |
217 |             },
218 |         }
219 |     except Exception as exc:
    |            ^^^^^^^^^
220 |         db.session.rollback()
221 |         log_error("获取系统概览失败", module="dashboard", error=str(exc))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:262:12
    |
260 |             charts["sync_trend"] = get_sync_trend_data()
261 |
262 |     except Exception as exc:
    |            ^^^^^^^^^
263 |         log_error("获取图表数据失败", module="dashboard", error=str(exc))
264 |         charts = {}
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:312:12
    |
311 |         return [{"status": status, "count": count} for status, count in status_count.items()]
312 |     except Exception as exc:
    |            ^^^^^^^^^
313 |         log_error("获取任务状态分布失败", module="dashboard", error=str(exc))
314 |         return []
    |

SLF001 Private member accessed: `_mapping`
   --> app/routes/dashboard.py:382:26
    |
380 |             .one_or_none()
381 |         )
382 |         result_mapping = result._mapping if result is not None else {}
    |                          ^^^^^^^^^^^^^^^
383 |
384 |         for start_dt, label in labels:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:391:12
    |
389 |                 },
390 |             )
391 |     except Exception as exc:
    |            ^^^^^^^^^
392 |         log_error("获取同步趋势数据失败", module="dashboard", error=str(exc))
393 |         trend_data = []
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:442:12
    |
440 |             "uptime": get_system_uptime(),
441 |         }
442 |     except Exception as exc:
    |            ^^^^^^^^^
443 |         log_error("获取系统状态失败", module="dashboard", error=str(exc))
444 |         return {
    |

D104 Missing docstring in public package
--> app/routes/databases/__init__.py:1:1

D205 1 blank line required between summary line and description
 --> app/routes/databases/capacity_sync.py:1:1
  |
1 | / """数据库域:容量同步 API 路由
2 | | 专注于数据同步功能,不包含统计功能.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/databases/capacity_sync.py:11:39
   |
 9 | from flask import Blueprint, Response
10 |
11 | from app.errors import NotFoundError, SystemError
   |                                       ^^^^^^^^^^^
12 | from app.models.instance import Instance
13 | from app.services.aggregation.aggregation_service import AggregationService
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/routes/databases/capacity_sync.py:74:16
   |
72 |         try:
73 |             inventory_result = collector.synchronize_database_inventory()
74 |         except Exception as inventory_error:
   |                ^^^^^^^^^
75 |             log_error(
76 |                 "同步数据库列表失败",
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/databases/capacity_sync.py:115:16
    |
113 |         try:
114 |             saved_count = collector.save_collected_data(databases_data)
115 |         except Exception as exc:
    |                ^^^^^^^^^
116 |             log_error(
117 |                 "保存数据库容量数据失败",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/databases/capacity_sync.py:136:16
    |
134 |             aggregation_service.calculate_daily_database_aggregations_for_instance(instance.id)
135 |             aggregation_service.calculate_daily_aggregations_for_instance(instance.id)
136 |         except Exception as exc:
    |                ^^^^^^^^^
137 |             log_warning(
138 |                 "容量聚合刷新失败",
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/databases/capacity_sync.py:218:9
    |
216 |         )
217 |         error_message = result.get("message") or result.get("error") or "实例容量同步失败"
218 |         raise SystemError(error_message)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |
220 |     except NotFoundError:
    |

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/databases/ledgers.py:14:39
   |
13 | from app.constants import DATABASE_TYPES
14 | from app.errors import NotFoundError, SystemError
   |                                       ^^^^^^^^^^^
15 | from app.services.ledgers.database_ledger_service import DatabaseLedgerService
16 | from app.utils.decorators import view_required
   |

D205 1 blank line required between summary line and description
 --> app/routes/files.py:1:1
  |
1 | / """文件导入导出路由
2 | | 统一处理全局的导出/上传相关接口.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/files.py:23:24
   |
21 |     INSTANCE_IMPORT_TEMPLATE_SAMPLE,
22 | )
23 | from app.errors import SystemError, ValidationError
   |                        ^^^^^^^^^^^
24 | from app.models.account_permission import AccountPermission
25 | from app.models.instance import Instance
   |

C901 `export_accounts` is too complex (17 > 10)
  --> app/routes/files.py:39:5
   |
37 | @login_required
38 | @view_required
39 | def export_accounts() -> Response:
   |     ^^^^^^^^^^^^^^^
40 |     """导出账户数据为 CSV.
   |

PLR0912 Too many branches (18 > 12)
  --> app/routes/files.py:39:5
   |
37 | @login_required
38 | @view_required
39 | def export_accounts() -> Response:
   |     ^^^^^^^^^^^^^^^
40 |     """导出账户数据为 CSV.
   |

PLR0915 Too many statements (64 > 50)
  --> app/routes/files.py:39:5
   |
37 | @login_required
38 | @view_required
39 | def export_accounts() -> Response:
   |     ^^^^^^^^^^^^^^^
40 |     """导出账户数据为 CSV.
   |

ERA001 Found commented-out code
  --> app/routes/files.py:60:9
   |
58 |     """
59 |     try:
60 |         # 获取查询参数(与列表页保持一致)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |         db_type = request.args.get("db_type", type=str)
62 |         search = request.args.get("search", "").strip()
   |
help: Remove commented-out code

PLC0415 `import` should be at the top-level of a file
  --> app/routes/files.py:68:9
   |
66 |         tags = [tag for tag in request.args.getlist("tags") if tag.strip()]
67 |
68 |         from app.models.instance_account import InstanceAccount
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 |
70 |         # 构建查询
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/files.py:102:20
    |
100 |             try:
101 |                 query = query.join(Instance).join(Instance.tags).filter(Tag.name.in_(tags))
102 |             except Exception as exc:
    |                    ^^^^^^^^^
103 |                 log_error(
104 |                     "导出账户时标签过滤失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/files.py:112:9
    |
110 |         accounts = query.all()
111 |
112 |         from app.models.account_classification import AccountClassificationAssignment
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
113 |
114 |         classifications: dict[int, list[str]] = {}
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/files.py:284:5
    |
282 | def export_database_ledger() -> Response:
283 |     """导出数据库台账列表为 CSV."""
284 |     from app.services.ledgers.database_ledger_service import DatabaseLedgerService
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
285 |
286 |     try:
    |

E501 Line too long (121 > 120)
   --> app/routes/files.py:300:89
    |
298 |         output = io.StringIO()
299 |         writer = csv.writer(output)
300 |         writer.writerow(["数据库名称", "实例名称", "主机", "数据库类型", "标签", "最新容量", "最后采集时间", "同步状态"])
    |                                                                                                                         ^
301 |
302 |         for row in rows:
    |

C901 `export_logs` is too complex (16 > 10)
   --> app/routes/files.py:343:5
    |
341 | @files_bp.route("/api/log-export", methods=["GET"])
342 | @login_required
343 | def export_logs() -> Response:
    |     ^^^^^^^^^^^
344 |     """导出日志 API.
    |

PLR0912 Too many branches (15 > 12)
   --> app/routes/files.py:343:5
    |
341 | @files_bp.route("/api/log-export", methods=["GET"])
342 | @login_required
343 | def export_logs() -> Response:
    |     ^^^^^^^^^^^
344 |     """导出日志 API.
    |

PLR0915 Too many statements (61 > 50)
   --> app/routes/files.py:343:5
    |
341 | @files_bp.route("/api/log-export", methods=["GET"])
342 | @login_required
343 | def export_logs() -> Response:
    |     ^^^^^^^^^^^
344 |     """导出日志 API.
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/files.py:407:17
    |
405 |               logs_data: list[dict[str, Any]] = []
406 |               for log in logs:
407 | /                 logs_data.append(
408 | |                     {
409 | |                         "id": log.id,
410 | |                         "timestamp": log.timestamp.isoformat() if log.timestamp else None,
411 | |                         "level": log.level.value if log.level else None,
412 | |                         "module": log.module,
413 | |                         "message": log.message,
414 | |                         "traceback": log.traceback,
415 | |                         "context": log.context,
416 | |                         "created_at": log.created_at.isoformat() if log.created_at else None,
417 | |                     },
418 | |                 )
    | |_________________^
419 |
420 |               payload = {"logs": logs_data, "exported_at": time_utils.now().isoformat()}
    |
help: Replace for loop with list comprehension

TRY301 Abstract `raise` to an inner function
   --> app/routes/files.py:475:9
    |
474 |         msg = "不支持的导出格式"
475 |         raise ValidationError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
476 |
477 |     except Exception as exc:
    |

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/health.py:13:24
   |
11 | from app.constants import TimeConstants
12 | from app.constants.system_constants import SuccessMessages
13 | from app.errors import SystemError
   |                        ^^^^^^^^^^^
14 | from app.services.cache_service import cache_manager
15 | from app.utils.response_utils import jsonify_unified_success
   |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/health.py:125:9
    |
123 |     db_status = "connected"
124 |     try:
125 |         from sqlalchemy import text
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
126 |
127 |         db.session.execute(text("SELECT 1"))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:128:12
    |
127 |         db.session.execute(text("SELECT 1"))
128 |     except Exception:
    |            ^^^^^^^^^
129 |         db_status = "error"
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:135:12
    |
133 |     try:
134 |         redis_status = "connected" if cache_manager and cache_manager.health_check() else "error"
135 |     except Exception:
    |            ^^^^^^^^^
136 |         redis_status = "error"
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/health.py:198:9
    |
196 |     try:
197 |         start_time = time.time()
198 |         from sqlalchemy import text
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
199 |         db.session.execute(text("SELECT 1"))
200 |         response_time = (time.time() - start_time) * 1000  # 毫秒
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:207:12
    |
205 |             "status": "connected",
206 |         }
207 |     except Exception as exc:
    |            ^^^^^^^^^
208 |         log_error("数据库健康检查失败", module="health", error=str(exc))
209 |         return {"healthy": False, "error": str(exc), "status": "disconnected"}
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:234:12
    |
232 |             "status": "connected" if result == "ok" else "error",
233 |         }
234 |     except Exception as exc:
    |            ^^^^^^^^^
235 |         log_error("缓存健康检查失败", module="health", error=str(exc))
236 |         return {"healthy": False, "error": str(exc), "status": "disconnected"}
    |

PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
   --> app/routes/health.py:269:31
    |
267 |         healthy = all(
268 |             [
269 |                 cpu_percent < 90,  # CPU使用率低于90%
    |                               ^^
270 |                 memory_percent < 90,  # 内存使用率低于90%
271 |                 disk_percent < 90,  # 磁盘使用率低于90%
    |

PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
   --> app/routes/health.py:270:34
    |
268 |             [
269 |                 cpu_percent < 90,  # CPU使用率低于90%
270 |                 memory_percent < 90,  # 内存使用率低于90%
    |                                  ^^
271 |                 disk_percent < 90,  # 磁盘使用率低于90%
272 |             ],
    |

PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
   --> app/routes/health.py:271:32
    |
269 |                 cpu_percent < 90,  # CPU使用率低于90%
270 |                 memory_percent < 90,  # 内存使用率低于90%
271 |                 disk_percent < 90,  # 磁盘使用率低于90%
    |                                ^^
272 |             ],
273 |         )
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:282:12
    |
280 |             "status": "healthy" if healthy else "warning",
281 |         }
282 |     except Exception as exc:
    |            ^^^^^^^^^
283 |         log_error("系统健康检查失败", module="health", error=str(exc))
284 |         return {"healthy": False, "error": str(exc), "status": "error"}
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/health.py:296:9
    |
294 |     """
295 |     try:
296 |         from app import app_start_time
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
297 |
298 |         current_time = time_utils.now_china()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/routes/health.py:305:9
    |
303 |         minutes, _ = divmod(remainder, 60)
304 |
305 |         return f"{days}天 {hours}小时 {minutes}分钟"
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
306 |     except Exception:
307 |         return "未知"
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:306:12
    |
305 |         return f"{days}天 {hours}小时 {minutes}分钟"
306 |     except Exception:
    |            ^^^^^^^^^
307 |         return "未知"
    |

D104 Missing docstring in public package
--> app/routes/history/__init__.py:1:1

D205 1 blank line required between summary line and description
 --> app/routes/history/logs.py:2:1
  |
2 | / """鲸落 - 统一日志系统API路由
3 | | 提供日志查询、展示和管理的RESTful API.
4 | | """
  | |___^
5 |
6 |   from datetime import datetime, timedelta
  |
help: Insert single blank line

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/history/logs.py:14:24
   |
12 | from app import db
13 | from app.constants import LOG_LEVELS, TIME_RANGES
14 | from app.errors import SystemError, ValidationError
   |                        ^^^^^^^^^^^
15 | from app.models.unified_log import LogLevel, UnifiedLog
16 | from app.utils.query_filter_utils import get_log_modules as load_log_modules
   |

C901 `search_logs` is too complex (17 > 10)
   --> app/routes/history/logs.py:102:5
    |
100 | @logs_bp.route("/api/search", methods=["GET"])
101 | @login_required
102 | def search_logs() -> Response:
    |     ^^^^^^^^^^^
103 |     """搜索日志 API.
    |

PLR0912 Too many branches (17 > 12)
   --> app/routes/history/logs.py:102:5
    |
100 | @logs_bp.route("/api/search", methods=["GET"])
101 | @login_required
102 | def search_logs() -> Response:
    |     ^^^^^^^^^^^
103 |     """搜索日志 API.
    |

PLR0915 Too many statements (67 > 50)
   --> app/routes/history/logs.py:102:5
    |
100 | @logs_bp.route("/api/search", methods=["GET"])
101 | @login_required
102 | def search_logs() -> Response:
    |     ^^^^^^^^^^^
103 |     """搜索日志 API.
    |

ERA001 Found commented-out code
   --> app/routes/history/logs.py:169:13
    |
167 |                 raise ValidationError(msg) from exc
168 |         elif not start_time and not end_time and not hours:
169 |             # 默认时间范围:最近24小时
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^
170 |             default_start = time_utils.now() - timedelta(hours=24)
171 |             query = query.filter(UnifiedLog.timestamp >= default_start)
    |
help: Remove commented-out code

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/history/logs.py:212:13
    |
210 |         logs = []
211 |         for log_entry in pagination.items:
212 |             logs.append(log_entry.to_dict())
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
213 |
214 |         response_data = {
    |
help: Replace for loop with list comprehension

C901 `list_logs` is too complex (11 > 10)
   --> app/routes/history/logs.py:239:5
    |
237 | @logs_bp.route("/api/list", methods=["GET"])
238 | @login_required
239 | def list_logs() -> Response:
    |     ^^^^^^^^^
240 |     """Grid.js 日志列表 API.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/history/logs.py:396:9
    |
394 |     """
395 |     try:
396 |         from sqlalchemy import distinct
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
397 |
398 |         # 获取所有模块
    |

C901 `get_log_stats` is too complex (11 > 10)
   --> app/routes/history/logs.py:414:5
    |
412 | @logs_bp.route("/api/stats", methods=["GET"])
413 | @login_required
414 | def get_log_stats() -> tuple[dict, int]:
    |     ^^^^^^^^^^^^^
415 |     """获取日志统计 API(兼容旧前端).
    |

ERA001 Found commented-out code
   --> app/routes/history/logs.py:465:9
    |
463 |         total_logs = query.count()
464 |
465 |         # 错误日志数(包含ERROR和CRITICAL级别)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
466 |         error_query = query.filter(UnifiedLog.level.in_([LogLevel.ERROR, LogLevel.CRITICAL]))
467 |         error_logs = error_query.count()
    |
help: Remove commented-out code

PLC0415 `import` should be at the top-level of a file
   --> app/routes/history/logs.py:474:9
    |
473 |         # 活跃模块数
474 |         from sqlalchemy import distinct
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
475 |         modules_query = db.session.query(distinct(UnifiedLog.module))
    |

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/history/sessions.py:8:39
   |
 7 | from app.constants import STATUS_SYNC_OPTIONS, SYNC_CATEGORIES, SYNC_TYPES, SyncStatus
 8 | from app.errors import NotFoundError, SystemError
   |                                       ^^^^^^^^^^^
 9 | from app.services.sync_session_service import sync_session_service
10 | from app.utils.decorators import require_csrf, view_required
   |

TRY301 Abstract `raise` to an inner function
   --> app/routes/history/sessions.py:149:13
    |
147 |         if not session:
148 |             msg = "会话不存在"
149 |             raise NotFoundError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
150 |
151 |         # 获取实例记录
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/history/sessions.py:208:9
    |
206 |             return jsonify_unified_success(message="会话已取消")
207 |         msg = "取消会话失败,会话不存在或已结束"
208 |         raise NotFoundError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
209 |
210 |     except Exception as e:
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/history/sessions.py:245:13
    |
243 |         if not session:
244 |             msg = "会话不存在"
245 |             raise NotFoundError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
246 |
247 |         # 获取所有实例记录
    |

INP001 File `app/routes/instances/batch.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/instances/batch.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/instances/batch.py:19:24
   |
17 | )
18 | from app.constants.system_constants import ErrorCategory
19 | from app.errors import SystemError, ValidationError
   |                        ^^^^^^^^^^^
20 | from app.services.instances import InstanceBatchCreationService, InstanceBatchDeletionService
21 | from app.utils.decorators import create_required, delete_required, require_csrf
   |

TRY301 Abstract `raise` to an inner function
   --> app/routes/instances/batch.py:127:13
    |
125 |         if not uploaded_file or not uploaded_file.filename.endswith(".csv"):
126 |             msg = "请上传CSV格式文件"
127 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
128 |
129 |         return _process_csv_file(uploaded_file)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `file_obj`
   --> app/routes/instances/batch.py:145:33
    |
145 | def _process_csv_file(file_obj: Any) -> Response:
    |                                 ^^^
146 |     """解析 CSV 文件并触发批量创建.
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/instances/batch.py:171:13
    |
169 |         if not instances_data:
170 |             msg = "CSV文件为空或未包含有效数据"
171 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
172 |
173 |         return _create_instances(instances_data)
    |

INP001 File `app/routes/instances/detail.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/instances/detail.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/instances/detail.py:13:39
   |
11 | from app import db
12 | from app.constants.database_types import DatabaseType
13 | from app.errors import ConflictError, SystemError, ValidationError
   |                                       ^^^^^^^^^^^
14 | from app.models.account_permission import AccountPermission
15 | from app.models.credential import Credential
   |

PLR0911 Too many return statements (7 > 6)
  --> app/routes/instances/detail.py:34:5
   |
34 | def _parse_is_active_value(data: Any, default: bool = False) -> bool:
   |     ^^^^^^^^^^^^^^^^^^^^^^
35 |     """从请求数据中解析 is_active,兼容表单/JSON/checkbox.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `data`
  --> app/routes/instances/detail.py:34:34
   |
34 | def _parse_is_active_value(data: Any, default: bool = False) -> bool:
   |                                  ^^^
35 |     """从请求数据中解析 is_active,兼容表单/JSON/checkbox.
   |

FBT001 Boolean-typed positional argument in function definition
  --> app/routes/instances/detail.py:34:39
   |
34 | def _parse_is_active_value(data: Any, default: bool = False) -> bool:
   |                                       ^^^^^^^
35 |     """从请求数据中解析 is_active,兼容表单/JSON/checkbox.
   |

FBT002 Boolean default positional argument in function definition
  --> app/routes/instances/detail.py:34:39
   |
34 | def _parse_is_active_value(data: Any, default: bool = False) -> bool:
   |                                       ^^^^^^^
35 |     """从请求数据中解析 is_active,兼容表单/JSON/checkbox.
   |

SIM108 Use ternary operator `value = None if not values else values[-1]` instead of `if`-`else`-block
  --> app/routes/instances/detail.py:48:9
   |
46 |       if hasattr(data, "getlist"):
47 |           values = data.getlist("is_active")
48 | /         if not values:
49 | |             value = None
50 | |         else:
51 | |             value = values[-1]  # 取最后一个值(checkbox优先于隐藏域)
   | |______________________________^
52 |       else:
53 |           value = data.get("is_active", default)
   |
help: Replace `if`-`else`-block with `value = None if not values else values[-1]`

B018 Found useless expression. Either assign it to a variable or remove it.
   --> app/routes/instances/detail.py:99:5
    |
 98 |     # 确保标签关系被加载
 99 |     instance.tags  # 触发标签关系的加载
    |     ^^^^^^^^^^^^^
100 |
101 |     # 获取查询参数
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/instances/detail.py:184:5
    |
182 |     instance = Instance.query.get_or_404(instance_id)
183 |
184 |     from app.models.account_permission import AccountPermission
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
185 |
186 |     account = AccountPermission.query.filter_by(id=account_id, instance_id=instance_id).first_or_404()
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/instances/detail.py:189:9
    |
188 |     try:
189 |         from app.models.account_change_log import AccountChangeLog
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
190 |
191 |         change_logs = (
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/instances/detail.py:204:13
    |
202 |           history = []
203 |           for log in change_logs:
204 | /             history.append(
205 | |                 {
206 | |                     "id": log.id,
207 | |                     "change_type": log.change_type,
208 | |                     "change_time": (time_utils.format_china_time(log.change_time) if log.change_time else "未知"),
209 | |                     "status": log.status,
210 | |                     "message": log.message,
211 | |                     "privilege_diff": log.privilege_diff,
212 | |                     "other_diff": log.other_diff,
213 | |                     "session_id": log.session_id,
214 | |                 },
215 | |             )
    | |_____________^
216 |
217 |           return jsonify_unified_success(
    |
help: Replace for loop with list comprehension

ERA001 Found commented-out code
   --> app/routes/instances/detail.py:271:5
    |
269 |         raise ValidationError(validation_error)
270 |
271 |     # 验证凭据ID(如果提供)
    |     ^^^^^^^^^^^^^^^^^^^^^^
272 |     if data.get("credential_id"):
273 |         try:
    |
help: Remove commented-out code

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app/routes/instances/detail.py:281:13
    |
279 |         except (ValueError, TypeError):
280 |             msg = "无效的凭据ID"
281 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
282 |
283 |     # 验证实例名称唯一性(排除当前实例)
    |

ERA001 Found commented-out code
   --> app/routes/instances/detail.py:283:5
    |
281 |             raise ValidationError(msg)
282 |
283 |     # 验证实例名称唯一性(排除当前实例)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
284 |     existing_instance = Instance.query.filter(
285 |         Instance.name == data.get("name"), Instance.id != instance_id,
    |
help: Remove commented-out code

ANN202 Missing return type annotation for private function `_build_capacity_query`
   --> app/routes/instances/detail.py:497:5
    |
495 |         message="获取账户权限详情成功",
496 |     )
497 | def _build_capacity_query(
    |     ^^^^^^^^^^^^^^^^^^^^^
498 |     instance_id: int,
499 |     database_name: str | None,
    |
help: Add return type annotation

FBT001 Boolean-typed positional argument in function definition
   --> app/routes/instances/detail.py:542:28
    |
542 | def _normalize_active_flag(flag: bool | None) -> bool:
    |                            ^^^^
543 |     """将可能为空的激活标记标准化为 bool.
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/routes/instances/detail.py:559:5
    |
557 | def _serialize_capacity_entry(
558 |     stat: DatabaseSizeStat,
559 |     is_active: bool,
    |     ^^^^^^^^^
560 |     deleted_at: datetime | None,
561 |     last_seen_date: date | None,
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> app/routes/instances/detail.py:589:5
    |
589 | def _fetch_latest_database_sizes(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
590 |     instance_id: int,
591 |     database_name: str | None,
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/routes/instances/detail.py:594:5
    |
592 |     start_date: date | None,
593 |     end_date: date | None,
594 |     include_inactive: bool,
    |     ^^^^^^^^^^^^^^^^
595 |     limit: int,
596 |     offset: int,
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> app/routes/instances/detail.py:684:5
    |
684 | def _fetch_historical_database_sizes(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
685 |     instance_id: int,
686 |     database_name: str | None,
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/routes/instances/detail.py:689:5
    |
687 |     start_date: date | None,
688 |     end_date: date | None,
689 |     include_inactive: bool,
    |     ^^^^^^^^^^^^^^^^
690 |     limit: int,
691 |     offset: int,
    |

INP001 File `app/routes/instances/manage.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/instances/manage.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/instances/manage.py:17:39
   |
15 |     SyncStatus,
16 | )
17 | from app.errors import ConflictError, SystemError, ValidationError
   |                                       ^^^^^^^^^^^
18 | from app.models.credential import Credential
19 | from app.models.instance import Instance
   |

PLC0415 `import` should be at the top-level of a file
  --> app/routes/instances/manage.py:65:5
   |
64 |     # 获取数据库类型配置
65 |     from app.services.database_type_service import DatabaseTypeService
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |
67 |     database_type_configs = DatabaseTypeService.get_active_types()
   |

ERA001 Found commented-out code
   --> app/routes/instances/manage.py:132:5
    |
130 |         raise ValidationError(validation_error)
131 |
132 |     # 验证凭据ID(如果提供)
    |     ^^^^^^^^^^^^^^^^^^^^^^
133 |     if data.get("credential_id"):
134 |         try:
    |
help: Remove commented-out code

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app/routes/instances/manage.py:142:13
    |
140 |         except (ValueError, TypeError):
141 |             msg = "无效的凭据ID"
142 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
143 |
144 |     # 验证实例名称唯一性
    |

C901 `list_instances_data` is too complex (13 > 10)
   --> app/routes/instances/manage.py:256:5
    |
254 | @login_required
255 | @view_required
256 | def list_instances_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^^
257 |     """Grid.js 实例列表 API.
    |

PLR0915 Too many statements (53 > 50)
   --> app/routes/instances/manage.py:256:5
    |
254 | @login_required
255 | @view_required
256 | def list_instances_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^^
257 |     """Grid.js 实例列表 API.
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/instances/manage.py:405:13
    |
403 |           items = []
404 |           for instance in pagination.items:
405 | /             items.append(
406 | |                 {
407 | |                     "id": instance.id,
408 | |                     "name": instance.name,
409 | |                     "db_type": instance.db_type,
410 | |                     "host": instance.host,
411 | |                     "port": instance.port,
412 | |                     "description": instance.description or "",
413 | |                     "is_active": instance.is_active,
414 | |                     "main_version": instance.main_version,
415 | |                     "active_db_count": active_database_counts.get(instance.id, 0),
416 | |                     "active_account_count": active_account_counts.get(instance.id, 0),
417 | |                     "last_sync_time": (
418 | |                         last_sync_times.get(instance.id).isoformat()
419 | |                         if last_sync_times.get(instance.id)
420 | |                         else None
421 | |                     ),
422 | |                     "tags": tags_map.get(instance.id, []),
423 | |                 },
424 | |             )
    | |_____________^
425 |
426 |           return jsonify_unified_success(
    |
help: Replace for loop with list comprehension

C901 `list_instance_accounts` is too complex (11 > 10)
   --> app/routes/instances/manage.py:467:5
    |
465 | @login_required
466 | @view_required
467 | def list_instance_accounts(instance_id: int) -> Response:
    |     ^^^^^^^^^^^^^^^^^^^^^^
468 |     """获取实例账户数据 API.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/instances/manage.py:544:5
    |
544 |     from app.models.account_permission import AccountPermission
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
545 |
546 |     account = AccountPermission.query.filter_by(id=account_id, instance_id=instance_id).first_or_404()
    |

F821 Undefined name `account_id`
   --> app/routes/instances/manage.py:546:52
    |
544 |     from app.models.account_permission import AccountPermission
545 |
546 |     account = AccountPermission.query.filter_by(id=account_id, instance_id=instance_id).first_or_404()
    |                                                    ^^^^^^^^^^
547 |
548 |     try:
    |

ERA001 Found commented-out code
   --> app/routes/instances/manage.py:549:9
    |
548 |     try:
549 |         # 构建权限信息(与账户管理页面保持一致的数据结构)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
550 |         permissions = {
551 |             "db_type": instance.db_type.upper() if instance else "",
    |
help: Remove commented-out code

F821 Undefined name `account_id`
   --> app/routes/instances/manage.py:598:24
    |
596 |             module="instances",
597 |             instance_id=instance_id,
598 |             account_id=account_id,
    |                        ^^^^^^^^^^
599 |             exception=exc,
600 |         )
    |

E402 Module level import not at top of file
   --> app/routes/instances/manage.py:606:1
    |
605 |   # 注册额外路由模块
606 | / from . import (
607 | |     detail,  # noqa: F401
608 | |     statistics,  # noqa: F401
609 | | )
    | |_^
    |

INP001 File `app/routes/instances/statistics.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/instances/statistics.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
 --> app/routes/instances/statistics.py:7:24
  |
6 | from app.constants import FlashCategory
7 | from app.errors import SystemError
  |                        ^^^^^^^^^^^
8 | from app.routes.instances.manage import instances_bp
9 | from app.services.statistics.instance_statistics_service import (
  |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> app/routes/main.py:70:17
   |
68 |     """
69 |     icon_name = "apple-touch-icon-precomposed.png" if "precomposed" in request.path else "apple-touch-icon.png"
70 |     icon_path = os.path.join(current_app.static_folder, "img")
   |                 ^^^^^^^^^^^^
71 |     return send_from_directory(icon_path, icon_name)
   |

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/partition.py:9:24
   |
 7 | from flask_login import current_user, login_required
 8 |
 9 | from app.errors import SystemError, ValidationError
   |                        ^^^^^^^^^^^
10 | from app.models.database_size_aggregation import DatabaseSizeAggregation
11 | from app.models.database_size_stat import DatabaseSizeStat
   |

ANN201 Missing return type annotation for public function `partitions_page`
  --> app/routes/partition.py:28:5
   |
26 | @login_required
27 | @view_required
28 | def partitions_page():
   |     ^^^^^^^^^^^^^^^
29 |     """分区管理页面.
   |
help: Add return type annotation

DTZ011 `datetime.date.today()` used
   --> app/routes/partition.py:105:20
    |
103 |     partitions = info.get("partitions", [])
104 |
105 |     current_date = date.today()
    |                    ^^^^^^^^^^^^
106 |     required_partitions: list[str] = []
107 |     for offset in range(3):
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

C901 `get_core_aggregation_metrics` is too complex (40 > 10)
   --> app/routes/partition.py:378:5
    |
376 | @login_required
377 | @view_required
378 | def get_core_aggregation_metrics() -> Response:  # noqa: PLR0912, PLR0915
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
379 |     """获取核心聚合指标数据.
    |

ERA001 Found commented-out code
   --> app/routes/partition.py:511:21
    |
510 |                 if period_type == "weekly":
511 |                     # 计算周的开始日期(周一)
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^
512 |                     week_start = period_start - timedelta(days=period_start.weekday())
513 |                     period_key = week_start.isoformat()
    |
help: Remove commented-out code

E501 Line too long (129 > 120)
   --> app/routes/partition.py:540:121
    |
538 |             for period_key, metrics in period_metrics.items():
539 |                 if metrics["days_in_period"] > 0:
540 |                     daily_metrics[period_key]["instance_count"] = round(metrics["instance_count"] / metrics["days_in_period"], 1)
    |                                                                                                                         ^^^^^^^^^
541 |                     daily_metrics[period_key]["database_count"] = round(metrics["database_count"] / metrics["days_in_period"], 1)
542 |                     daily_metrics[period_key]["instance_aggregation_count"] = metrics["instance_aggregation_count"]
    |

E501 Line too long (129 > 120)
   --> app/routes/partition.py:541:121
    |
539 |                 if metrics["days_in_period"] > 0:
540 |                     daily_metrics[period_key]["instance_count"] = round(metrics["instance_count"] / metrics["days_in_period"], 1)
541 |                     daily_metrics[period_key]["database_count"] = round(metrics["database_count"] / metrics["days_in_period"], 1)
    |                                                                                                                         ^^^^^^^^^
542 |                     daily_metrics[period_key]["instance_aggregation_count"] = metrics["instance_aggregation_count"]
543 |                     daily_metrics[period_key]["database_aggregation_count"] = metrics["database_aggregation_count"]
    |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:8:55
   |
 7 | from flask import Blueprint, Response, render_template
 8 | from flask_login import current_user, login_required  # type: ignore
   |                                                       ^^^^^^^^^^^^^^
 9 |
10 | from app.constants.scheduler_jobs import BUILTIN_TASK_IDS
   |

A004 Import `SystemError` is shadowing a Python builtin
  --> app/routes/scheduler.py:12:39
   |
10 | from app.constants.scheduler_jobs import BUILTIN_TASK_IDS
11 | from app.constants.sync_constants import SyncCategory, SyncOperationType
12 | from app.errors import NotFoundError, SystemError
   |                                       ^^^^^^^^^^^
13 | from app.scheduler import get_scheduler
14 | from app.services.sync_session_service import sync_session_service
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:45:95
   |
44 | _scheduler_forms = SchedulerJobFormView.as_view("scheduler_forms")
45 | _scheduler_forms = login_required(scheduler_manage_required(require_csrf(_scheduler_forms)))  # type: ignore
   |                                                                                               ^^^^^^^^^^^^^^
46 | scheduler_bp.add_url_rule(
47 |     "/api/jobs/<job_id>",
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:54:18
   |
53 | @scheduler_bp.route("/")
54 | @login_required  # type: ignore
   |                  ^^^^^^^^^^^^^^
55 | @scheduler_view_required  # type: ignore
56 | def index() -> str:
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:55:27
   |
53 | @scheduler_bp.route("/")
54 | @login_required  # type: ignore
55 | @scheduler_view_required  # type: ignore
   |                           ^^^^^^^^^^^^^^
56 | def index() -> str:
57 |     """定时任务管理页面.
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:69:18
   |
68 | @scheduler_bp.route("/api/jobs")
69 | @login_required  # type: ignore
   |                  ^^^^^^^^^^^^^^
70 | @scheduler_view_required  # type: ignore
71 | def get_jobs() -> Response:
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:70:27
   |
68 | @scheduler_bp.route("/api/jobs")
69 | @login_required  # type: ignore
70 | @scheduler_view_required  # type: ignore
   |                           ^^^^^^^^^^^^^^
71 | def get_jobs() -> Response:
72 |     """获取所有定时任务.
   |

C901 `get_jobs` is too complex (31 > 10)
  --> app/routes/scheduler.py:71:5
   |
69 | @login_required  # type: ignore
70 | @scheduler_view_required  # type: ignore
71 | def get_jobs() -> Response:
   |     ^^^^^^^^
72 |     """获取所有定时任务.
   |

PLR0912 Too many branches (33 > 12)
  --> app/routes/scheduler.py:71:5
   |
69 | @login_required  # type: ignore
70 | @scheduler_view_required  # type: ignore
71 | def get_jobs() -> Response:
   |     ^^^^^^^^
72 |     """获取所有定时任务.
   |

PLR0915 Too many statements (117 > 50)
  --> app/routes/scheduler.py:71:5
   |
69 | @login_required  # type: ignore
70 | @scheduler_view_required  # type: ignore
71 | def get_jobs() -> Response:
   |     ^^^^^^^^
72 |     """获取所有定时任务.
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:84:38
   |
82 |     """
83 |     try:
84 |         scheduler = get_scheduler()  # type: ignore
   |                                      ^^^^^^^^^^^^^^
85 |         if not scheduler.running:
86 |             log_warning("调度器未启动", module="scheduler")
   |

TRY301 Abstract `raise` to an inner function
  --> app/routes/scheduler.py:88:13
   |
86 |             log_warning("调度器未启动", module="scheduler")
87 |             msg = "调度器未启动"
88 |             raise SystemError(msg)
   |             ^^^^^^^^^^^^^^^^^^^^^^
89 |         jobs = scheduler.get_jobs()
90 |         jobs_data: list[dict[str, Any]] = []
   |

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   --> app/routes/scheduler.py:126:43
    |
124 |                         # 如果是列表,直接使用字段值
125 |                         # 按时间顺序生成trigger_args:秒、分、时、日、月、周、年
126 |                         if len(fields) >= 8:
    |                                           ^
127 |                             trigger_args["second"] = str(fields[7]) if fields[7] is not None else "0"
128 |                             trigger_args["minute"] = str(fields[6]) if fields[6] is not None else "0"
    |

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   --> app/routes/scheduler.py:177:43
    |
175 |                     elif isinstance(fields, list):
176 |                         # 如果是列表,直接使用字段值,按时间顺序排序:秒、分、时、日、月、周、年
177 |                         if len(fields) >= 8:
    |                                           ^
178 |                             # 按时间顺序添加非默认值
179 |                             if str(fields[7]) != "0":  # second
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:196:20
    |
194 |                     # 对于其他类型的触发器,使用原始字符串
195 |                     trigger_args = {"description": str(job.trigger)}
196 |             except Exception as job_error:
    |                    ^^^^^^^^^
197 |                 log_error(
198 |                     "处理任务触发器信息失败",
    |

ERA001 Found commented-out code
   --> app/routes/scheduler.py:212:13
    |
210 |                 state = "STATE_RUNNING"
211 |
212 |             # 获取任务的上次运行时间(从日志中查找)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
213 |             last_run_time = None
214 |             try:
    |
help: Remove commented-out code

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:215:17
    |
213 |             last_run_time = None
214 |             try:
215 |                 from datetime import timedelta
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |
217 |                 from app.models.unified_log import UnifiedLog
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:217:17
    |
215 |                 from datetime import timedelta
216 |
217 |                 from app.models.unified_log import UnifiedLog
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |                 from app.utils.time_utils import time_utils
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:218:17
    |
217 |                 from app.models.unified_log import UnifiedLog
218 |                 from app.utils.time_utils import time_utils
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |
220 |                 # 查找最近24小时内该任务的执行日志
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:229:20
    |
227 |                 if recent_logs:
228 |                     last_run_time = recent_logs.timestamp.isoformat()
229 |             except Exception as lookup_error:
    |                    ^^^^^^^^^
230 |                 log_warning(
231 |                     "获取任务上次运行时间失败",
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:272:18
    |
271 | @scheduler_bp.route("/api/jobs/<job_id>")
272 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
273 | @scheduler_view_required  # type: ignore
274 | def get_job(job_id: str) -> Response:
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:273:27
    |
271 | @scheduler_bp.route("/api/jobs/<job_id>")
272 | @login_required  # type: ignore
273 | @scheduler_view_required  # type: ignore
    |                           ^^^^^^^^^^^^^^
274 | def get_job(job_id: str) -> Response:
275 |     """获取指定任务详情.
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:285:48
    |
283 |     """
284 |     try:
285 |         job = get_scheduler().get_job(job_id)  # type: ignore
    |                                                ^^^^^^^^^^^^^^
286 |         if not job:
287 |             msg = "任务不存在"
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/scheduler.py:288:13
    |
286 |         if not job:
287 |             msg = "任务不存在"
288 |             raise NotFoundError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
289 |
290 |         job_info = {
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:319:18
    |
318 | @scheduler_bp.route("/api/jobs/<job_id>/pause", methods=["POST"])
319 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
320 | @scheduler_manage_required  # type: ignore
321 | @require_csrf
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:320:29
    |
318 | @scheduler_bp.route("/api/jobs/<job_id>/pause", methods=["POST"])
319 | @login_required  # type: ignore
320 | @scheduler_manage_required  # type: ignore
    |                             ^^^^^^^^^^^^^^
321 | @require_csrf
322 | def pause_job(job_id: str) -> Response:
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:333:44
    |
331 |     """
332 |     try:
333 |         get_scheduler().pause_job(job_id)  # type: ignore
    |                                            ^^^^^^^^^^^^^^
334 |         log_info("任务暂停成功", module="scheduler", job_id=job_id)
335 |         return jsonify_unified_success(message="任务暂停成功")
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:344:18
    |
343 | @scheduler_bp.route("/api/jobs/<job_id>/resume", methods=["POST"])
344 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
345 | @scheduler_manage_required  # type: ignore
346 | @require_csrf
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:345:29
    |
343 | @scheduler_bp.route("/api/jobs/<job_id>/resume", methods=["POST"])
344 | @login_required  # type: ignore
345 | @scheduler_manage_required  # type: ignore
    |                             ^^^^^^^^^^^^^^
346 | @require_csrf
347 | def resume_job(job_id: str) -> Response:
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:358:45
    |
356 |     """
357 |     try:
358 |         get_scheduler().resume_job(job_id)  # type: ignore
    |                                             ^^^^^^^^^^^^^^
359 |         log_info("任务恢复成功", module="scheduler", job_id=job_id)
360 |         return jsonify_unified_success(message="任务恢复成功")
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:369:18
    |
368 | @scheduler_bp.route("/api/jobs/<job_id>/run", methods=["POST"])
369 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
370 | @scheduler_manage_required  # type: ignore
371 | @require_csrf
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:370:29
    |
368 | @scheduler_bp.route("/api/jobs/<job_id>/run", methods=["POST"])
369 | @login_required  # type: ignore
370 | @scheduler_manage_required  # type: ignore
    |                             ^^^^^^^^^^^^^^
371 | @require_csrf
372 | def run_job(job_id: str) -> Response:
    |

C901 `run_job` is too complex (12 > 10)
   --> app/routes/scheduler.py:372:5
    |
370 | @scheduler_manage_required  # type: ignore
371 | @require_csrf
372 | def run_job(job_id: str) -> Response:
    |     ^^^^^^^
373 |     """立即执行任务.
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:386:38
    |
384 |     """
385 |     try:
386 |         scheduler = get_scheduler()  # type: ignore
    |                                      ^^^^^^^^^^^^^^
387 |         if not scheduler.running:
388 |             log_warning("调度器未启动", module="scheduler")
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/scheduler.py:390:13
    |
388 |             log_warning("调度器未启动", module="scheduler")
389 |             msg = "调度器未启动"
390 |             raise SystemError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^
391 |
392 |         job = scheduler.get_job(job_id)
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/scheduler.py:395:13
    |
393 |         if not job:
394 |             msg = "任务不存在"
395 |             raise NotFoundError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
396 |
397 |         log_info("开始立即执行任务", module="scheduler", job_id=job_id, job_name=job.name)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:404:16
    |
402 |         try:
403 |             user_is_authenticated = current_user.is_authenticated  # type: ignore[attr-defined]
404 |         except Exception:  # pragma: no cover - 防御性捕获
    |                ^^^^^^^^^
405 |             user_is_authenticated = False
406 |         if user_is_authenticated:
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:419:25
    |
417 |                         job.func(*job.args, **manual_kwargs)
418 |                     else:
419 |                         from app import create_app
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
420 |
421 |                         app = create_app(init_scheduler_on_start=False)  # type: ignore
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:421:74
    |
419 |                         from app import create_app
420 |
421 |                         app = create_app(init_scheduler_on_start=False)  # type: ignore
    |                                                                          ^^^^^^^^^^^^^^
422 |                         with app.app_context():
423 |                             job.func(*job.args, **(job.kwargs or {}))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:431:24
    |
429 |                         job_name=job.name,
430 |                     )
431 |                 except Exception as func_error:  # pragma: no cover - 防御性日志
    |                        ^^^^^^^^^
432 |                     log_error(
433 |                         "任务函数执行失败",
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:472:18
    |
471 | @scheduler_bp.route("/api/jobs/reload", methods=["POST"])
472 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
473 | @scheduler_manage_required  # type: ignore
474 | @require_csrf
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:473:29
    |
471 | @scheduler_bp.route("/api/jobs/reload", methods=["POST"])
472 | @login_required  # type: ignore
473 | @scheduler_manage_required  # type: ignore
    |                             ^^^^^^^^^^^^^^
474 | @require_csrf
475 | def reload_jobs() -> Response:
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:485:38
    |
483 |     """
484 |     try:
485 |         scheduler = get_scheduler()  # type: ignore
    |                                      ^^^^^^^^^^^^^^
486 |         if not scheduler.running:
487 |             log_warning("调度器未启动", module="scheduler")
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/scheduler.py:489:13
    |
487 |             log_warning("调度器未启动", module="scheduler")
488 |             msg = "调度器未启动"
489 |             raise SystemError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^
490 |
491 |         # 获取现有任务列表
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:502:20
    |
500 |                 deleted_count += 1
501 |                 log_info("重新加载-删除任务", module="scheduler", job_id=job_id)
502 |             except Exception as del_err:
    |                    ^^^^^^^^^
503 |                 log_error(
504 |                     "重新加载-删除任务失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:511:9
    |
510 |         # 重新加载任务配置
511 |         from app.scheduler import _reload_all_jobs
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
512 |         _reload_all_jobs()
    |

D104 Missing docstring in public package
--> app/routes/tags/__init__.py:1:1

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/tags/manage.py:201:12
    |
199 |         return redirect(url_for("tags.index"))
200 |
201 |     except Exception as e:
    |            ^^^^^^^^^
202 |         db.session.rollback()
203 |         log_error(
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/tags/manage.py:264:16
    |
262 |             _delete_tag_record(tag, operator_id=operator_id)
263 |             results.append({"tag_id": tag_id, "status": "deleted"})
264 |         except Exception as exc:
    |                ^^^^^^^^^
265 |             db.session.rollback()
266 |             has_failure = True
    |

BLE001 Do not catch blind exception: `Exception`
  --> app/routes/users.py:60:12
   |
58 |         )
59 |
60 |     except Exception as e:
   |            ^^^^^^^^^
61 |         log_error(
62 |             "加载用户管理页面失败",
   |

D205 1 blank line required between summary line and description
 --> app/scheduler.py:1:1
  |
1 | / """鲸落定时任务调度器
2 | | 使用APScheduler实现轻量级定时任务.
3 | | """
  | |___^
4 |
5 |   import atexit
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/scheduler.py:31:9
   |
29 |     """定时任务调度器."""
30 |
31 |     def __init__(self, app: Any = None) -> None:
   |         ^^^^^^^^
32 |         self.app = app
33 |         self.scheduler = None
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `app`
  --> app/scheduler.py:31:29
   |
29 |     """定时任务调度器."""
30 |
31 |     def __init__(self, app: Any = None) -> None:
   |                             ^^^
32 |         self.app = app
33 |         self.scheduler = None
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `event`
  --> app/scheduler.py:80:36
   |
78 |         self.scheduler.add_listener(self._job_error, EVENT_JOB_ERROR)
79 |
80 |     def _job_executed(self, event: Any) -> None:
   |                                    ^^^
81 |         """处理任务成功事件.
   |

G004 Logging statement uses f-string
  --> app/scheduler.py:90:21
   |
89 |         """
90 |         logger.info(f"任务执行成功: {event.job_id} - {event.retval}")
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
91 |
92 |     def _job_error(self, event: Any) -> None:
   |
help: Convert to lazy `%` formatting

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `event`
  --> app/scheduler.py:92:33
   |
90 |         logger.info(f"任务执行成功: {event.job_id} - {event.retval}")
91 |
92 |     def _job_error(self, event: Any) -> None:
   |                                 ^^^
93 |         """处理任务失败事件.
   |

G004 Logging statement uses f-string
   --> app/scheduler.py:103:22
    |
101 |         """
102 |         exception_str = str(event.exception) if event.exception else "未知错误"
103 |         logger.error(f"任务执行失败: {event.job_id} - {exception_str}")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
104 |
105 |     def start(self) -> None:
    |
help: Convert to lazy `%` formatting

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/scheduler.py:129:29
    |
127 |             logger.info("定时任务调度器已停止")
128 |
129 |     def add_job(self, func: Any, trigger: Any, **kwargs: Any) -> Any:
    |                             ^^^
130 |         """向调度器注册任务.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `trigger`
   --> app/scheduler.py:129:43
    |
127 |             logger.info("定时任务调度器已停止")
128 |
129 |     def add_job(self, func: Any, trigger: Any, **kwargs: Any) -> Any:
    |                                           ^^^
130 |         """向调度器注册任务.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/scheduler.py:129:58
    |
127 |             logger.info("定时任务调度器已停止")
128 |
129 |     def add_job(self, func: Any, trigger: Any, **kwargs: Any) -> Any:
    |                                                          ^^^
130 |         """向调度器注册任务.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `add_job`
   --> app/scheduler.py:129:66
    |
127 |             logger.info("定时任务调度器已停止")
128 |
129 |     def add_job(self, func: Any, trigger: Any, **kwargs: Any) -> Any:
    |                                                                  ^^^
130 |         """向调度器注册任务.
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:155:25
    |
153 |         try:
154 |             self.scheduler.remove_job(job_id)
155 |             logger.info(f"任务已删除: {job_id}")
    |                         ^^^^^^^^^^^^^^^^^^^^^^^
156 |         except Exception as e:
157 |             error_str = str(e) if e else "未知错误"
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:158:30
    |
156 |         except Exception as e:
157 |             error_str = str(e) if e else "未知错误"
158 |             logger.exception(f"删除任务失败: {job_id} - {error_str}")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
159 |
160 |     def get_jobs(self) -> list:
    |
help: Convert to lazy `%` formatting

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get_job`
   --> app/scheduler.py:169:39
    |
167 |         return self.scheduler.get_jobs()
168 |
169 |     def get_job(self, job_id: str) -> Any:
    |                                       ^^^
170 |         """获取指定任务.
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:192:21
    |
190 |         """
191 |         self.scheduler.pause_job(job_id)
192 |         logger.info(f"任务已暂停: {job_id}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^
193 |
194 |     def resume_job(self, job_id: str) -> None:
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:205:21
    |
203 |         """
204 |         self.scheduler.resume_job(job_id)
205 |         logger.info(f"任务已恢复: {job_id}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Convert to lazy `%` formatting

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get_scheduler`
   --> app/scheduler.py:213:24
    |
212 | # 确保scheduler实例可以被正确访问
213 | def get_scheduler() -> Any:
    |                        ^^^
214 |     """获取底层 APScheduler 实例.
    |

PLW0603 Using the global statement to update `_scheduler_lock_handle` is discouraged
   --> app/scheduler.py:230:12
    |
229 |     """
230 |     global _scheduler_lock_handle, _scheduler_lock_pid
    |            ^^^^^^^^^^^^^^^^^^^^^^
231 |
232 |     if fcntl is None:
    |

PLW0603 Using the global statement to update `_scheduler_lock_handle` is discouraged
   --> app/scheduler.py:230:12
    |
229 |     """
230 |     global _scheduler_lock_handle, _scheduler_lock_pid
    |            ^^^^^^^^^^^^^^^^^^^^^^
231 |
232 |     if fcntl is None:
    |

PLW0603 Using the global statement to update `_scheduler_lock_pid` is discouraged
   --> app/scheduler.py:230:36
    |
229 |     """
230 |     global _scheduler_lock_handle, _scheduler_lock_pid
    |                                    ^^^^^^^^^^^^^^^^^^^
231 |
232 |     if fcntl is None:
    |

PLW0603 Using the global statement to update `_scheduler_lock_pid` is discouraged
   --> app/scheduler.py:230:36
    |
229 |     """
230 |     global _scheduler_lock_handle, _scheduler_lock_pid
    |                                    ^^^^^^^^^^^^^^^^^^^
231 |
232 |     if fcntl is None:
    |

SIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`
   --> app/scheduler.py:242:9
    |
240 |               return True
241 |           # 子进程继承了锁句柄,但并未真正持有锁,需要重新获取
242 | /         try:
243 | |             _scheduler_lock_handle.close()
244 | |         except Exception:  # pragma: no cover - 防御性释放
245 | |             pass
    | |________________^
246 |           _scheduler_lock_handle = None
247 |           _scheduler_lock_pid = None
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> app/scheduler.py:244:9
    |
242 |           try:
243 |               _scheduler_lock_handle.close()
244 | /         except Exception:  # pragma: no cover - 防御性释放
245 | |             pass
    | |________________^
246 |           _scheduler_lock_handle = None
247 |           _scheduler_lock_pid = None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/scheduler.py:244:16
    |
242 |         try:
243 |             _scheduler_lock_handle.close()
244 |         except Exception:  # pragma: no cover - 防御性释放
    |                ^^^^^^^^^
245 |             pass
246 |         _scheduler_lock_handle = None
    |

SIM115 Use a context manager for opening files
   --> app/scheduler.py:254:14
    |
252 |     lock_path = Path("userdata") / "scheduler.lock"
253 |     lock_path.parent.mkdir(exist_ok=True)
254 |     handle = open(lock_path, "w+")
    |              ^^^^
255 |     try:
256 |         fcntl.flock(handle, fcntl.LOCK_EX | fcntl.LOCK_NB)
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> app/scheduler.py:254:14
    |
252 |     lock_path = Path("userdata") / "scheduler.lock"
253 |     lock_path.parent.mkdir(exist_ok=True)
254 |     handle = open(lock_path, "w+")
    |              ^^^^
255 |     try:
256 |         fcntl.flock(handle, fcntl.LOCK_EX | fcntl.LOCK_NB)
    |
help: Replace with `Path.open()`

TRY300 Consider moving this statement to an `else` block
   --> app/scheduler.py:262:9
    |
260 |         _scheduler_lock_pid = current_pid
261 |         logger.info("调度器锁已获取,当前进程负责运行定时任务", pid=os.getpid())
262 |         return True
    |         ^^^^^^^^^^^
263 |     except BlockingIOError:
264 |         handle.close()
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:269:26
    |
267 |     except Exception as exc:  # pragma: no cover - 极端情况
268 |         handle.close()
269 |         logger.exception(f"获取调度器锁失败: {exc}")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
270 |         return False
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/scheduler.py:269:39
    |
267 |     except Exception as exc:  # pragma: no cover - 极端情况
268 |         handle.close()
269 |         logger.exception(f"获取调度器锁失败: {exc}")
    |                                               ^^^
270 |         return False
    |

PLW0603 Using the global statement to update `_scheduler_lock_handle` is discouraged
   --> app/scheduler.py:280:12
    |
279 |     """
280 |     global _scheduler_lock_handle, _scheduler_lock_pid
    |            ^^^^^^^^^^^^^^^^^^^^^^
281 |     if fcntl is None or not _scheduler_lock_handle:
282 |         return
    |

PLW0603 Using the global statement to update `_scheduler_lock_pid` is discouraged
   --> app/scheduler.py:280:36
    |
279 |     """
280 |     global _scheduler_lock_handle, _scheduler_lock_pid
    |                                    ^^^^^^^^^^^^^^^^^^^
281 |     if fcntl is None or not _scheduler_lock_handle:
282 |         return
    |

SIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`
   --> app/scheduler.py:283:5
    |
281 |       if fcntl is None or not _scheduler_lock_handle:
282 |           return
283 | /     try:
284 | |         fcntl.flock(_scheduler_lock_handle, fcntl.LOCK_UN)
285 | |     except Exception:  # pragma: no cover
286 | |         pass
    | |____________^
287 |       try:
288 |           _scheduler_lock_handle.close()
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> app/scheduler.py:285:5
    |
283 |       try:
284 |           fcntl.flock(_scheduler_lock_handle, fcntl.LOCK_UN)
285 | /     except Exception:  # pragma: no cover
286 | |         pass
    | |____________^
287 |       try:
288 |           _scheduler_lock_handle.close()
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/scheduler.py:285:12
    |
283 |     try:
284 |         fcntl.flock(_scheduler_lock_handle, fcntl.LOCK_UN)
285 |     except Exception:  # pragma: no cover
    |            ^^^^^^^^^
286 |         pass
287 |     try:
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> app/scheduler.py:289:5
    |
287 |       try:
288 |           _scheduler_lock_handle.close()
289 | /     except Exception:  # pragma: no cover
290 | |         pass
    | |____________^
291 |       finally:
292 |           _scheduler_lock_handle = None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/scheduler.py:289:12
    |
287 |     try:
288 |         _scheduler_lock_handle.close()
289 |     except Exception:  # pragma: no cover
    |            ^^^^^^^^^
290 |         pass
291 |     finally:
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:308:21
    |
306 |     enable_flag = os.environ.get("ENABLE_SCHEDULER", "true").strip().lower()
307 |     if enable_flag not in ("true", "1", "yes"):
308 |         logger.info(f"检测到 ENABLE_SCHEDULER={enable_flag},跳过调度器初始化")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
309 |         return False
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:314:21
    |
312 |     if server_software.startswith("gunicorn"):
313 |         parent_pid = os.getppid()
314 |         logger.info(f"检测到 gunicorn 环境,ppid={parent_pid},将通过文件锁保证单实例")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
315 |
316 |     # Flask reloader: 只有子进程 (WERKZEUG_RUN_MAIN=true) 才运行调度器
    |
help: Convert to lazy `%` formatting

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `app`
   --> app/scheduler.py:326:25
    |
326 | def init_scheduler(app: Any) -> None:
    |                         ^^^
327 |     """初始化调度器(仅在允许的进程中启动).
    |

PLW0602 Using global for `scheduler` but no assignment is done
   --> app/scheduler.py:336:12
    |
335 |     """
336 |     global scheduler
    |            ^^^^^^^^^
337 |
338 |     if not _should_start_scheduler():
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:362:9
    |
361 |         # 等待调度器完全启动
362 |         import time
    |         ^^^^^^^^^^^
363 |         time.sleep(2)
    |

TRY300 Consider moving this statement to an `else` block
   --> app/scheduler.py:372:9
    |
371 |         logger.info("调度器初始化完成")
372 |         return scheduler
    |         ^^^^^^^^^^^^^^^^
373 |     except Exception as e:
374 |         logger.exception(f"调度器初始化失败: {e}")
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:374:26
    |
372 |         return scheduler
373 |     except Exception as e:
374 |         logger.exception(f"调度器初始化失败: {e}")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^
375 |         # 不抛出异常,让应用继续启动
376 |         return None
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/scheduler.py:374:39
    |
372 |         return scheduler
373 |     except Exception as e:
374 |         logger.exception(f"调度器初始化失败: {e}")
    |                                               ^
375 |         # 不抛出异常,让应用继续启动
376 |         return None
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:407:29
    |
405 |             existing_jobs = scheduler.get_jobs()
406 |             if existing_jobs:
407 |                 logger.info(f"从SQLite数据库加载了 {len(existing_jobs)} 个现有任务")
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
408 |                 for job in existing_jobs:
409 |                     logger.info(f"加载任务: {job.name} ({job.id})")
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:409:33
    |
407 |                 logger.info(f"从SQLite数据库加载了 {len(existing_jobs)} 个现有任务")
408 |                 for job in existing_jobs:
409 |                     logger.info(f"加载任务: {job.name} ({job.id})")
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
410 |             else:
411 |                 logger.info("SQLite数据库中没有找到任务")
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:416:30
    |
414 |             return
415 |         except Exception as e:
416 |             logger.exception(f"获取任务列表失败: {e}")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^
417 |             return
418 |     except Exception as e:
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/scheduler.py:416:43
    |
414 |             return
415 |         except Exception as e:
416 |             logger.exception(f"获取任务列表失败: {e}")
    |                                                   ^
417 |             return
418 |     except Exception as e:
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:419:26
    |
417 |             return
418 |     except Exception as e:
419 |         logger.exception(f"加载现有任务失败: {e}")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^
420 |         # 不抛出异常,让应用继续启动
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/scheduler.py:419:39
    |
417 |             return
418 |     except Exception as e:
419 |         logger.exception(f"加载现有任务失败: {e}")
    |                                               ^
420 |         # 不抛出异常,让应用继续启动
    |

C901 `_load_tasks_from_config` is too complex (22 > 10)
   --> app/scheduler.py:443:5
    |
443 | def _load_tasks_from_config(force: bool = False) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^
444 |     """从配置文件加载默认任务并注册.
    |

PLR0912 Too many branches (23 > 12)
   --> app/scheduler.py:443:5
    |
443 | def _load_tasks_from_config(force: bool = False) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^
444 |     """从配置文件加载默认任务并注册.
    |

PLR0915 Too many statements (75 > 50)
   --> app/scheduler.py:443:5
    |
443 | def _load_tasks_from_config(force: bool = False) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^
444 |     """从配置文件加载默认任务并注册.
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/scheduler.py:443:29
    |
443 | def _load_tasks_from_config(force: bool = False) -> None:
    |                             ^^^^^
444 |     """从配置文件加载默认任务并注册.
    |

FBT002 Boolean default positional argument in function definition
   --> app/scheduler.py:443:29
    |
443 | def _load_tasks_from_config(force: bool = False) -> None:
    |                             ^^^^^
444 |     """从配置文件加载默认任务并注册.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:453:5
    |
452 |     """
453 |     import yaml
    |     ^^^^^^^^^^^
454 |
455 |     from app.tasks.accounts_sync_tasks import sync_accounts
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:455:5
    |
453 |     import yaml
454 |
455 |     from app.tasks.accounts_sync_tasks import sync_accounts
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
456 |     from app.tasks.capacity_aggregation_tasks import calculate_database_size_aggregations
457 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:456:5
    |
455 |     from app.tasks.accounts_sync_tasks import sync_accounts
456 |     from app.tasks.capacity_aggregation_tasks import calculate_database_size_aggregations
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
457 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
458 |     from app.tasks.log_cleanup_tasks import cleanup_old_logs
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:457:5
    |
455 |     from app.tasks.accounts_sync_tasks import sync_accounts
456 |     from app.tasks.capacity_aggregation_tasks import calculate_database_size_aggregations
457 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
458 |     from app.tasks.log_cleanup_tasks import cleanup_old_logs
459 |     from app.tasks.partition_management_tasks import monitor_partition_health
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:458:5
    |
456 |     from app.tasks.capacity_aggregation_tasks import calculate_database_size_aggregations
457 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
458 |     from app.tasks.log_cleanup_tasks import cleanup_old_logs
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
459 |     from app.tasks.partition_management_tasks import monitor_partition_health
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:459:5
    |
457 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
458 |     from app.tasks.log_cleanup_tasks import cleanup_old_logs
459 |     from app.tasks.partition_management_tasks import monitor_partition_health
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
460 |
461 |     # 如果不是强制模式,检查是否已有任务
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:466:29
    |
464 |             existing_jobs = scheduler.get_jobs()
465 |             if existing_jobs:
466 |                 logger.info(f"发现 {len(existing_jobs)} 个现有任务,跳过创建默认任务")
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
467 |                 return
468 |         except KeyboardInterrupt:
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:472:30
    |
470 |             return
471 |         except Exception as e:
472 |             logger.exception(f"检查现有任务失败: {e}")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^
473 |             return
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/scheduler.py:472:43
    |
470 |             return
471 |         except Exception as e:
472 |             logger.exception(f"检查现有任务失败: {e}")
    |                                                   ^
473 |             return
    |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
   --> app/scheduler.py:476:19
    |
475 |     # 从配置文件读取默认任务
476 |     config_file = os.path.join(os.path.dirname(__file__), "config", "scheduler_tasks.yaml")
    |                   ^^^^^^^^^^^^
477 |
478 |     try:
    |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
   --> app/scheduler.py:476:32
    |
475 |     # 从配置文件读取默认任务
476 |     config_file = os.path.join(os.path.dirname(__file__), "config", "scheduler_tasks.yaml")
    |                                ^^^^^^^^^^^^^^^
477 |
478 |     try:
    |
help: Replace with `Path(...).parent`

PTH123 `open()` should be replaced by `Path.open()`
   --> app/scheduler.py:479:14
    |
478 |     try:
479 |         with open(config_file, encoding="utf-8") as f:
    |              ^^^^
480 |             config = yaml.safe_load(f)
    |
help: Replace with `Path.open()`

G004 Logging statement uses f-string
   --> app/scheduler.py:505:32
    |
503 |             func = task_func_map.get(function_name)
504 |             if not func:
505 |                 logger.warning(f"未知的任务函数: {function_name}")
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
506 |                 continue
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:514:37
    |
512 |                     try:
513 |                         scheduler.remove_job(task_id)
514 |                         logger.info(f"强制模式-删除现有任务: {task_name} ({task_id})")
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
515 |                     except Exception:
516 |                         pass  # 任务不存在,忽略错误
    |
help: Convert to lazy `%` formatting

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> app/scheduler.py:515:21
    |
513 |                           scheduler.remove_job(task_id)
514 |                           logger.info(f"强制模式-删除现有任务: {task_name} ({task_id})")
515 | /                     except Exception:
516 | |                         pass  # 任务不存在,忽略错误
    | |____________________________^
517 |
518 |                   # 对于cron触发器,确保使用正确的时区
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/scheduler.py:515:28
    |
513 |                         scheduler.remove_job(task_id)
514 |                         logger.info(f"强制模式-删除现有任务: {task_name} ({task_id})")
515 |                     except Exception:
    |                            ^^^^^^^^^
516 |                         pass  # 任务不存在,忽略错误
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:520:21
    |
518 |                 # 对于cron触发器,确保使用正确的时区
519 |                 if trigger_type == "cron":
520 |                     from apscheduler.triggers.cron import CronTrigger
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
521 |                     # 只传递实际配置的字段,避免APScheduler自动填充默认值
522 |                     cron_kwargs = {}
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:554:29
    |
552 |                         **trigger_params,
553 |                     )
554 |                 logger.info(f"添加任务: {task_name} ({task_id})")
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
555 |             except Exception as e:
556 |                 if force:
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:557:38
    |
555 |             except Exception as e:
556 |                 if force:
557 |                     logger.exception(f"强制模式-创建任务失败: {task_name} ({task_id}) - {e}")
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
558 |                 else:
559 |                     logger.warning(f"任务已存在,跳过创建: {task_name} ({task_id}) - {e}")
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/scheduler.py:557:80
    |
555 |             except Exception as e:
556 |                 if force:
557 |                     logger.exception(f"强制模式-创建任务失败: {task_name} ({task_id}) - {e}")
    |                                                                                          ^
558 |                 else:
559 |                     logger.warning(f"任务已存在,跳过创建: {task_name} ({task_id}) - {e}")
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:559:36
    |
557 |                     logger.exception(f"强制模式-创建任务失败: {task_name} ({task_id}) - {e}")
558 |                 else:
559 |                     logger.warning(f"任务已存在,跳过创建: {task_name} ({task_id}) - {e}")
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
560 |
561 |     except FileNotFoundError:
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:562:26
    |
561 |     except FileNotFoundError:
562 |         logger.exception(f"配置文件不存在: {config_file},无法加载默认任务")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
563 |         return
564 |     except Exception as e:
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:565:26
    |
563 |         return
564 |     except Exception as e:
565 |         logger.exception(f"读取配置文件失败: {e}")
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^
566 |         return
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/scheduler.py:565:39
    |
563 |         return
564 |     except Exception as e:
565 |         logger.exception(f"读取配置文件失败: {e}")
    |                                               ^
566 |         return
    |

D107 Missing docstring in `__init__`
  --> app/services/account_classification/auto_classify_service.py:68:9
   |
66 |     """
67 |
68 |     def __init__(self, classification_service: AccountClassificationService | None = None) -> None:
   |         ^^^^^^^^
69 |         self.classification_service = classification_service or AccountClassificationService()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance_id`
  --> app/services/account_classification/auto_classify_service.py:74:22
   |
72 |         self,
73 |         *,
74 |         instance_id: Any,
   |                      ^^^
75 |         created_by: int | None,
76 |         use_optimized: Any = True,
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `use_optimized`
  --> app/services/account_classification/auto_classify_service.py:76:24
   |
74 |         instance_id: Any,
75 |         created_by: int | None,
76 |         use_optimized: Any = True,
   |                        ^^^
77 |     ) -> AutoClassifyResult:
78 |         """执行账户自动分类.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/account_classification/auto_classify_service.py:186:24
    |
185 |     @staticmethod
186 |     def _as_int(value: Any) -> int:
    |                        ^^^
187 |         """安全地将输入转换为整数.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `raw_value`
   --> app/services/account_classification/auto_classify_service.py:201:49
    |
199 |             return 0
200 |
201 |     def _normalize_instance_id(self, raw_value: Any) -> int | None:
    |                                                 ^^^
202 |         """规范化实例 ID.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/account_classification/auto_classify_service.py:225:35
    |
223 |             raise AutoClassifyError(msg) from exc
224 |
225 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
226 |         """将输入值转换为布尔型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `errors`
   --> app/services/account_classification/auto_classify_service.py:257:35
    |
256 |     @staticmethod
257 |     def _normalize_errors(errors: Any) -> list[str]:
    |                                   ^^^
258 |         """规范化错误结构为字符串列表.
    |

D107 Missing docstring in `__init__`
  --> app/services/account_classification/cache.py:17:9
   |
15 |     """针对分类业务封装的缓存访问器."""
16 |
17 |     def __init__(self, manager: Any | None = None) -> None:
   |         ^^^^^^^^
18 |         self.manager = manager or cache_manager
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `manager`
  --> app/services/account_classification/cache.py:17:33
   |
15 |     """针对分类业务封装的缓存访问器."""
16 |
17 |     def __init__(self, manager: Any | None = None) -> None:
   |                                 ^^^^^^^^^^
18 |         self.manager = manager or cache_manager
   |

C901 `evaluate` is too complex (41 > 10)
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:9
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

PLR0911 Too many return statements (10 > 6)
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:9
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

PLR0912 Too many branches (43 > 12)
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:9
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

PLR0915 Too many statements (85 > 50)
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:9
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

ANN001 Missing type annotation for function argument `account`
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:24
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |                        ^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/account_classification/classifiers/mysql_classifier.py:170:13
    |
168 |                     return False
169 |
170 |             return True
    |             ^^^^^^^^^^^
171 |         except Exception as exc:
172 |             log_error("评估MySQL规则失败", module="account_classification", error=str(exc))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/classifiers/mysql_classifier.py:171:16
    |
170 |             return True
171 |         except Exception as exc:
    |                ^^^^^^^^^
172 |             log_error("评估MySQL规则失败", module="account_classification", error=str(exc))
173 |             return False
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `perms`
   --> app/services/account_classification/classifiers/mysql_classifier.py:176:36
    |
175 |     @staticmethod
176 |     def _extract_perm_names(perms: Any) -> set[str]:
    |                                    ^^^
177 |         """从权限数据中提取权限名称集合.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `requirement`
   --> app/services/account_classification/classifiers/mysql_classifier.py:200:48
    |
199 |     @staticmethod
200 |     def _normalize_db_requirement(requirement: Any) -> dict[str, Any] | None:
    |                                                ^^^
201 |         """规范化数据库权限要求.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `requirement`
   --> app/services/account_classification/classifiers/mysql_classifier.py:217:51
    |
216 |     @staticmethod
217 |     def _normalize_table_requirement(requirement: Any) -> dict[str, Any] | None:
    |                                                   ^^^
218 |         """规范化表权限要求.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/account_classification/classifiers/mysql_classifier.py:234:29
    |
233 |     @staticmethod
234 |     def _ensure_list(value: Any) -> list[str]:
    |                             ^^^
235 |         """确保值为列表格式.
    |

C901 `evaluate` is too complex (15 > 10)
  --> app/services/account_classification/classifiers/oracle_classifier.py:36:9
   |
34 |     db_type = "oracle"
35 |
36 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
37 |         """评估账户是否满足 Oracle 规则表达式.
   |

PLR0912 Too many branches (14 > 12)
  --> app/services/account_classification/classifiers/oracle_classifier.py:36:9
   |
34 |     db_type = "oracle"
35 |
36 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
37 |         """评估账户是否满足 Oracle 规则表达式.
   |

ANN001 Missing type annotation for function argument `account`
  --> app/services/account_classification/classifiers/oracle_classifier.py:36:24
   |
34 |     db_type = "oracle"
35 |
36 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |                        ^^^^^^^
37 |         """评估账户是否满足 Oracle 规则表达式.
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/classifiers/oracle_classifier.py:138:16
    |
137 |             return self._combine_results(match_results, operator)
138 |         except Exception as exc:
    |                ^^^^^^^^^
139 |             log_error("评估Oracle规则失败", module="account_classification", error=str(exc))
140 |             return False
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `source`
   --> app/services/account_classification/classifiers/oracle_classifier.py:161:50
    |
160 |     @staticmethod
161 |     def _normalize_tablespace_privileges(source: Any) -> list[dict[str, Any]]:
    |                                                  ^^^
162 |         """支持 dict/list 两种结构的表空间权限.
    |

PERF401 Use `list.extend` to create a transformed list
   --> app/services/account_classification/classifiers/oracle_classifier.py:176:21
    |
174 |                   perms = privileges if isinstance(privileges, list) else [privileges]
175 |                   for privilege in perms:
176 | /                     normalized.append(
177 | |                         {
178 | |                             "tablespace_name": tablespace_name,
179 | |                             "privilege": privilege,
180 | |                         },
181 | |                     )
    | |_____________________^
182 |           elif isinstance(source, list):
183 |               normalized = [item for item in source if isinstance(item, dict)]
    |
help: Replace for loop with list.extend

C901 `evaluate` is too complex (11 > 10)
  --> app/services/account_classification/classifiers/postgresql_classifier.py:37:9
   |
35 |     db_type = "postgresql"
36 |
37 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
38 |         """评估账户是否满足 PostgreSQL 规则表达式.
   |

ANN001 Missing type annotation for function argument `account`
  --> app/services/account_classification/classifiers/postgresql_classifier.py:37:24
   |
35 |     db_type = "postgresql"
36 |
37 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |                        ^^^^^^^
38 |         """评估账户是否满足 PostgreSQL 规则表达式.
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/classifiers/postgresql_classifier.py:105:16
    |
104 |             return self._combine_results(match_results, operator)
105 |         except Exception as exc:
    |                ^^^^^^^^^
106 |             log_error("评估PostgreSQL规则失败", module="account_classification", error=str(exc))
107 |             return False
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `perms`
   --> app/services/account_classification/classifiers/postgresql_classifier.py:110:36
    |
109 |     @staticmethod
110 |     def _extract_priv_names(perms: Any) -> set[str]:
    |                                    ^^^
111 |         """提取权限名称集合.
    |

C901 `evaluate` is too complex (11 > 10)
  --> app/services/account_classification/classifiers/sqlserver_classifier.py:37:9
   |
35 |     db_type = "sqlserver"
36 |
37 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
38 |         """评估账户是否满足 SQL Server 规则表达式.
   |

ANN001 Missing type annotation for function argument `account`
  --> app/services/account_classification/classifiers/sqlserver_classifier.py:37:24
   |
35 |     db_type = "sqlserver"
36 |
37 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |                        ^^^^^^^
38 |         """评估账户是否满足 SQL Server 规则表达式.
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/classifiers/sqlserver_classifier.py:115:16
    |
114 |             return self._combine_results(match_results, operator)
115 |         except Exception as exc:
    |                ^^^^^^^^^
116 |             log_error("评估SQL Server规则失败", module="account_classification", error=str(exc))
117 |             return False
    |

D107 Missing docstring in `__init__`
  --> app/services/account_classification/orchestrator.py:32:9
   |
30 |     """
31 |
32 |     def __init__(
   |         ^^^^^^^^
33 |         self,
34 |         repository: ClassificationRepository | None = None,
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/account_classification/orchestrator.py:87:13
   |
85 |             )
86 |
87 |             return {"success": True, "message": "自动分类完成", **result}
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
88 |         except Exception as exc:
89 |             log_error("优化后的自动分类失败", module="account_classification", error=str(exc))
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/account_classification/orchestrator.py:88:16
   |
87 |             return {"success": True, "message": "自动分类完成", **result}
88 |         except Exception as exc:
   |                ^^^^^^^^^
89 |             log_error("优化后的自动分类失败", module="account_classification", error=str(exc))
90 |             return {"success": False, "error": f"自动分类失败: {exc}"}
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/orchestrator.py:101:16
    |
 99 |         try:
100 |             return self.cache.invalidate_all()
101 |         except Exception as exc:
    |                ^^^^^^^^^
102 |             log_error("清除分类缓存失败", module="account_classification", error=str(exc))
103 |             return False
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/orchestrator.py:117:16
    |
115 |         try:
116 |             return self.cache.invalidate_db_type(db_type)
117 |         except Exception as exc:
    |                ^^^^^^^^^
118 |             log_error("清除数据库类型缓存失败", module="account_classification", db_type=db_type, error=str(exc))
119 |             return False
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/orchestrator.py:251:20
    |
249 |                 all_errors.extend(result["errors"])
250 |                 db_type_results[db_type] = result
251 |             except Exception as exc:
    |                    ^^^^^^^^^
252 |                 error_msg = f"数据库类型 {db_type} 分类失败: {exc}"
253 |                 log_error(error_msg, module="account_classification")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/orchestrator.py:316:20
    |
314 |                     matched_accounts=len(matched_accounts),
315 |                 )
316 |             except Exception as exc:
    |                    ^^^^^^^^^
317 |                 error_msg = f"规则 {rule.rule_name} 处理失败: {exc}"
318 |                 log_error(error_msg, module="account_classification", rule_id=rule.id, db_type=db_type)
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/services/account_classification/orchestrator.py:355:17
    |
353 |         for account in filtered_accounts:
354 |             if self._evaluate_rule(account, rule):
355 |                 matched_accounts.append(account)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
356 |         return matched_accounts
    |
help: Replace for loop with list comprehension

TRY300 Consider moving this statement to an `else` block
  --> app/services/account_classification/repositories.py:89:13
   |
87 |                 )
88 |             db.session.commit()
89 |             return deleted
   |             ^^^^^^^^^^^^^^
90 |         except Exception as exc:
91 |             db.session.rollback()
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/repositories.py:160:16
    |
159 |             return len(new_assignments)
160 |         except Exception as exc:
    |                ^^^^^^^^^
161 |             log_error(
162 |                 "批量写入分类分配失败",
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/services/account_classification/repositories.py:184:13
    |
182 |           payload: list[dict] = []
183 |           for rule in rules:
184 | /             payload.append(
185 | |                 {
186 | |                     "id": rule.id,
187 | |                     "classification_id": rule.classification_id,
188 | |                     "db_type": rule.db_type,
189 | |                     "rule_name": rule.rule_name,
190 | |                     "rule_expression": rule.rule_expression,
191 | |                     "is_active": rule.is_active,
192 | |                     "created_at": rule.created_at.isoformat() if rule.created_at else None,
193 | |                     "updated_at": rule.updated_at.isoformat() if rule.updated_at else None,
194 | |                 },
195 | |             )
    | |_____________^
196 |           return payload
    |
help: Replace for loop with list comprehension

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/repositories.py:220:20
    |
218 |                 rule.is_active = data.get("is_active", True)
219 |                 hydrated.append(rule)
220 |             except Exception as exc:
    |                    ^^^^^^^^^
221 |                 log_error("反序列化规则缓存失败", module="account_classification", error=str(exc))
222 |         return hydrated
    |

FBT001 Boolean-typed positional argument in function definition
  --> app/services/accounts_sync/account_query_service.py:9:48
   |
 9 | def get_accounts_by_instance(instance_id: int, include_inactive: bool = False) -> list[AccountPermission]:
   |                                                ^^^^^^^^^^^^^^^^
10 |     """按实例获取账户列表.
   |

FBT002 Boolean default positional argument in function definition
  --> app/services/accounts_sync/account_query_service.py:9:48
   |
 9 | def get_accounts_by_instance(instance_id: int, include_inactive: bool = False) -> list[AccountPermission]:
   |                                                ^^^^^^^^^^^^^^^^
10 |     """按实例获取账户列表.
   |

D205 1 blank line required between summary line and description
 --> app/services/accounts_sync/accounts_sync_filters.py:1:1
  |
1 | / """鲸落 - 数据库过滤规则管理器
2 | | 专门用于数据库账户同步时的过滤规则管理.
3 | | """
  | |___^
4 |
5 |   import re
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/accounts_sync_filters.py:22:9
   |
20 |     """数据库过滤规则管理器."""
21 |
22 |     def __init__(self, config_path: str | Path | None = None) -> None:
   |         ^^^^^^^^
23 |         path_obj = Path(config_path) if config_path else _DEFAULT_CONFIG_PATH
24 |         self.config_file = path_obj
   |

G004 Logging statement uses f-string
  --> app/services/accounts_sync/accounts_sync_filters.py:40:26
   |
38 |         """
39 |         if not self.config_file.exists():
40 |             logger.error(f"账户过滤规则配置文件不存在: {self.config_path_str}")
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
41 |             msg = f"账户过滤规则配置文件不存在: {self.config_path_str}"
42 |             raise FileNotFoundError(msg)
   |
help: Convert to lazy `%` formatting

TRY301 Abstract `raise` to an inner function
  --> app/services/accounts_sync/accounts_sync_filters.py:51:17
   |
49 |                 logger.error("配置文件格式错误,缺少 account_filters 节点")
50 |                 msg = "配置文件格式错误,缺少 account_filters 节点"
51 |                 raise ValueError(msg)
   |                 ^^^^^^^^^^^^^^^^^^^^^
52 |
53 |             filter_rules = config["account_filters"] or {}
   |

G004 Logging statement uses f-string
  --> app/services/accounts_sync/accounts_sync_filters.py:54:25
   |
53 |             filter_rules = config["account_filters"] or {}
54 |             logger.info(f"成功加载账户过滤规则配置文件: {self.config_path_str}")
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |             logger.info(f"加载的数据库类型: {list(filter_rules.keys())}")
   |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
  --> app/services/accounts_sync/accounts_sync_filters.py:55:25
   |
53 |             filter_rules = config["account_filters"] or {}
54 |             logger.info(f"成功加载账户过滤规则配置文件: {self.config_path_str}")
55 |             logger.info(f"加载的数据库类型: {list(filter_rules.keys())}")
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
56 |
57 |             return filter_rules
   |
help: Convert to lazy `%` formatting

TRY300 Consider moving this statement to an `else` block
  --> app/services/accounts_sync/accounts_sync_filters.py:57:13
   |
55 |             logger.info(f"加载的数据库类型: {list(filter_rules.keys())}")
56 |
57 |             return filter_rules
   |             ^^^^^^^^^^^^^^^^^^^
58 |
59 |         except yaml.YAMLError as exc:
   |

G004 Logging statement uses f-string
  --> app/services/accounts_sync/accounts_sync_filters.py:60:30
   |
59 |         except yaml.YAMLError as exc:
60 |             logger.exception(f"解析配置文件失败: {exc}")
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |             msg = f"解析配置文件失败: {exc}"
62 |             raise ValueError(msg) from exc
   |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
  --> app/services/accounts_sync/accounts_sync_filters.py:60:43
   |
59 |         except yaml.YAMLError as exc:
60 |             logger.exception(f"解析配置文件失败: {exc}")
   |                                                   ^^^
61 |             msg = f"解析配置文件失败: {exc}"
62 |             raise ValueError(msg) from exc
   |

G004 Logging statement uses f-string
  --> app/services/accounts_sync/accounts_sync_filters.py:64:30
   |
62 |             raise ValueError(msg) from exc
63 |         except Exception as exc:
64 |             logger.exception(f"加载过滤规则配置文件失败: {exc}")
   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
65 |             raise
   |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
  --> app/services/accounts_sync/accounts_sync_filters.py:64:47
   |
62 |             raise ValueError(msg) from exc
63 |         except Exception as exc:
64 |             logger.exception(f"加载过滤规则配置文件失败: {exc}")
   |                                                           ^^^
65 |             raise
   |

G004 Logging statement uses f-string
   --> app/services/accounts_sync/accounts_sync_filters.py:99:30
    |
 97 |             return bool(re.match(regex_pattern, text, re.IGNORECASE))
 98 |         except Exception as exc:
 99 |             logger.exception(f"模式匹配失败: {pattern} -> {text}, 错误: {exc}")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 |             return False
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/services/accounts_sync/accounts_sync_filters.py:99:66
    |
 97 |             return bool(re.match(regex_pattern, text, re.IGNORECASE))
 98 |         except Exception as exc:
 99 |             logger.exception(f"模式匹配失败: {pattern} -> {text}, 错误: {exc}")
    |                                                                          ^^^
100 |             return False
    |

E501 Line too long (144 > 120)
  --> app/services/accounts_sync/accounts_sync_service.py:95:121
   |
93 | …
94 | …
95 | … SyncOperationType.MANUAL_TASK.value, SyncOperationType.SCHEDULED_TASK.value]:
   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^
96 | …
97 | …
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/accounts_sync_service.py:167:13
    |
165 |                 result=result,
166 |             )
167 |             return result
    |             ^^^^^^^^^^^^^
168 |         except Exception as exc:
169 |             self.sync_logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/accounts_sync_service.py:169:30
    |
167 |             return result
168 |         except Exception as exc:
169 |             self.sync_logger.error(
    |                              ^^^^^
170 |                 "单实例同步失败",
171 |                 module="accounts_sync",
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/accounts_sync_service.py:247:13
    |
245 |                 )
246 |
247 |             return result
    |             ^^^^^^^^^^^^^
248 |
249 |         except Exception as e:
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/accounts_sync_service.py:305:13
    |
303 |                 result=result,
304 |             )
305 |             return result
    |             ^^^^^^^^^^^^^
306 |         except Exception as exc:
307 |             db.session.rollback()
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/accounts_sync_service.py:308:30
    |
306 |         except Exception as exc:
307 |             db.session.rollback()
308 |             self.sync_logger.error(
    |                              ^^^^^
309 |                 "现有会话同步失败",
310 |                 module="accounts_sync",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/base_adapter.py:17:69
   |
15 |     """账户同步适配器基类,负责抽象远端账户数据抓取."""
16 |
17 |     def fetch_remote_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                     ^^^
18 |         """拉取远端账户信息.
   |

PERF401 Use a list comprehension to create a transformed list
  --> app/services/accounts_sync/adapters/base_adapter.py:37:13
   |
35 |         normalized: list[dict[str, Any]] = []
36 |         for account in raw_accounts:
37 |             normalized.append(self._normalize_account(instance, account))
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |         return normalized
   |
help: Replace for loop with list comprehension

ARG002 Unused method argument: `instance`
  --> app/services/accounts_sync/adapters/base_adapter.py:42:9
   |
40 |     def enrich_permissions(
41 |         self,
42 |         instance: Instance,
   |         ^^^^^^^^
43 |         connection: Any,
44 |         accounts: list[dict[str, Any]],
   |

ARG002 Unused method argument: `connection`
  --> app/services/accounts_sync/adapters/base_adapter.py:43:9
   |
41 |         self,
42 |         instance: Instance,
43 |         connection: Any,
   |         ^^^^^^^^^^
44 |         accounts: list[dict[str, Any]],
45 |         *,
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/base_adapter.py:43:21
   |
41 |         self,
42 |         instance: Instance,
43 |         connection: Any,
   |                     ^^^
44 |         accounts: list[dict[str, Any]],
45 |         *,
   |

ARG002 Unused method argument: `usernames`
  --> app/services/accounts_sync/adapters/base_adapter.py:46:9
   |
44 |         accounts: list[dict[str, Any]],
45 |         *,
46 |         usernames: Sequence[str] | None = None,
   |         ^^^^^^^^^
47 |     ) -> list[dict[str, Any]]:
48 |         """为账号列表补全权限信息.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/base_adapter.py:67:67
   |
66 |     @abstractmethod
67 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
68 |         """具体数据库实现负责查询账户列表.
   |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/adapters/mysql_adapter.py:37:9
   |
35 |     """
36 |
37 |     def __init__(self) -> None:
   |         ^^^^^^^^
38 |         self.logger = get_sync_logger()
39 |         self.filter_manager = DatabaseFilterManager()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/mysql_adapter.py:44:67
   |
42 |     # BaseAccountAdapter 实现
43 |     # ------------------------------------------------------------------
44 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
45 |         """拉取 MySQL 原始账户信息.
   |

S608 Possible SQL injection vector through string-based query construction
  --> app/services/accounts_sync/adapters/mysql_adapter.py:78:17
   |
76 |               where_clause, params = self._build_filter_conditions()
77 |               user_sql = (
78 | /                 "SELECT "
79 | |                 "    User as username, "
80 | |                 "    Host as host, "
81 | |                 "    Super_priv as is_superuser, "
82 | |                 "    account_locked as is_locked, "
83 | |                 "    Grant_priv as can_grant, "
84 | |                 "    plugin as plugin, "
85 | |                 "    password_last_changed as password_last_changed "
86 | |                 "FROM mysql.user "
87 | |                 f"WHERE User != '' AND {where_clause} "
88 | |                 "ORDER BY User, Host"
   | |_____________________________________^
89 |               )
90 |               users = connection.execute_query(user_sql, params)
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/adapters/mysql_adapter.py:124:13
    |
122 |                 account_count=len(accounts),
123 |             )
124 |             return accounts
    |             ^^^^^^^^^^^^^^^
125 |         except Exception as exc:
126 |             self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:126:25
    |
124 |             return accounts
125 |         except Exception as exc:
126 |             self.logger.error(
    |                         ^^^^^
127 |                 "fetch_mysql_accounts_failed",
128 |                 module="mysql_account_adapter",
    |

ARG002 Unused method argument: `instance`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:135:34
    |
133 |             return []
134 |
135 |     def _normalize_account(self, instance: Instance, account: dict[str, Any]) -> dict[str, Any]:
    |                                  ^^^^^^^^
136 |         """规范化 MySQL 账户信息.
    |

E501 Line too long (136 > 120)
   --> app/services/accounts_sync/adapters/mysql_adapter.py:189:121
    |
187 | …ysql")
188 | …
189 | …_rules.get("exclude_users", []), filter_rules.get("exclude_patterns", []))
    |                                                            ^^^^^^^^^^^^^^^^
190 | …
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:192:49
    |
190 |         return builder.build_where_clause()
191 |
192 |     def _get_user_permissions(self, connection: Any, username: str, host: str) -> dict[str, Any]:
    |                                                 ^^^
193 |         """获取 MySQL 用户权限详情.
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/adapters/mysql_adapter.py:244:13
    |
242 |                       },
243 |                   )
244 | /             return {
245 | |                 "global_privileges": global_privileges,
246 | |                 "database_privileges": database_privileges,
247 | |                 "type_specific": type_specific,
248 | |             }
    | |_____________^
249 |           except Exception as exc:
250 |               self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:250:25
    |
248 |             }
249 |         except Exception as exc:
250 |             self.logger.error(
    |                         ^^^^^
251 |                 "fetch_mysql_permissions_failed",
252 |                 module="mysql_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:267:21
    |
265 |         self,
266 |         instance: Instance,
267 |         connection: Any,
    |                     ^^^
268 |         accounts: list[dict[str, Any]],
269 |         *,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:323:29
    |
321 |                 )
322 |             except Exception as exc:
323 |                 self.logger.error(
    |                             ^^^^^
324 |                     "fetch_mysql_permissions_failed",
325 |                     module="mysql_account_adapter",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:395:16
    |
393 |                     existing.append("GRANT OPTION")
394 |                 return
395 |         except Exception as exc:
    |                ^^^^^^^^^
396 |             self.logger.warning(
397 |                 "mysql_parse_grant_failed",
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/accounts_sync/adapters/mysql_adapter.py:420:38
    |
418 |         return [priv.strip().upper() for priv in privileges_part.split(",") if priv.strip()]
419 |
420 |     def _expand_all_privileges(self, is_global: bool) -> list[str]:
    |                                      ^^^^^^^^^
421 |         """返回 ALL PRIVILEGES 展开的权限列表.
    |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/adapters/oracle_adapter.py:35:9
   |
33 |     """
34 |
35 |     def __init__(self) -> None:
   |         ^^^^^^^^
36 |         self.logger = get_sync_logger()
37 |         self.filter_manager = DatabaseFilterManager()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/oracle_adapter.py:39:67
   |
37 |         self.filter_manager = DatabaseFilterManager()
38 |
39 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
40 |         """拉取 Oracle 原始账户信息.
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/accounts_sync/adapters/oracle_adapter.py:78:13
   |
76 |                 account_count=len(accounts),
77 |             )
78 |             return accounts
   |             ^^^^^^^^^^^^^^^
79 |         except Exception as exc:
80 |             self.logger.error(
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
  --> app/services/accounts_sync/adapters/oracle_adapter.py:80:25
   |
78 |             return accounts
79 |         except Exception as exc:
80 |             self.logger.error(
   |                         ^^^^^
81 |                 "fetch_oracle_accounts_failed",
82 |                 module="oracle_account_adapter",
   |

ARG002 Unused method argument: `instance`
  --> app/services/accounts_sync/adapters/oracle_adapter.py:89:34
   |
87 |             return []
88 |
89 |     def _normalize_account(self, instance: Instance, account: dict[str, Any]) -> dict[str, Any]:
   |                                  ^^^^^^^^
90 |         """规范化 Oracle 账户信息.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:124:40
    |
123 |     # ------------------------------------------------------------------
124 |     def _fetch_users(self, connection: Any) -> list[dict[str, Any]]:
    |                                        ^^^
125 |         """读取 Oracle 用户列表.
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/oracle_adapter.py:139:13
    |
138 |           sql = (
139 | /             "SELECT username, account_status, default_tablespace "
140 | |             "FROM dba_users "
141 | |             f"WHERE username NOT IN ({placeholders})"
    | |_____________________________________________________^
142 |           )
143 |           params = {f":{i+1}": user for i, user in enumerate(exclude_users)}
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/services/accounts_sync/adapters/oracle_adapter.py:147:13
    |
145 |           results: list[dict[str, Any]] = []
146 |           for row in rows:
147 | /             results.append(
148 | |                 {
149 | |                     "username": row[0],
150 | |                     "account_status": row[1],
151 | |                     "default_tablespace": row[2],
152 | |                     "is_dba": row[0] == "SYS",
153 | |                 },
154 | |             )
    | |_____________^
155 |           return results
    |
help: Replace for loop with list comprehension

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:157:49
    |
155 |         return results
156 |
157 |     def _get_user_permissions(self, connection: Any, username: str) -> dict[str, Any]:
    |                                                 ^^^
158 |         """查询单个用户的权限快照.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:178:21
    |
176 |         self,
177 |         instance: Instance,
178 |         connection: Any,
    |                     ^^^
179 |         accounts: list[dict[str, Any]],
180 |         *,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:215:29
    |
213 |                     account["is_locked"] = account_status.upper() != "OPEN"
214 |             except Exception as exc:
215 |                 self.logger.error(
    |                             ^^^^^
216 |                     "fetch_oracle_permissions_failed",
217 |                     module="oracle_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:233:38
    |
231 |         return accounts
232 |
233 |     def _get_roles(self, connection: Any, username: str) -> list[str]:
    |                                      ^^^
234 |         """查询用户拥有的角色.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:248:50
    |
246 |         return [row[0] for row in rows if row and row[0]]
247 |
248 |     def _get_system_privileges(self, connection: Any, username: str) -> list[str]:
    |                                                  ^^^
249 |         """查询用户拥有的系统权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:263:54
    |
261 |         return [row[0] for row in rows if row and row[0]]
262 |
263 |     def _get_tablespace_privileges(self, connection: Any, username: str) -> dict[str, dict[str, Any]]:
    |                                                      ^^^
264 |         """查询用户的表空间配额信息.
    |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/adapters/postgresql_adapter.py:36:9
   |
34 |     """
35 |
36 |     def __init__(self) -> None:
   |         ^^^^^^^^
37 |         self.logger = get_sync_logger()
38 |         self.filter_manager = DatabaseFilterManager()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/postgresql_adapter.py:40:67
   |
38 |         self.filter_manager = DatabaseFilterManager()
39 |
40 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
41 |         """拉取 PostgreSQL 原始账户信息.
   |

S608 Possible SQL injection vector through string-based query construction
  --> app/services/accounts_sync/adapters/postgresql_adapter.py:56:17
   |
54 |               where_clause, params = self._build_filter_conditions()
55 |               roles_sql = (
56 | /                 "SELECT "
57 | |                 "    rolname as username, "
58 | |                 "    rolsuper as is_superuser, "
59 | |                 "    rolcreaterole as can_create_role, "
60 | |                 "    rolcreatedb as can_create_db, "
61 | |                 "    rolreplication as can_replicate, "
62 | |                 "    rolbypassrls as can_bypass_rls, "
63 | |                 "    rolcanlogin as can_login, "
64 | |                 "    rolinherit as can_inherit, "
65 | |                 "    CASE "
66 | |                 "        WHEN rolvaliduntil = 'infinity'::timestamp THEN NULL "
67 | |                 "        WHEN rolvaliduntil = '-infinity'::timestamp THEN NULL "
68 | |                 "        ELSE rolvaliduntil "
69 | |                 "    END as valid_until "
70 | |                 "FROM pg_roles "
71 | |                 f"WHERE {where_clause} "
72 | |                 "ORDER BY rolname"
   | |__________________________________^
73 |               )
74 |               rows = connection.execute_query(roles_sql, params)
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:124:13
    |
122 |                 account_count=len(accounts),
123 |             )
124 |             return accounts
    |             ^^^^^^^^^^^^^^^
125 |         except Exception as exc:
126 |             self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:126:25
    |
124 |             return accounts
125 |         except Exception as exc:
126 |             self.logger.error(
    |                         ^^^^^
127 |                 "fetch_postgresql_accounts_failed",
128 |                 module="postgresql_account_adapter",
    |

ARG002 Unused method argument: `instance`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:135:34
    |
133 |             return []
134 |
135 |     def _normalize_account(self, instance: Instance, account: dict[str, Any]) -> dict[str, Any]:
    |                                  ^^^^^^^^
136 |         """规范化 PostgreSQL 账户信息.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:192:21
    |
190 |     def _get_role_permissions(
191 |         self,
192 |         connection: Any,
    |                     ^^^
193 |         username: str,
194 |         *,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:218:16
    |
216 |         try:
217 |             permissions["role_attributes"] = self._get_role_attributes(connection, username)
218 |         except Exception as exc:
    |                ^^^^^^^^^
219 |             self.logger.warning(
220 |                 "fetch_pg_role_attributes_failed",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:227:16
    |
225 |         try:
226 |             permissions["predefined_roles"] = self._get_predefined_roles(connection, username)
227 |         except Exception as exc:
    |                ^^^^^^^^^
228 |             self.logger.warning(
229 |                 "fetch_pg_predefined_roles_failed",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:236:16
    |
234 |         try:
235 |             permissions["database_privileges_pg"] = self._get_database_privileges(connection, username)
236 |         except Exception as exc:
    |                ^^^^^^^^^
237 |             self.logger.warning(
238 |                 "fetch_pg_database_privileges_failed",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:245:16
    |
243 |         try:
244 |             permissions["tablespace_privileges"] = self._get_tablespace_privileges(connection, username)
245 |         except Exception as exc:
    |                ^^^^^^^^^
246 |             self.logger.warning(
247 |                 "fetch_pg_tablespace_privileges_failed",
    |

C901 `enrich_permissions` is too complex (13 > 10)
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:256:9
    |
254 |         return permissions
255 |
256 |     def enrich_permissions(
    |         ^^^^^^^^^^^^^^^^^^
257 |         self,
258 |         instance: Instance,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:259:21
    |
257 |         self,
258 |         instance: Instance,
259 |         connection: Any,
    |                     ^^^
260 |         accounts: list[dict[str, Any]],
261 |         *,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:326:29
    |
324 |                 account["is_locked"] = not can_login
325 |             except Exception as exc:
326 |                 self.logger.error(
    |                             ^^^^^
327 |                     "fetch_pg_permissions_failed",
328 |                     module="postgresql_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:345:48
    |
344 |     # 以下辅助查询函数沿用旧实现
345 |     def _get_role_attributes(self, connection: Any, username: str) -> dict[str, Any]:
    |                                                ^^^
346 |         """查询角色属性.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:374:49
    |
372 |         }
373 |
374 |     def _get_predefined_roles(self, connection: Any, username: str) -> list[str]:
    |                                                 ^^^
375 |         """查询用户所属的预定义角色.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:394:52
    |
392 |         return [row[0] for row in rows if row and row[0]]
393 |
394 |     def _get_database_privileges(self, connection: Any, username: str) -> dict[str, list[str]]:
    |                                                    ^^^
395 |         """查询用户在各数据库上的权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:432:54
    |
430 |         return privileges
431 |
432 |     def _get_tablespace_privileges(self, connection: Any, username: str) -> dict[str, list[str]]:
    |                                                      ^^^
433 |         """查询用户在各表空间上的权限.
    |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:39:9
   |
37 |     """
38 |
39 |     def __init__(self) -> None:
   |         ^^^^^^^^
40 |         self.logger = get_sync_logger()
41 |         self.filter_manager = DatabaseFilterManager()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:43:67
   |
41 |         self.filter_manager = DatabaseFilterManager()
42 |
43 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
44 |         """拉取 SQL Server 原始账户信息.
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:81:13
   |
79 |                 account_count=len(accounts),
80 |             )
81 |             return accounts
   |             ^^^^^^^^^^^^^^^
82 |         except Exception as exc:
83 |             self.logger.error(
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:83:25
   |
81 |             return accounts
82 |         except Exception as exc:
83 |             self.logger.error(
   |                         ^^^^^
84 |                 "fetch_sqlserver_accounts_failed",
85 |                 module="sqlserver_account_adapter",
   |

ARG002 Unused method argument: `instance`
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:92:34
   |
90 |             return []
91 |
92 |     def _normalize_account(self, instance: Instance, account: dict[str, Any]) -> dict[str, Any]:
   |                                  ^^^^^^^^
93 |         """规范化 SQL Server 账户信息.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:131:21
    |
129 |         self,
130 |         instance: Instance,
131 |         connection: Any,
    |                     ^^^
132 |         accounts: list[dict[str, Any]],
133 |         *,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:192:29
    |
190 |                 account["is_locked"] = bool(type_specific.get("is_disabled", False))
191 |             except Exception as exc:
192 |                 self.logger.error(
    |                             ^^^^^
193 |                     "fetch_sqlserver_permissions_failed",
194 |                     module="sqlserver_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:213:41
    |
211 |     # 查询逻辑来源于旧实现
212 |     # ------------------------------------------------------------------
213 |     def _fetch_logins(self, connection: Any) -> list[dict[str, Any]]:
    |                                         ^^^
214 |         """查询服务器登录账户.
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:287:9
    |
285 |         return compiled
286 |
287 |     def _get_login_permissions(
    |         ^^^^^^^^^^^^^^^^^^^^^^
288 |         self,
289 |         connection: Any,
    |

ARG002 Unused method argument: `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:289:9
    |
287 |     def _get_login_permissions(
288 |         self,
289 |         connection: Any,
    |         ^^^^^^^^^^
290 |         login_name: str,
291 |         *,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:289:21
    |
287 |     def _get_login_permissions(
288 |         self,
289 |         connection: Any,
    |                     ^^^
290 |         login_name: str,
291 |         *,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:403:50
    |
401 |         return copied
402 |
403 |     def _get_server_roles_bulk(self, connection: Any, usernames: Sequence[str]) -> dict[str, list[str]]:
    |                                                  ^^^
404 |         """批量查询服务器角色.
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:419:15
    |
418 |           placeholders = ", ".join(["%s"] * len(normalized))
419 |           sql = f"""
    |  _______________^
420 | |             SELECT member.name AS login_name, role.name AS role_name
421 | |             FROM sys.server_role_members rm
422 | |             JOIN sys.server_principals role ON rm.role_principal_id = role.principal_id
423 | |             JOIN sys.server_principals member ON rm.member_principal_id = member.principal_id
424 | |             WHERE member.name IN ({placeholders})
425 | |         """
    | |___________^
426 |           rows = connection.execute_query(sql, tuple(normalized))
427 |           result: dict[str, list[str]] = {}
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:436:56
    |
434 |         return result
435 |
436 |     def _get_server_permissions_bulk(self, connection: Any, usernames: Sequence[str]) -> dict[str, list[str]]:
    |                                                        ^^^
437 |         """批量查询服务器权限.
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:452:15
    |
451 |           placeholders = ", ".join(["%s"] * len(normalized))
452 |           sql = f"""
    |  _______________^
453 | |             SELECT sp.name AS login_name, perm.permission_name
454 | |             FROM sys.server_permissions perm
455 | |             JOIN sys.server_principals sp ON perm.grantee_principal_id = sp.principal_id
456 | |             WHERE sp.name IN ({placeholders})
457 | |         """
    | |___________^
458 |           rows = connection.execute_query(sql, tuple(normalized))
459 |           result: dict[str, list[str]] = {}
    |

C901 `_get_all_users_database_permissions_batch` is too complex (32 > 10)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:468:9
    |
466 |         return result
467 |
468 |     def _get_all_users_database_permissions_batch(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
469 |         self,
470 |         connection: Any,
    |

PLR0912 Too many branches (31 > 12)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:468:9
    |
466 |         return result
467 |
468 |     def _get_all_users_database_permissions_batch(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
469 |         self,
470 |         connection: Any,
    |

PLR0915 Too many statements (88 > 50)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:468:9
    |
466 |         return result
467 |
468 |     def _get_all_users_database_permissions_batch(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
469 |         self,
470 |         connection: Any,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:470:21
    |
468 |     def _get_all_users_database_permissions_batch(
469 |         self,
470 |         connection: Any,
    |                     ^^^
471 |         usernames: Sequence[str],
472 |     ) -> dict[str, dict[str, Any]]:
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:512:30
    |
510 |               unique_usernames = list(dict.fromkeys(usernames))
511 |               placeholders = ", ".join(["%s"] * len(unique_usernames))
512 |               login_sids_sql = f"""
    |  ______________________________^
513 | |                 SELECT name, sid
514 | |                 FROM sys.server_principals
515 | |                 WHERE name IN ({placeholders})
516 | |                   AND type IN ('S', 'U', 'G')
517 | |             """
    | |_______________^
518 |               login_rows = connection.execute_query(login_sids_sql, tuple(unique_usernames))
519 |               sid_to_logins: dict[bytes, list[str]] = {}
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:543:21
    |
541 |                   quoted_db = self._quote_identifier(db)
542 |                   principals_parts.append(
543 | /                     f"""
544 | |                     SELECT '{db}' AS db_name,
545 | |                            name COLLATE SQL_Latin1_General_CP1_CI_AS AS user_name,
546 | |                            principal_id,
547 | |                            sid
548 | |                     FROM {quoted_db}.sys.database_principals
549 | |                     WHERE type IN ('S', 'U', 'G')
550 | |                       AND name != 'dbo'
551 | |                       AND sid IN ({sid_filter})
552 | |                     """,
    | |_______________________^
553 |                   )
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:556:21
    |
555 |                   roles_parts.append(
556 | /                     f"""
557 | |                     SELECT '{db}' AS db_name,
558 | |                            role.name COLLATE SQL_Latin1_General_CP1_CI_AS AS role_name,
559 | |                            member.principal_id AS member_principal_id
560 | |                     FROM {quoted_db}.sys.database_role_members drm
561 | |                     JOIN {quoted_db}.sys.database_principals role
562 | |                       ON drm.role_principal_id = role.principal_id
563 | |                     JOIN {quoted_db}.sys.database_principals member
564 | |                       ON drm.member_principal_id = member.principal_id
565 | |                     WHERE member.sid IN ({sid_filter})
566 | |                     """,
    | |_______________________^
567 |                   )
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:570:21
    |
569 |   …     perms_parts.append(
570 | / …         f"""
571 | | …         SELECT '{db}' AS db_name,
572 | | …                perm.permission_name COLLATE SQL_Latin1_General_CP1_CI_AS AS permission_name,
573 | | …                perm.grantee_principal_id,
574 | | …                perm.major_id,
575 | | …                perm.minor_id,
576 | | …                CASE
577 | | …                    WHEN perm.class_desc = 'DATABASE' THEN 'DATABASE'
578 | | …                    WHEN perm.class_desc = 'SCHEMA' THEN 'SCHEMA'
579 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' AND perm.minor_id = 0 THEN 'OBJECT'
580 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' AND perm.minor_id > 0 THEN 'COLUMN'
581 | | …                    ELSE perm.class_desc
582 | | …                END AS permission_scope,
583 | | …                CASE
584 | | …                    WHEN perm.class_desc = 'SCHEMA' THEN SCHEMA_NAME(perm.major_id)
585 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' THEN OBJECT_SCHEMA_NAME(perm.major_id)
586 | | …                    ELSE NULL
587 | | …                END AS schema_name,
588 | | …                CASE
589 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' THEN OBJECT_NAME(perm.major_id)
590 | | …                    ELSE NULL
591 | | …                END AS object_name,
592 | | …                CASE
593 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' AND perm.minor_id > 0 THEN COL_NAME(perm.major_id, perm.minor_id)
594 | | …                    ELSE NULL
595 | | …                END AS column_name
596 | | …         FROM {quoted_db}.sys.database_permissions perm
597 | | …         JOIN {quoted_db}.sys.database_principals dp
598 | | …           ON perm.grantee_principal_id = dp.principal_id
599 | | …         WHERE perm.state = 'G'
600 | | …           AND dp.sid IN ({sid_filter})
601 | | …         """,
    | |_____________^
602 |   …     )
    |

E501 Line too long (138 > 120)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:593:121
    |
591 | …                     END AS object_name,
592 | …                     CASE
593 | …                         WHEN perm.class_desc = 'OBJECT_OR_COLUMN' AND perm.minor_id > 0 THEN COL_NAME(perm.major_id, perm.minor_id)
    |                                                                                                                    ^^^^^^^^^^^^^^^^^^
594 | …                         ELSE NULL
595 | …                     END AS column_name
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:701:13
    |
699 |             )
700 |
701 |             return result
    |             ^^^^^^^^^^^^^
702 |         except Exception as exc:
703 |             self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:703:25
    |
701 |             return result
702 |         except Exception as exc:
703 |             self.logger.error(
    |                         ^^^^^
704 |                 "sqlserver_batch_database_permissions_failed",
705 |                 module="sqlserver_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `raw_sid`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:712:33
    |
711 |     @staticmethod
712 |     def _normalize_sid(raw_sid: Any) -> bytes | None:
    |                                 ^^^
713 |         """标准化 SID 字节串.
    |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/coordinator.py:39:9
   |
37 |     """
38 |
39 |     def __init__(self, instance: Instance) -> None:
   |         ^^^^^^^^
40 |         self.instance = instance
41 |         self.logger = get_sync_logger()
   |

ANN001 Missing type annotation for function argument `exc_type`
  --> app/services/accounts_sync/coordinator.py:71:24
   |
69 |         return self
70 |
71 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                        ^^^^^^^^
72 |         """退出上下文时释放连接资源.
   |

ANN001 Missing type annotation for function argument `exc_val`
  --> app/services/accounts_sync/coordinator.py:71:34
   |
69 |         return self
70 |
71 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                                  ^^^^^^^
72 |         """退出上下文时释放连接资源.
   |

ANN001 Missing type annotation for function argument `exc_tb`
  --> app/services/accounts_sync/coordinator.py:71:43
   |
69 |         return self
70 |
71 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                                           ^^^^^^
72 |         """退出上下文时释放连接资源.
   |

PLR0911 Too many return statements (7 > 6)
  --> app/services/accounts_sync/coordinator.py:85:9
   |
83 |         self.disconnect()
84 |
85 |     def connect(self) -> bool:
   |         ^^^^^^^
86 |         """建立到数据库实例的连接.
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/coordinator.py:111:25
    |
109 |             self._connection_failed = True
110 |             self._connection_error = str(exc)
111 |             self.logger.error(
    |                         ^^^^^
112 |                 "accounts_sync_connection_init_failed",
113 |                 instance_id=self.instance.id,
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/coordinator.py:156:13
    |
154 |                 module=MODULE,
155 |             )
156 |             return False
    |             ^^^^^^^^^^^^
157 |         except Exception as exc:
158 |             self._connection_failed = True
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/coordinator.py:160:25
    |
158 |             self._connection_failed = True
159 |             self._connection_error = str(exc)
160 |             self.logger.error(
    |                         ^^^^^
161 |                 "accounts_sync_connection_exception",
162 |                 instance_id=self.instance.id,
    |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> app/services/accounts_sync/coordinator.py:200:9
    |
199 |           """
200 | /         if not self._connection or not getattr(self._connection, "is_connected", False):
201 | |             if not self.connect():
    | |__________________________________^
202 |                   error_message = self._connection_error or "数据库连接未建立"
203 |                   raise RuntimeError(error_message)
    |
help: Combine `if` statements using `and`

E501 Line too long (122 > 120)
   --> app/services/accounts_sync/coordinator.py:356:121
    |
354 |         active_usernames = [account.username for account in active_accounts if getattr(account, "username", None)]
355 |         enriched_usernames = getattr(self, "_enriched_usernames", set())
356 |         pending_usernames = [username for username in active_usernames if username and username not in enriched_usernames]
    |                                                                                                                         ^^
357 |         if pending_usernames:
358 |             self._ensure_connection()
    |

E501 Line too long (121 > 120)
   --> app/services/accounts_sync/coordinator.py:394:121
    |
392 |             "updated": summary.get("updated", 0),
393 |             "skipped": summary.get("skipped", 0),
394 |             "processed_records": summary.get("processed_records", summary.get("created", 0) + summary.get("updated", 0)),
    |                                                                                                                         ^
395 |             "errors": summary.get("errors", []),
396 |             "message": summary.get("message"),
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/inventory_manager.py:128:25
    |
126 |         except Exception as exc:
127 |             db.session.rollback()
128 |             self.logger.error(
    |                         ^^^^^
129 |                 "account_inventory_sync_commit_failed",
130 |                 instance=instance.name,
    |

C901 `synchronize` is too complex (11 > 10)
  --> app/services/accounts_sync/permission_manager.py:96:9
   |
94 |         self.logger = get_sync_logger()
95 |
96 |     def synchronize(
   |         ^^^^^^^^^^^
97 |         self,
98 |         instance: Instance,
   |

PLR0915 Too many statements (62 > 50)
  --> app/services/accounts_sync/permission_manager.py:96:9
   |
94 |         self.logger = get_sync_logger()
95 |
96 |     def synchronize(
   |         ^^^^^^^^^^^
97 |         self,
98 |         instance: Instance,
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/permission_manager.py:233:25
    |
231 |         except SQLAlchemyError as exc:
232 |             db.session.rollback()
233 |             self.logger.error(
    |                         ^^^^^
234 |                 "account_permission_sync_commit_failed",
235 |                 instance=instance.name,
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/accounts_sync/permission_manager.py:288:9
    |
286 |         record: AccountPermission,
287 |         permissions: dict,
288 |         is_superuser: bool,
    |         ^^^^^^^^^^^^
289 |         is_locked: bool,
290 |     ) -> None:
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/accounts_sync/permission_manager.py:289:9
    |
287 |         permissions: dict,
288 |         is_superuser: bool,
289 |         is_locked: bool,
    |         ^^^^^^^^^
290 |     ) -> None:
291 |         """将权限快照写入账户记录.
    |

C901 `_calculate_diff` is too complex (11 > 10)
   --> app/services/accounts_sync/permission_manager.py:314:9
    |
312 |                 setattr(record, field, None)
313 |
314 |     def _calculate_diff(
    |         ^^^^^^^^^^^^^^^
315 |         self,
316 |         record: AccountPermission,
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/accounts_sync/permission_manager.py:318:9
    |
316 |         record: AccountPermission,
317 |         permissions: dict,
318 |         is_superuser: bool,
    |         ^^^^^^^^^^^^
319 |         is_locked: bool,
320 |     ) -> dict[str, Any]:
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/accounts_sync/permission_manager.py:319:9
    |
317 |         permissions: dict,
318 |         is_superuser: bool,
319 |         is_locked: bool,
    |         ^^^^^^^^^
320 |     ) -> dict[str, Any]:
321 |         """计算新旧权限之间的差异.
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/accounts_sync/permission_manager.py:431:9
    |
429 |         self,
430 |         permissions: dict[str, Any],
431 |         is_superuser: bool,
    |         ^^^^^^^^^^^^
432 |         is_locked: bool,
433 |     ) -> dict[str, Any]:
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/accounts_sync/permission_manager.py:432:9
    |
430 |         permissions: dict[str, Any],
431 |         is_superuser: bool,
432 |         is_locked: bool,
    |         ^^^^^^^^^
433 |     ) -> dict[str, Any]:
434 |         """构建新账户的权限差异初始结构.
    |

FBT003 Boolean positional value in function call
   --> app/services/accounts_sync/permission_manager.py:453:72
    |
451 |         other_diff: list[dict[str, Any]] = []
452 |         if is_superuser:
453 |             other_entry = self._build_other_diff_entry("is_superuser", False, True)
    |                                                                        ^^^^^
454 |             if other_entry:
455 |                 other_diff.append(other_entry)
    |

FBT003 Boolean positional value in function call
   --> app/services/accounts_sync/permission_manager.py:453:79
    |
451 |         other_diff: list[dict[str, Any]] = []
452 |         if is_superuser:
453 |             other_entry = self._build_other_diff_entry("is_superuser", False, True)
    |                                                                               ^^^^
454 |             if other_entry:
455 |                 other_diff.append(other_entry)
    |

FBT003 Boolean positional value in function call
   --> app/services/accounts_sync/permission_manager.py:457:70
    |
455 |                 other_diff.append(other_entry)
456 |         if is_locked:
457 |             locked_entry = self._build_other_diff_entry("is_locked", False, True)
    |                                                                      ^^^^^
458 |             if locked_entry:
459 |                 other_diff.append(locked_entry)
    |

FBT003 Boolean positional value in function call
   --> app/services/accounts_sync/permission_manager.py:457:77
    |
455 |                 other_diff.append(other_entry)
456 |         if is_locked:
457 |             locked_entry = self._build_other_diff_entry("is_locked", False, True)
    |                                                                             ^^^^
458 |             if locked_entry:
459 |                 other_diff.append(locked_entry)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `old_value`
   --> app/services/accounts_sync/permission_manager.py:474:20
    |
472 |         self,
473 |         field: str,
474 |         old_value: Any,
    |                    ^^^
475 |         new_value: Any,
476 |     ) -> list[dict[str, Any]]:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `new_value`
   --> app/services/accounts_sync/permission_manager.py:475:20
    |
473 |         field: str,
474 |         old_value: Any,
475 |         new_value: Any,
    |                    ^^^
476 |     ) -> list[dict[str, Any]]:
477 |         """比较权限字段并返回差异条目.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `old_value`
   --> app/services/accounts_sync/permission_manager.py:579:20
    |
577 |         self,
578 |         field: str,
579 |         old_value: Any,
    |                    ^^^
580 |         new_value: Any,
581 |     ) -> dict[str, Any] | None:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `new_value`
   --> app/services/accounts_sync/permission_manager.py:580:20
    |
578 |         field: str,
579 |         old_value: Any,
580 |         new_value: Any,
    |                    ^^^
581 |     ) -> dict[str, Any] | None:
582 |         """构建非权限字段的差异条目.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `old_value`
   --> app/services/accounts_sync/permission_manager.py:606:63
    |
604 |         }
605 |
606 |     def _build_other_description(self, label: str, old_value: Any, new_value: Any) -> str:
    |                                                               ^^^
607 |         """生成非权限字段差异的自然语言描述.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `new_value`
   --> app/services/accounts_sync/permission_manager.py:606:79
    |
604 |         }
605 |
606 |     def _build_other_description(self, label: str, old_value: Any, new_value: Any) -> str:
    |                                                                               ^^^
607 |         """生成非权限字段差异的自然语言描述.
    |

C901 `_build_change_summary` is too complex (11 > 10)
   --> app/services/accounts_sync/permission_manager.py:628:9
    |
626 |         return f"{label} 已更新"
627 |
628 |     def _build_change_summary(
    |         ^^^^^^^^^^^^^^^^^^^^^
629 |         self,
630 |         username: str,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/accounts_sync/permission_manager.py:681:28
    |
680 |     @staticmethod
681 |     def _is_mapping(value: Any) -> bool:
    |                            ^^^
682 |         """判断值是否为映射类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/accounts_sync/permission_manager.py:694:35
    |
693 |     @staticmethod
694 |     def _normalize_mapping(value: Any) -> dict[str, set]:
    |                                   ^^^
695 |         """将权限映射标准化为 {str: set} 结构.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/accounts_sync/permission_manager.py:712:36
    |
711 |     @staticmethod
712 |     def _normalize_sequence(value: Any) -> set:
    |                                    ^^^
713 |         """将单值或序列转换为集合形式.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/accounts_sync/permission_manager.py:729:28
    |
728 |     @staticmethod
729 |     def _repr_value(value: Any) -> str:
    |                            ^^^
730 |         """将值转换为日志友好的文本.
    |

ARG002 Unused method argument: `target_date`
  --> app/services/aggregation/aggregation_service.py:94:42
   |
92 |         return instance
93 |
94 |     def _ensure_partition_for_date(self, target_date: date) -> None:
   |                                          ^^^^^^^^^^^
95 |         """保留接口,当前环境无需分区预处理.
   |

ANN001 Missing type annotation for function argument `aggregation`
   --> app/services/aggregation/aggregation_service.py:106:44
    |
104 |         return
105 |
106 |     def _commit_with_partition_retry(self, aggregation, start_date: date) -> None:
    |                                            ^^^^^^^^^^^
107 |         """提交聚合记录,移除分区重试逻辑.
    |

ARG002 Unused method argument: `aggregation`
   --> app/services/aggregation/aggregation_service.py:106:44
    |
104 |         return
105 |
106 |     def _commit_with_partition_retry(self, aggregation, start_date: date) -> None:
    |                                            ^^^^^^^^^^^
107 |         """提交聚合记录,移除分区重试逻辑.
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/aggregation/aggregation_service.py:152:61
    |
150 |         return (period_type or "").lower() == "daily"
151 |
152 |     def _resolve_use_current_period(self, period_type: str, override: bool | None = None) -> bool:
    |                                                             ^^^^^^^^
153 |         """结合覆盖配置判断是否使用当前周期."""
154 |         if override is not None:
    |

ANN001 Missing type annotation for function argument `runner`
   --> app/services/aggregation/aggregation_service.py:255:9
    |
253 |         self,
254 |         *,
255 |         runner,
    |         ^^^^^^
256 |         period_type: str,
257 |         use_current_period: bool,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/aggregation_service.py:325:20
    |
323 |             try:
324 |                 period_result = method(use_current_period=use_current)
325 |             except Exception as exc:  # pragma: no cover - 防御性日志
    |                    ^^^^^^^^^
326 |                 log_error(
327 |                     "数据库级聚合执行失败",
    |

E501 Line too long (121 > 120)
   --> app/services/aggregation/aggregation_service.py:375:121
    |
374 |         failed_periods = [
375 |             period for period, result in period_results.items() if result.get("status") == AggregationStatus.FAILED.value
    |                                                                                                                         ^
376 |         ]
377 |         failed_instance_periods = [
    |

C901 `aggregate_current_period` is too complex (11 > 10)
   --> app/services/aggregation/aggregation_service.py:444:9
    |
442 |         )
443 |
444 |     def aggregate_current_period(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
445 |         self,
446 |         period_type: str = "daily",
    |

C901 `calculate_instance_aggregations` is too complex (11 > 10)
   --> app/services/aggregation/aggregation_service.py:681:9
    |
679 |         )
680 |
681 |     def calculate_instance_aggregations(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
682 |         self,
683 |         instance_id: int,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/aggregation_service.py:726:20
    |
724 |             try:
725 |                 result = func(instance_id, use_current_period=use_current_period)
726 |             except Exception as exc:  # pragma: no cover - 防御性日志
    |                    ^^^^^^^^^
727 |                 log_error(
728 |                     "实例周期聚合执行失败",
    |

ANN001 Missing type annotation for function argument `now_func`
  --> app/services/aggregation/calculator.py:23:24
   |
21 |     """
22 |
23 |     def __init__(self, now_func=None) -> None:
   |                        ^^^^^^^^
24 |         """初始化周期计算器.
   |

ANN002 Missing type annotation for `*args`
  --> app/services/aggregation/database_aggregation_runner.py:62:70
   |
60 |         self._module = module
61 |
62 |     def _invoke_callback(self, callback: Callable[..., None] | None, *args) -> None:
   |                                                                      ^^^^^
63 |         """安全执行回调.
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/aggregation/database_aggregation_runner.py:77:16
   |
75 |         try:
76 |             callback(*args)
77 |         except Exception as exc:  # pragma: no cover - 防御性处理
   |                ^^^^^^^^^
78 |             log_warning(
79 |                 "聚合回调执行失败",
   |

PLR0913 Too many arguments in function definition (6 > 5)
  --> app/services/aggregation/database_aggregation_runner.py:85:9
   |
83 |             )
84 |
85 |     def aggregate_period(
   |         ^^^^^^^^^^^^^^^^
86 |         self,
87 |         period_type: str,
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/database_aggregation_runner.py:187:20
    |
185 |                 }
186 |                 self._invoke_callback(on_instance_complete, instance, result_payload)
187 |             except Exception as exc:  # pragma: no cover - 防御性日志
    |                    ^^^^^^^^^
188 |                 db.session.rollback()
189 |                 summary.failed_instances += 1
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> app/services/aggregation/database_aggregation_runner.py:366:9
    |
364 |         return grouped
365 |
366 |     def _persist_database_aggregation(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
367 |         self,
368 |         *,
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/services/aggregation/database_aggregation_runner.py:503:9
    |
501 |             ) from exc
502 |
503 |     def _apply_change_statistics(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
504 |         self,
505 |         *,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/database_aggregation_runner.py:583:16
    |
581 |             aggregation.log_size_change_percent = None
582 |             aggregation.growth_rate = aggregation.size_change_percent
583 |         except Exception as exc:  # pragma: no cover - 防御性日志
    |                ^^^^^^^^^
584 |             log_error(
585 |                 "计算数据库增量统计失败,使用默认值",
    |

ANN002 Missing type annotation for `*args`
  --> app/services/aggregation/instance_aggregation_runner.py:62:70
   |
60 |         self._module = module
61 |
62 |     def _invoke_callback(self, callback: Callable[..., None] | None, *args) -> None:
   |                                                                      ^^^^^
63 |         """安全地执行回调.
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/aggregation/instance_aggregation_runner.py:77:16
   |
75 |         try:
76 |             callback(*args)
77 |         except Exception as exc:  # pragma: no cover
   |                ^^^^^^^^^
78 |             log_warning(
79 |                 "聚合回调执行失败",
   |

PLR0913 Too many arguments in function definition (6 > 5)
  --> app/services/aggregation/instance_aggregation_runner.py:85:9
   |
83 |             )
84 |
85 |     def aggregate_period(
   |         ^^^^^^^^^^^^^^^^
86 |         self,
87 |         period_type: str,
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/instance_aggregation_runner.py:182:20
    |
180 |                 }
181 |                 self._invoke_callback(on_instance_complete, instance, result_payload)
182 |             except Exception as exc:  # pragma: no cover - 防御性日志
    |                    ^^^^^^^^^
183 |                 db.session.rollback()
184 |                 summary.failed_instances += 1
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/services/aggregation/instance_aggregation_runner.py:315:9
    |
313 |         ).all()
314 |
315 |     def _persist_instance_aggregation(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
316 |         self,
317 |         *,
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> app/services/aggregation/instance_aggregation_runner.py:519:56
    |
517 |             aggregation.growth_rate = aggregation.total_size_change_percent
518 |
519 |             if aggregation.total_size_change_percent > 5:
    |                                                        ^
520 |                 aggregation.trend_direction = "growing"
521 |             elif aggregation.total_size_change_percent < -5:
    |

PLR2004 Magic value used in comparison, consider replacing `-5` with a constant variable
   --> app/services/aggregation/instance_aggregation_runner.py:521:58
    |
519 |             if aggregation.total_size_change_percent > 5:
520 |                 aggregation.trend_direction = "growing"
521 |             elif aggregation.total_size_change_percent < -5:
    |                                                          ^^
522 |                 aggregation.trend_direction = "shrinking"
523 |             else:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/instance_aggregation_runner.py:525:16
    |
523 |             else:
524 |                 aggregation.trend_direction = "stable"
525 |         except Exception as exc:  # pragma: no cover - defensive logging
    |                ^^^^^^^^^
526 |             log_error(
527 |                 "计算实例增量统计失败,使用默认值",
    |

D107 Missing docstring in `__init__`
  --> app/services/cache_service.py:27:9
   |
25 |     """
26 |
27 |     def __init__(self, cache: Cache = None) -> None:
   |         ^^^^^^^^
28 |         self.cache = cache
29 |         self.default_ttl = Config.CACHE_DEFAULT_TTL  # 7天,按用户要求
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:100:16
    |
 98 |             info = self.cache.cache.info() if hasattr(self.cache.cache, "info") else "未获取到缓存详情"
 99 |             result = {"status": "connected", "info": info}
100 |         except Exception as exc:
    |                ^^^^^^^^^
101 |             result = {"status": "error", "error": str(exc)}
102 |         return result
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:132:16
    |
130 |                 )
131 |                 result = data.get("result")
132 |         except Exception as exc:
    |                ^^^^^^^^^
133 |             logger.warning(
134 |                 "获取规则评估缓存失败",
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/cache_service.py:141:72
    |
139 |         return result
140 |
141 |     def set_rule_evaluation_cache(self, rule_id: int, account_id: int, result: bool, ttl: int | None = None) -> bool:
    |                                                                        ^^^^^^
142 |         """设置规则评估缓存.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:177:16
    |
175 |             )
176 |             success = True
177 |         except Exception as exc:
    |                ^^^^^^^^^
178 |             logger.warning(
179 |                 "设置规则评估缓存失败",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:205:16
    |
203 |                 logger.debug("分类规则缓存命中", cache_key=cache_key)
204 |                 result = data
205 |         except Exception as exc:
    |                ^^^^^^^^^
206 |             logger.warning("获取分类规则缓存失败", error=str(exc))
207 |         return result
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:236:16
    |
234 |             logger.debug("分类规则缓存已设置", cache_key=cache_key, ttl=ttl, count=len(rules))
235 |             success = True
236 |         except Exception as exc:
    |                ^^^^^^^^^
237 |             logger.warning("设置分类规则缓存失败", error=str(exc))
238 |         return success
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:259:16
    |
257 |             logger.info("清除账户缓存", account_id=account_id)
258 |             success = True
259 |         except Exception as exc:
    |                ^^^^^^^^^
260 |             logger.warning("清除账户缓存失败", account_id=account_id, error=str(exc))
261 |         return success
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:280:16
    |
278 |             logger.info("清除分类缓存")
279 |             success = True
280 |         except Exception as exc:
    |                ^^^^^^^^^
281 |             logger.warning("清除分类缓存失败", error=str(exc))
282 |         return success
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:298:16
    |
296 |             logger.info("清除所有规则评估缓存")
297 |             success = True
298 |         except Exception as exc:
    |                ^^^^^^^^^
299 |             logger.warning("清除所有规则评估缓存失败", error=str(exc))
300 |         return success
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:340:16
    |
338 |                 else:
339 |                     logger.warning("数据库类型规则缓存格式错误", db_type=db_type, cache_key=cache_key)
340 |         except Exception as exc:
    |                ^^^^^^^^^
341 |             logger.warning("获取数据库类型规则缓存失败", db_type=db_type, error=str(exc))
342 |         return rules
    |

E501 Line too long (131 > 120)
   --> app/services/cache_service.py:344:121
    |
342 |         return rules
343 |
344 |     def set_classification_rules_by_db_type_cache(self, db_type: str, rules: list[dict[str, Any]], ttl: int | None = None) -> bool:
    |                                                                                                                         ^^^^^^^^^^^
345 |         """设置按数据库类型分类的规则缓存.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:379:16
    |
377 |             )
378 |             success = True
379 |         except Exception as exc:
    |                ^^^^^^^^^
380 |             logger.warning("设置数据库类型规则缓存失败", db_type=db_type, error=str(exc))
381 |         return success
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:402:16
    |
400 |             logger.info("清除数据库类型缓存", db_type=db_type)
401 |             success = True
402 |         except Exception as exc:
    |                ^^^^^^^^^
403 |             logger.warning("清除数据库类型缓存失败", db_type=db_type, error=str(exc))
404 |         return success
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:424:16
    |
422 |             logger.info("清除所有数据库类型缓存")
423 |             success = True
424 |         except Exception as exc:
    |                ^^^^^^^^^
425 |             logger.warning("清除所有数据库类型缓存失败", error=str(exc))
426 |         return success
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/cache_service.py:448:16
    |
446 |             self.cache.delete(test_key)
447 |             is_healthy = result == test_value
448 |         except Exception as exc:
    |                ^^^^^^^^^
449 |             logger.warning("缓存健康检查失败", error=str(exc))
450 |         return is_healthy
    |

D205 1 blank line required between summary line and description
 --> app/services/connection_adapters/__init__.py:1:1
  |
1 | / """鲸落 - 连接适配器模块
2 | | 集中提供数据库连接工厂与连接测试服务.
3 | | """
  | |___^
4 |
5 |   from .connection_factory import ConnectionFactory
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/services/connection_adapters/adapters/base.py:52:9
   |
50 |     """
51 |
52 |     def __init__(self, instance: Instance) -> None:
   |         ^^^^^^^^
53 |         self.instance = instance
54 |         self.db_logger = get_db_logger()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `params`
  --> app/services/connection_adapters/adapters/base.py:95:49
   |
94 |     @abstractmethod
95 |     def execute_query(self, query: str, params: Any | None = None) -> Any:
   |                                                 ^^^^^^^^^^
96 |         """执行查询并返回结果.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
  --> app/services/connection_adapters/adapters/base.py:95:71
   |
94 |     @abstractmethod
95 |     def execute_query(self, query: str, params: Any | None = None) -> Any:
   |                                                                       ^^^
96 |         """执行查询并返回结果.
   |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/mysql_adapter.py:21:13
   |
19 |         """
20 |         try:
21 |             import pymysql
   |             ^^^^^^^^^^^^^^
22 |
23 |             password = self.instance.credential.get_plain_password() if self.instance.credential else ""
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/mysql_adapter.py:39:13
   |
37 |             )
38 |             self.is_connected = True
39 |             return True
   |             ^^^^^^^^^^^
40 |         except Exception as exc:
41 |             self.db_logger.exception(
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/mysql_adapter.py:79:13
   |
78 |               version = self.get_version()
79 | /             return {
80 | |                 "success": True,
81 | |                 "message": f"MySQL连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
82 | |                 "database_version": version,
83 | |             }
   | |_____________^
84 |           except Exception as exc:
85 |               return {"success": False, "error": str(exc)}
   |

E501 Line too long (121 > 120)
  --> app/services/connection_adapters/adapters/mysql_adapter.py:81:111
   |
79 |             return {
80 |                 "success": True,
81 |                 "message": f"MySQL连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
   |                                                                                                                         ^
82 |                 "database_version": version,
83 |             }
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/connection_adapters/adapters/mysql_adapter.py:84:16
   |
82 |                 "database_version": version,
83 |             }
84 |         except Exception as exc:
   |                ^^^^^^^^^
85 |             return {"success": False, "error": str(exc)}
86 |         finally:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
  --> app/services/connection_adapters/adapters/mysql_adapter.py:89:73
   |
87 |             self.disconnect()
88 |
89 |     def execute_query(self, query: str, params: tuple | None = None) -> Any:
   |                                                                         ^^^
90 |         """执行 SQL 查询并返回全部结果.
   |

TRY002 Create your own exception
   --> app/services/connection_adapters/adapters/mysql_adapter.py:102:19
    |
100 |         if not self.is_connected and not self.connect():
101 |             msg = "无法建立数据库连接"
102 |             raise Exception(msg)
    |                   ^^^^^^^^^^^^^^
103 |
104 |         cursor = self.connection.cursor()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/mysql_adapter.py:122:13
    |
120 |             if result:
121 |                 return result[0][0]
122 |             return None
    |             ^^^^^^^^^^^
123 |         except Exception:
124 |             return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/mysql_adapter.py:123:16
    |
121 |                 return result[0][0]
122 |             return None
123 |         except Exception:
    |                ^^^^^^^^^
124 |             return None
    |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/oracle_adapter.py:22:13
   |
20 |         username_for_connection = None
21 |         try:
22 |             import os
   |             ^^^^^^^^^
23 |
24 |             import oracledb
   |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/oracle_adapter.py:24:13
   |
22 |             import os
23 |
24 |             import oracledb
   |             ^^^^^^^^^^^^^^^
25 |
26 |             password = self.instance.credential.get_plain_password() if self.instance.credential else ""
   |

E501 Line too long (129 > 120)
  --> app/services/connection_adapters/adapters/oracle_adapter.py:32:121
   |
30 |             port = self.instance.port
31 |             service_name = self.instance.database_name or "ORCL"
32 |             dsn = f"(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST={host})(PORT={port}))(CONNECT_DATA=(SERVICE_NAME={service_name})))"
   |                                                                                                                         ^^^^^^^^^
33 |
34 |             if not hasattr(oracledb, "is_thin") or not oracledb.is_thin():
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> app/services/connection_adapters/adapters/oracle_adapter.py:43:48
   |
41 |                     oracle_home = os.getenv("ORACLE_HOME")
42 |                     if oracle_home:
43 |                         candidate_paths.append(os.path.join(oracle_home, "lib"))
   |                                                ^^^^^^^^^^^^
44 |
45 |                     current_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> app/services/connection_adapters/adapters/oracle_adapter.py:45:35
   |
43 |                         candidate_paths.append(os.path.join(oracle_home, "lib"))
44 |
45 |                     current_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
   |                                   ^^^^^^^^^^^^^^^
46 |                     candidate_paths.append(os.path.join(current_dir, "oracle_client", "lib"))
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> app/services/connection_adapters/adapters/oracle_adapter.py:45:51
   |
43 |                         candidate_paths.append(os.path.join(oracle_home, "lib"))
44 |
45 |                     current_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
   |                                                   ^^^^^^^^^^^^^^^
46 |                     candidate_paths.append(os.path.join(current_dir, "oracle_client", "lib"))
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> app/services/connection_adapters/adapters/oracle_adapter.py:45:67
   |
43 |                         candidate_paths.append(os.path.join(oracle_home, "lib"))
44 |
45 |                     current_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
   |                                                                   ^^^^^^^^^^^^^^^
46 |                     candidate_paths.append(os.path.join(current_dir, "oracle_client", "lib"))
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> app/services/connection_adapters/adapters/oracle_adapter.py:45:83
   |
43 |                         candidate_paths.append(os.path.join(oracle_home, "lib"))
44 |
45 |                     current_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
   |                                                                                   ^^^^^^^^^^^^^^^
46 |                     candidate_paths.append(os.path.join(current_dir, "oracle_client", "lib"))
   |
help: Replace with `Path(...).resolve()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> app/services/connection_adapters/adapters/oracle_adapter.py:46:44
   |
45 |                     current_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
46 |                     candidate_paths.append(os.path.join(current_dir, "oracle_client", "lib"))
   |                                            ^^^^^^^^^^^^
47 |
48 |                     lib_dir = next((path for path in candidate_paths if path and os.path.isdir(path)), None)
   |

PTH112 `os.path.isdir()` should be replaced by `Path.is_dir()`
  --> app/services/connection_adapters/adapters/oracle_adapter.py:48:82
   |
46 |                     candidate_paths.append(os.path.join(current_dir, "oracle_client", "lib"))
47 |
48 |                     lib_dir = next((path for path in candidate_paths if path and os.path.isdir(path)), None)
   |                                                                                  ^^^^^^^^^^^^^
49 |                     if lib_dir:
50 |                         oracledb.init_oracle_client(lib_dir=lib_dir)
   |
help: Replace with `Path(...).is_dir()`

BLE001 Do not catch blind exception: `Exception`
  --> app/services/connection_adapters/adapters/oracle_adapter.py:53:24
   |
51 |                     else:
52 |                         oracledb.init_oracle_client()
53 |                 except Exception as init_error:
   |                        ^^^^^^^^^
54 |                     if "already been initialized" not in str(init_error).lower():
55 |                         self.db_logger.warning(
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/oracle_adapter.py:74:13
   |
72 |                 username=username_for_connection,
73 |             )
74 |             return True
   |             ^^^^^^^^^^^
75 |         except Exception as exc:
76 |             self.db_logger.exception(
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/oracle_adapter.py:118:13
    |
117 |               version = self.get_version()
118 | /             return {
119 | |                 "success": True,
120 | |                 "message": f"Oracle连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
121 | |                 "database_version": version,
122 | |             }
    | |_____________^
123 |           except Exception as exc:
124 |               return {"success": False, "error": str(exc)}
    |

E501 Line too long (122 > 120)
   --> app/services/connection_adapters/adapters/oracle_adapter.py:120:111
    |
118 |             return {
119 |                 "success": True,
120 |                 "message": f"Oracle连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
    |                                                                                                                         ^^
121 |                 "database_version": version,
122 |             }
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/oracle_adapter.py:123:16
    |
121 |                 "database_version": version,
122 |             }
123 |         except Exception as exc:
    |                ^^^^^^^^^
124 |             return {"success": False, "error": str(exc)}
125 |         finally:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
   --> app/services/connection_adapters/adapters/oracle_adapter.py:128:80
    |
126 |             self.disconnect()
127 |
128 |     def execute_query(self, query: str, params: tuple | dict | None = None) -> Any:
    |                                                                                ^^^
129 |         """执行 SQL 查询并返回全部行.
    |

TRY002 Create your own exception
   --> app/services/connection_adapters/adapters/oracle_adapter.py:141:19
    |
139 |         if not self.is_connected and not self.connect():
140 |             msg = "无法建立数据库连接"
141 |             raise Exception(msg)
    |                   ^^^^^^^^^^^^^^
142 |
143 |         cursor = self.connection.cursor()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/oracle_adapter.py:161:13
    |
159 |             if result:
160 |                 return result[0][0]
161 |             return None
    |             ^^^^^^^^^^^
162 |         except Exception:
163 |             return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/oracle_adapter.py:162:16
    |
160 |                 return result[0][0]
161 |             return None
162 |         except Exception:
    |                ^^^^^^^^^
163 |             return None
    |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:21:13
   |
19 |         """
20 |         try:
21 |             import psycopg
   |             ^^^^^^^^^^^^^^
22 |
23 |             password = self.instance.credential.get_plain_password() if self.instance.credential else ""
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:35:13
   |
33 |             )
34 |             self.is_connected = True
35 |             return True
   |             ^^^^^^^^^^^
36 |         except Exception as exc:
37 |             self.db_logger.exception(
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:75:13
   |
74 |   …         version = self.get_version()
75 | / …         return {
76 | | …             "success": True,
77 | | …             "message": f"PostgreSQL连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
78 | | …             "database_version": version,
79 | | …         }
   | |___________^
80 |   …     except Exception as exc:
81 |   …         return {"success": False, "error": str(exc)}
   |

E501 Line too long (126 > 120)
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:77:112
   |
75 | …     return {
76 | …         "success": True,
77 | …         "message": f"PostgreSQL连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
   |                                                                                                                    ^^^^^
78 | …         "database_version": version,
79 | …     }
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:80:16
   |
78 |                 "database_version": version,
79 |             }
80 |         except Exception as exc:
   |                ^^^^^^^^^
81 |             return {"success": False, "error": str(exc)}
82 |         finally:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:85:73
   |
83 |             self.disconnect()
84 |
85 |     def execute_query(self, query: str, params: tuple | None = None) -> Any:
   |                                                                         ^^^
86 |         """执行 SQL 查询并返回所有结果.
   |

TRY002 Create your own exception
   --> app/services/connection_adapters/adapters/postgresql_adapter.py:98:19
    |
 96 |         if not self.is_connected and not self.connect():
 97 |             msg = "无法建立数据库连接"
 98 |             raise Exception(msg)
    |                   ^^^^^^^^^^^^^^
 99 |
100 |         cursor = self.connection.cursor()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/postgresql_adapter.py:118:13
    |
116 |             if result:
117 |                 return result[0][0]
118 |             return None
    |             ^^^^^^^^^^^
119 |         except Exception:
120 |             return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/postgresql_adapter.py:119:16
    |
117 |                 return result[0][0]
118 |             return None
119 |         except Exception:
    |                ^^^^^^^^^
120 |             return None
    |

D107 Missing docstring in `__init__`
  --> app/services/connection_adapters/adapters/sqlserver_adapter.py:15:9
   |
13 |     """SQL Server 数据库连接."""
14 |
15 |     def __init__(self, instance: Any) -> None:
   |         ^^^^^^^^
16 |         super().__init__(instance)
17 |         self.driver_type: str | None = None
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
  --> app/services/connection_adapters/adapters/sqlserver_adapter.py:15:34
   |
13 |     """SQL Server 数据库连接."""
14 |
15 |     def __init__(self, instance: Any) -> None:
   |                                  ^^^
16 |         super().__init__(instance)
17 |         self.driver_type: str | None = None
   |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/sqlserver_adapter.py:60:13
   |
58 |         """
59 |         try:
60 |             import pymssql
   |             ^^^^^^^^^^^^^^
61 |
62 |             self.connection = pymssql.connect(
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/sqlserver_adapter.py:74:13
   |
72 |             self.is_connected = True
73 |             self.driver_type = "pymssql"
74 |             return True
   |             ^^^^^^^^^^^
75 |         except ImportError:
76 |             self.db_logger.exception(
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:112:20
    |
110 |             try:
111 |                 self.connection.close()
112 |             except Exception as exc:
    |                    ^^^^^^^^^
113 |                 self.db_logger.warning(
114 |                     "SQL Server断开连接出现异常",
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:131:13
    |
130 |   …         version = self.get_version()
131 | / …         return {
132 | | …             "success": True,
133 | | …             "message": f"SQL Server连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
134 | | …             "database_version": version,
135 | | …         }
    | |___________^
136 |   …     except Exception as exc:
137 |   …         return {"success": False, "error": str(exc)}
    |

E501 Line too long (126 > 120)
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:133:112
    |
131 | …     return {
132 | …         "success": True,
133 | …         "message": f"SQL Server连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
    |                                                                                                                    ^^^^^
134 | …         "database_version": version,
135 | …     }
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:136:16
    |
134 |                 "database_version": version,
135 |             }
136 |         except Exception as exc:
    |                ^^^^^^^^^
137 |             return {"success": False, "error": str(exc)}
138 |         finally:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:141:73
    |
139 |             self.disconnect()
140 |
141 |     def execute_query(self, query: str, params: tuple | None = None) -> Any:
    |                                                                         ^^^
142 |         """执行 SQL 查询并返回 `fetchall` 结果.
    |

TRY002 Create your own exception
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:154:19
    |
152 |         if not self.is_connected and not self.connect():
153 |             msg = "无法建立数据库连接"
154 |             raise Exception(msg)
    |                   ^^^^^^^^^^^^^^
155 |
156 |         cursor = self.connection.cursor()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:174:13
    |
172 |             if result:
173 |                 return result[0][0]
174 |             return None
    |             ^^^^^^^^^^^
175 |         except Exception:
176 |             return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:175:16
    |
173 |                 return result[0][0]
174 |             return None
175 |         except Exception:
    |                ^^^^^^^^^
176 |             return None
    |

EXE001 Shebang is present but file is not executable
 --> app/services/connection_adapters/connection_factory.py:1:1
  |
1 | #!/usr/bin/env python3
  | ^^^^^^^^^^^^^^^^^^^^^^
2 |
3 | """数据库连接工厂,依据实例类型选择适配器."""
  |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/services/connection_adapters/connection_factory.py:39:26
   |
37 |       """
38 |
39 |       CONNECTION_CLASSES = {
   |  __________________________^
40 | |         "mysql": MySQLConnection,
41 | |         "postgresql": PostgreSQLConnection,
42 | |         "sqlserver": SQLServerConnection,
43 | |         "oracle": OracleConnection,
44 | |     }
   | |_____^
45 |
46 |       @staticmethod
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/connection_test_service.py:80:13
   |
78 |               db.session.commit()
79 |
80 | /             return {
81 | |                 "success": True,
82 | |                 "message": f"连接成功,数据库版本: {formatted_version}",
83 | |                 "version": formatted_version,
84 | |                 "database_version": instance.database_version,
85 | |                 "main_version": instance.main_version,
86 | |                 "detailed_version": instance.detailed_version,
87 | |             }
   | |_____________^
88 |
89 |           except Exception as e:
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/connection_test_service.py:134:24
    |
132 |                 try:
133 |                     connection_obj.disconnect()
134 |                 except Exception as close_error:
    |                        ^^^^^^^^^
135 |                     self.test_logger.warning(
136 |                         "关闭数据库连接时发生错误",
    |

D107 Missing docstring in `__init__`
  --> app/services/database_sync/adapters/base_adapter.py:30:9
   |
28 |     """
29 |
30 |     def __init__(self) -> None:
   |         ^^^^^^^^
31 |         self.logger = get_system_logger()
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/base_adapter.py:33:51
   |
31 |         self.logger = get_system_logger()
32 |
33 |     def fetch_inventory(self, instance: Instance, connection) -> list[dict]:
   |                                                   ^^^^^^^^^^
34 |         """列出实例当前的数据库/表空间.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/base_adapter.py:54:9
   |
52 |         self,
53 |         instance: Instance,
54 |         connection,
   |         ^^^^^^^^^^
55 |         target_databases: Sequence[str] | None = None,
56 |     ) -> list[dict]:
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/services/database_sync/adapters/mysql_adapter.py:32:25
   |
30 |     """
31 |
32 |     _SYSTEM_DATABASES = {"information_schema", "performance_schema", "mysql", "sys"}
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |
34 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/mysql_adapter.py:34:31
   |
32 |     _SYSTEM_DATABASES = {"information_schema", "performance_schema", "mysql", "sys"}
33 |
34 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                               ^^^^^^^^
35 |         """列出 MySQL 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/mysql_adapter.py:34:41
   |
32 |     _SYSTEM_DATABASES = {"information_schema", "performance_schema", "mysql", "sys"}
33 |
34 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                                         ^^^^^^^^^^
35 |         """列出 MySQL 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/mysql_adapter.py:78:9
   |
76 |     def fetch_capacity(
77 |         self,
78 |         instance,
   |         ^^^^^^^^
79 |         connection,
80 |         target_databases: Sequence[str] | None = None,
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/mysql_adapter.py:79:9
   |
77 |         self,
78 |         instance,
79 |         connection,
   |         ^^^^^^^^^^
80 |         target_databases: Sequence[str] | None = None,
81 |     ) -> list[dict]:
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/adapters/mysql_adapter.py:107:25
    |
105 |             tablespace_stats = self._collect_tablespace_sizes(connection, instance)
106 |         except Exception as exc:  # pragma: no cover - defensive logging
107 |             self.logger.error(
    |                         ^^^^^
108 |                 "mysql_tablespace_collection_failed",
109 |                 instance=instance.name,
    |

ANN001 Missing type annotation for function argument `connection`
   --> app/services/database_sync/adapters/mysql_adapter.py:132:34
    |
130 |         return data
131 |
132 |     def _assert_permission(self, connection, instance) -> None:
    |                                  ^^^^^^^^^^
133 |         """验证 MySQL 权限.
    |

ANN001 Missing type annotation for function argument `instance`
   --> app/services/database_sync/adapters/mysql_adapter.py:132:46
    |
130 |         return data
131 |
132 |     def _assert_permission(self, connection, instance) -> None:
    |                                              ^^^^^^^^
133 |         """验证 MySQL 权限.
    |

C901 `_collect_tablespace_sizes` is too complex (15 > 10)
   --> app/services/database_sync/adapters/mysql_adapter.py:164:9
    |
162 |         )
163 |
164 |     def _collect_tablespace_sizes(self, connection, instance) -> dict[str, int]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
165 |         """采集 MySQL 表空间大小.
    |

PLR0912 Too many branches (15 > 12)
   --> app/services/database_sync/adapters/mysql_adapter.py:164:9
    |
162 |         )
163 |
164 |     def _collect_tablespace_sizes(self, connection, instance) -> dict[str, int]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
165 |         """采集 MySQL 表空间大小.
    |

ANN001 Missing type annotation for function argument `connection`
   --> app/services/database_sync/adapters/mysql_adapter.py:164:41
    |
162 |         )
163 |
164 |     def _collect_tablespace_sizes(self, connection, instance) -> dict[str, int]:
    |                                         ^^^^^^^^^^
165 |         """采集 MySQL 表空间大小.
    |

ANN001 Missing type annotation for function argument `instance`
   --> app/services/database_sync/adapters/mysql_adapter.py:164:53
    |
162 |         )
163 |
164 |     def _collect_tablespace_sizes(self, connection, instance) -> dict[str, int]:
    |                                                     ^^^^^^^^
165 |         """采集 MySQL 表空间大小.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/database_sync/adapters/mysql_adapter.py:218:20
    |
216 |                         view=label,
217 |                     )
218 |             except Exception as exc:
    |                    ^^^^^^^^^
219 |                 self.logger.warning(
220 |                     "mysql_tablespace_query_failed",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/database_sync/adapters/mysql_adapter.py:238:16
    |
236 |                         continue
237 |                     aggregated.setdefault(db_name, 0)
238 |         except Exception as exc:
    |                ^^^^^^^^^
239 |             self.logger.warning(
240 |                 "mysql_show_databases_failed",
    |

ANN001 Missing type annotation for function argument `instance`
   --> app/services/database_sync/adapters/mysql_adapter.py:248:45
    |
246 |         return aggregated
247 |
248 |     def _build_stats_from_tablespaces(self, instance, stats: dict[str, int]) -> list[dict]:
    |                                             ^^^^^^^^
249 |         """将表空间统计转换为标准容量数据.
    |

ANN001 Missing type annotation for function argument `instance`
   --> app/services/database_sync/adapters/mysql_adapter.py:323:41
    |
321 |         return re.sub(r"@([0-9A-Fa-f]{4})", _replace, raw_name)
322 |
323 |     def _build_tablespace_queries(self, instance) -> list[tuple[str, str]]:
    |                                         ^^^^^^^^
324 |         """构建表空间查询语句列表.
    |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/oracle_adapter.py:27:31
   |
25 |     """
26 |
27 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                               ^^^^^^^^
28 |         """列出 Oracle 实例当前的表空间清单.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/oracle_adapter.py:27:41
   |
25 |     """
26 |
27 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                                         ^^^^^^^^^^
28 |         """列出 Oracle 实例当前的表空间清单.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/oracle_adapter.py:71:9
   |
69 |     def fetch_capacity(
70 |         self,
71 |         instance,
   |         ^^^^^^^^
72 |         connection,
73 |         target_databases: Sequence[str] | None = None,
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/oracle_adapter.py:72:9
   |
70 |         self,
71 |         instance,
72 |         connection,
   |         ^^^^^^^^^^
73 |         target_databases: Sequence[str] | None = None,
74 |     ) -> list[dict]:
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/services/database_sync/adapters/postgresql_adapter.py:30:25
   |
28 |     """
29 |
30 |     _SYSTEM_DATABASES = {"postgres"}
   |                         ^^^^^^^^^^^^
31 |
32 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/postgresql_adapter.py:32:31
   |
30 |     _SYSTEM_DATABASES = {"postgres"}
31 |
32 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                               ^^^^^^^^
33 |         """列出 PostgreSQL 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/postgresql_adapter.py:32:41
   |
30 |     _SYSTEM_DATABASES = {"postgres"}
31 |
32 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                                         ^^^^^^^^^^
33 |         """列出 PostgreSQL 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/postgresql_adapter.py:77:9
   |
75 |     def fetch_capacity(
76 |         self,
77 |         instance,
   |         ^^^^^^^^
78 |         connection,
79 |         target_databases: Sequence[str] | None = None,
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/postgresql_adapter.py:78:9
   |
76 |         self,
77 |         instance,
78 |         connection,
   |         ^^^^^^^^^^
79 |         target_databases: Sequence[str] | None = None,
80 |     ) -> list[dict]:
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/sqlserver_adapter.py:27:31
   |
25 |     """
26 |
27 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                               ^^^^^^^^
28 |         """列出 SQL Server 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/sqlserver_adapter.py:27:41
   |
25 |     """
26 |
27 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                                         ^^^^^^^^^^
28 |         """列出 SQL Server 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/sqlserver_adapter.py:71:9
   |
69 |     def fetch_capacity(
70 |         self,
71 |         instance,
   |         ^^^^^^^^
72 |         connection,
73 |         target_databases: Sequence[str] | None = None,
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/sqlserver_adapter.py:72:9
   |
70 |         self,
71 |         instance,
72 |         connection,
   |         ^^^^^^^^^^
73 |         target_databases: Sequence[str] | None = None,
74 |     ) -> list[dict]:
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/coordinator.py:105:25
    |
103 |                 return True
104 |         except Exception as exc:
105 |             self.logger.error(
    |                         ^^^^^
106 |                 "capacity_sync_connection_error",
107 |                 instance=self.instance.name,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/database_sync/coordinator.py:130:20
    |
128 |             try:
129 |                 self._connection.disconnect()
130 |             except Exception as exc:
    |                    ^^^^^^^^^
131 |                 self.logger.warning(
132 |                     "capacity_sync_disconnect_error",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/coordinator.py:292:29
    |
290 |             except Exception as exc:
291 |                 db.session.rollback()
292 |                 self.logger.error(
    |                             ^^^^^
293 |                     "capacity_sync_commit_failed",
294 |                     instance=self.instance.name,
    |

SIM102 Use a single `if` statement instead of nested `if` statements
   --> app/services/database_sync/coordinator.py:320:9
    |
319 |           """
320 | /         if not self._connection or not getattr(self._connection, "is_connected", False):
321 | |             if not self.connect():
    | |__________________________________^
322 |                   msg = "数据库连接未建立"
323 |                   raise RuntimeError(msg)
    |
help: Combine `if` statements using `and`

D107 Missing docstring in `__init__`
  --> app/services/database_sync/database_filters.py:29:9
   |
27 |     """负责加载数据库发现/容量同步所需的过滤配置."""
28 |
29 |     def __init__(self, config_path: str | Path | None = None) -> None:
   |         ^^^^^^^^
30 |         self._config_path = Path(config_path) if config_path else _DEFAULT_CONFIG_PATH
31 |         self._normalized_rules: dict[str, dict[str, Any]] = {}
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/services/database_sync/database_filters.py:111:49
    |
109 |         return re.compile(regex, re.IGNORECASE)
110 |
111 |     def should_exclude_database(self, instance: Any, database_name: str | None) -> tuple[bool, str | None]:
    |                                                 ^^^
112 |         """判断给定实例下的数据库是否需要被过滤.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/services/database_sync/database_filters.py:143:47
    |
141 |         return False, None
142 |
143 |     def filter_database_names(self, instance: Any, names: Iterable[str]) -> tuple[list[str], list[str]]:
    |                                               ^^^
144 |         """过滤数据库名称,返回保留与排除列表.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/services/database_sync/database_filters.py:164:49
    |
162 |         return allowed, excluded
163 |
164 |     def filter_capacity_payload(self, instance: Any, payload: Sequence[dict[str, Any]]) -> tuple[list[dict[str, Any]], list[str]]:
    |                                                 ^^^
165 |         """过滤容量采集结果,返回保留记录与被排除的库名.
    |

E501 Line too long (130 > 120)
   --> app/services/database_sync/database_filters.py:164:121
    |
162 |         return allowed, excluded
163 |
164 |     def filter_capacity_payload(self, instance: Any, payload: Sequence[dict[str, Any]]) -> tuple[list[dict[str, Any]], list[str]]:
    |                                                                                                                         ^^^^^^^^^^
165 |         """过滤容量采集结果,返回保留记录与被排除的库名.
    |

ANN001 Missing type annotation for function argument `exc_type`
  --> app/services/database_sync/database_sync_service.py:58:24
   |
56 |         return self
57 |
58 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                        ^^^^^^^^
59 |         """退出上下文管理器,断开数据库连接.
   |

ANN001 Missing type annotation for function argument `exc_val`
  --> app/services/database_sync/database_sync_service.py:58:34
   |
56 |         return self
57 |
58 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                                  ^^^^^^^
59 |         """退出上下文管理器,断开数据库连接.
   |

ANN001 Missing type annotation for function argument `exc_tb`
  --> app/services/database_sync/database_sync_service.py:58:43
   |
56 |         return self
57 |
58 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                                           ^^^^^^
59 |         """退出上下文管理器,断开数据库连接.
   |

PLC0415 `import` should be at the top-level of a file
   --> app/services/database_sync/database_sync_service.py:209:5
    |
208 |     """
209 |     from app.models.instance import Instance
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
210 |
211 |     logger = get_system_logger()
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/database_sync_service.py:251:20
    |
249 |         except Exception as exc:
250 |             error_msg = f"实例 {instance.name} 采集失败: {exc}"
251 |             logger.error(
    |                    ^^^^^
252 |                 "capacity_collection_failed",
253 |                 instance=instance.name,
    |

D107 Missing docstring in `__init__`
  --> app/services/database_sync/inventory_manager.py:24:9
   |
22 |     """负责维护 instance_databases 表的增量同步逻辑."""
23 |
24 |     def __init__(self, filter_manager=database_sync_filter_manager) -> None:
   |         ^^^^^^^^
25 |         self.logger = get_system_logger()
26 |         self.filter_manager = filter_manager
   |

ANN001 Missing type annotation for function argument `filter_manager`
  --> app/services/database_sync/inventory_manager.py:24:24
   |
22 |     """负责维护 instance_databases 表的增量同步逻辑."""
23 |
24 |     def __init__(self, filter_manager=database_sync_filter_manager) -> None:
   |                        ^^^^^^^^^^^^^^
25 |         self.logger = get_system_logger()
26 |         self.filter_manager = filter_manager
   |

C901 `synchronize` is too complex (11 > 10)
  --> app/services/database_sync/inventory_manager.py:28:9
   |
26 |         self.filter_manager = filter_manager
27 |
28 |     def synchronize(
   |         ^^^^^^^^^^^
29 |         self,
30 |         instance: Instance,
   |

PLR0915 Too many statements (54 > 50)
  --> app/services/database_sync/inventory_manager.py:28:9
   |
26 |         self.filter_manager = filter_manager
27 |
28 |     def synchronize(
   |         ^^^^^^^^^^^
29 |         self,
30 |         instance: Instance,
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/inventory_manager.py:121:25
    |
119 |         except SQLAlchemyError as exc:
120 |             db.session.rollback()
121 |             self.logger.error(
    |                         ^^^^^
122 |                 "inventory_sync_commit_failed",
123 |                 instance=instance.name,
    |

D107 Missing docstring in `__init__`
  --> app/services/database_sync/persistence.py:27:9
   |
25 |     """负责容量采集相关的数据持久化."""
26 |
27 |     def __init__(self) -> None:
   |         ^^^^^^^^
28 |         self.logger = get_system_logger()
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/persistence.py:101:25
    |
 99 |         except SQLAlchemyError as exc:
100 |             db.session.rollback()
101 |             self.logger.error(
    |                         ^^^^^
102 |                 "save_database_stats_upsert_failed",
103 |                 instance=instance.name,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/persistence.py:118:25
    |
116 |         except SQLAlchemyError as exc:
117 |             db.session.rollback()
118 |             self.logger.error(
    |                         ^^^^^
119 |                 "save_database_stats_commit_failed",
120 |                 instance=instance.name,
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/database_sync/persistence.py:191:13
    |
189 |                 database_count=database_count,
190 |             )
191 |             return True
    |             ^^^^^^^^^^^
192 |         except SQLAlchemyError as exc:
193 |             self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/persistence.py:193:25
    |
191 |             return True
192 |         except SQLAlchemyError as exc:
193 |             self.logger.error(
    |                         ^^^^^
194 |                 "save_instance_stats_failed",
195 |                 instance=instance.name,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/persistence.py:250:29
    |
248 |             except SQLAlchemyError as exc:
249 |                 db.session.rollback()
250 |                 self.logger.error(
    |                             ^^^^^
251 |                     "update_instance_total_size_commit_failed",
252 |                     instance=instance.name,
    |

D205 1 blank line required between summary line and description
 --> app/services/database_type_service.py:1:1
  |
1 | / """鲸落 - 数据库类型管理服务
2 | | 提供数据库类型的CRUD操作和业务逻辑.
3 | | """
  | |___^
4 |
5 |   from typing import Any
  |
help: Insert single blank line

PLR0911 Too many return statements (8 > 6)
  --> app/services/form_service/classification_rule_service.py:45:9
   |
43 |         return dict(payload or {})
44 |
45 |     def validate(self, data: dict[str, Any], *, resource: ClassificationRule | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
46 |         """校验分类规则数据.
   |

ARG002 Unused method argument: `data`
   --> app/services/form_service/classification_rule_service.py:118:56
    |
116 |         instance.is_active = data["is_active"]
117 |
118 |     def after_save(self, instance: ClassificationRule, data: dict[str, Any]) -> None:
    |                                                        ^^^^
119 |         """保存后记录日志并清除缓存.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/services/form_service/classification_rule_service.py:129:9
    |
128 |         """
129 |         from app.utils.structlog_config import log_info
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
130 |
131 |         log_info(
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/classification_rule_service.py:140:16
    |
138 |             service = AccountClassificationService()
139 |             service.invalidate_cache()
140 |         except Exception as exc:
    |                ^^^^^^^^^
141 |             log_info(
142 |                 "清除分类缓存失败",
    |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/classification_rule_service.py:148:32
    |
146 |             )
147 |
148 |     def build_context(self, *, resource: ClassificationRule | None) -> dict[str, Any]:
    |                                ^^^^^^^^
149 |         """构建模板渲染上下文.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `expression`
   --> app/services/form_service/classification_rule_service.py:167:49
    |
165 |         }
166 |
167 |     def _normalize_expression(self, expression: Any) -> str:
    |                                                 ^^^
168 |         """规范化规则表达式为 JSON 字符串.
    |

PLR0911 Too many return statements (7 > 6)
   --> app/services/form_service/classification_rule_service.py:183:9
    |
181 |         return json.dumps(parsed, ensure_ascii=False, sort_keys=True)
182 |
183 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |         ^^^^^^^^^^^^
184 |         """将值转换为布尔类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/form_service/classification_rule_service.py:183:35
    |
181 |         return json.dumps(parsed, ensure_ascii=False, sort_keys=True)
182 |
183 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
184 |         """将值转换为布尔类型.
    |

PLR0911 Too many return statements (7 > 6)
  --> app/services/form_service/classification_service.py:43:9
   |
41 |         return dict(payload or {})
42 |
43 |     def validate(self, data: dict[str, Any], *, resource: AccountClassification | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
44 |         """校验账户分类数据.
   |

E501 Line too long (121 > 120)
  --> app/services/form_service/classification_service.py:43:121
   |
41 |         return dict(payload or {})
42 |
43 |     def validate(self, data: dict[str, Any], *, resource: AccountClassification | None) -> ServiceResult[dict[str, Any]]:
   |                                                                                                                         ^
44 |         """校验账户分类数据.
   |

PLC0415 `import` should be at the top-level of a file
   --> app/services/form_service/classification_service.py:117:9
    |
115 |         """
116 |         action = "创建账户分类成功" if data.get("_is_create") else "更新账户分类成功"
117 |         from app.utils.structlog_config import log_info  # avoid circular import
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
118 |
119 |         log_info(
    |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/classification_service.py:126:32
    |
124 |         )
125 |
126 |     def build_context(self, *, resource: AccountClassification | None) -> dict[str, Any]:
    |                                ^^^^^^^^
127 |         """构建模板渲染上下文.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `raw_value`
   --> app/services/form_service/classification_service.py:146:42
    |
144 |         }
145 |
146 |     def _parse_priority(self, raw_value: Any, default: int) -> int:
    |                                          ^^^
147 |         """解析优先级值.
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app/services/form_service/classification_service.py:166:13
    |
164 |         except (TypeError, ValueError):
165 |             msg = "优先级必须为整数"
166 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^
167 |         return max(0, min(value, 100))
    |

C901 `validate` is too complex (11 > 10)
  --> app/services/form_service/credential_service.py:50:9
   |
48 |         return sanitize_form_data(payload or {})
49 |
50 |     def validate(self, data: dict[str, Any], *, resource: Credential | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
51 |         """校验凭据数据.
   |

PLR0911 Too many return statements (7 > 6)
  --> app/services/form_service/credential_service.py:50:9
   |
48 |         return sanitize_form_data(payload or {})
49 |
50 |     def validate(self, data: dict[str, Any], *, resource: Credential | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
51 |         """校验凭据数据.
   |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/credential_service.py:147:32
    |
145 |         )
146 |
147 |     def build_context(self, *, resource: Credential | None) -> dict[str, Any]:
    |                                ^^^^^^^^
148 |         """构建模板渲染上下文.
    |

E501 Line too long (127 > 120)
   --> app/services/form_service/credential_service.py:178:121
    |
176 |         normalized: dict[str, Any] = {}
177 |         normalized["name"] = (data.get("name") or (resource.name if resource else "")).strip()
178 |         normalized["credential_type"] = (data.get("credential_type") or (resource.credential_type if resource else "")).strip()
    |                                                                                                                         ^^^^^^^
179 |         normalized["username"] = (data.get("username") or (resource.username if resource else "")).strip()
    |

PLR0911 Too many return statements (7 > 6)
   --> app/services/form_service/credential_service.py:198:9
    |
196 |         return normalized
197 |
198 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |         ^^^^^^^^^^^^
199 |         """将值转换为布尔类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/form_service/credential_service.py:198:35
    |
196 |         return normalized
197 |
198 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
199 |         """将值转换为布尔类型.
    |

S106 Possible hardcoded password assigned to argument: "password"
   --> app/services/form_service/credential_service.py:235:13
    |
233 |             credential_type="database",
234 |             username="__pending__",
235 |             password="__pending__",
    |             ^^^^^^^^^^^^^^^^^^^^^^
236 |         )
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `credential_raw`
   --> app/services/form_service/instance_service.py:150:54
    |
148 |     # Helpers
149 |     # ------------------------------------------------------------------ #
150 |     def _resolve_credential_id(self, credential_raw: Any) -> int | None:
    |                                                      ^^^
151 |         """解析凭据 ID.
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app/services/form_service/instance_service.py:169:13
    |
167 |         except (TypeError, ValueError):
168 |             msg = "无效的凭据ID"
169 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^
170 |
171 |         credential = Credential.query.get(credential_id)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `tag_field`
   --> app/services/form_service/instance_service.py:177:47
    |
175 |         return credential_id
176 |
177 |     def _normalize_tag_names(self, tag_field: Any) -> list[str]:
    |                                               ^^^
178 |         """规范化标签名称列表.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/instance_service.py:261:16
    |
259 |                     tags=added,
260 |                 )
261 |         except Exception as exc:
    |                ^^^^^^^^^
262 |             db.session.rollback()
263 |             log_error(
    |

PLR0911 Too many return statements (7 > 6)
  --> app/services/form_service/password_service.py:43:9
   |
41 |         return sanitize_form_data(payload or {})
42 |
43 |     def validate(self, data: dict[str, Any], *, resource: User | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
44 |         """校验密码修改数据.
   |

ARG002 Unused method argument: `instance`
  --> app/services/form_service/password_service.py:94:26
   |
92 |         instance.set_password(data["new_password"])
93 |
94 |     def after_save(self, instance: User, data: dict[str, Any]) -> None:
   |                          ^^^^^^^^
95 |         """保存后记录日志.
   |

ARG002 Unused method argument: `data`
  --> app/services/form_service/password_service.py:94:42
   |
92 |         instance.set_password(data["new_password"])
93 |
94 |     def after_save(self, instance: User, data: dict[str, Any]) -> None:
   |                                          ^^^^
95 |         """保存后记录日志.
   |

E501 Line too long (131 > 120)
   --> app/services/form_service/password_service.py:125:117
    |
123 | …rce)
124 | …
125 | …"验证失败", message_key=validation.message_key, extra=validation.extra)
    |                                                              ^^^^^^^^^^^
126 | …
127 | …
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/password_service.py:136:16
    |
134 |             db.session.add(instance)
135 |             db.session.commit()
136 |         except Exception as exc:
    |                ^^^^^^^^^
137 |             db.session.rollback()
138 |             return ServiceResult.fail("密码修改失败,请稍后再试", extra={"exception": str(exc)})
    |

D205 1 blank line required between summary line and description
 --> app/services/form_service/resource_service.py:1:1
  |
1 | / """通用资源表单服务基类.
2 | | ---------------------------------
3 | | 负责封装表单校验、模型赋值、数据库提交与统一的结果返回.
4 | | """
  | |___^
5 |
6 |   from __future__ import annotations
  |
help: Insert single blank line

ARG002 Unused method argument: `resource`
   --> app/services/form_service/resource_service.py:125:49
    |
123 |         return dict(payload or {})
124 |
125 |     def validate(self, data: dict[str, Any], *, resource: TModel | None) -> ServiceResult[dict[str, Any]]:
    |                                                 ^^^^^^^^
126 |         """子类应该实现具体校验逻辑.
    |

ARG002 Unused method argument: `instance`
   --> app/services/form_service/resource_service.py:154:26
    |
152 |         raise NotImplementedError
153 |
154 |     def after_save(self, instance: TModel, data: dict[str, Any]) -> None:
    |                          ^^^^^^^^
155 |         """保存成功后的钩子(可选).
    |

ARG002 Unused method argument: `data`
   --> app/services/form_service/resource_service.py:154:44
    |
152 |         raise NotImplementedError
153 |
154 |     def after_save(self, instance: TModel, data: dict[str, Any]) -> None:
    |                                            ^^^^
155 |         """保存成功后的钩子(可选).
    |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/resource_service.py:167:32
    |
165 |         return
166 |
167 |     def build_context(self, *, resource: TModel | None) -> dict[str, Any]:
    |                                ^^^^^^^^
168 |         """提供模板渲染所需的额外上下文.
    |

E501 Line too long (131 > 120)
   --> app/services/form_service/resource_service.py:198:117
    |
196 | …rce)
197 | …
198 | …"验证失败", message_key=validation.message_key, extra=validation.extra)
    |                                                              ^^^^^^^^^^^
199 | …
200 | …
    |

G004 Logging statement uses f-string
   --> app/services/form_service/resource_service.py:208:42
    |
206 |         except SQLAlchemyError as exc:
207 |             db.session.rollback()
208 |             current_app.logger.exception(f"资源表单保存失败: {self.__class__.__name__}")
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
209 |             return ServiceResult.fail("保存失败,请稍后再试", extra={"exception": str(exc)})
    |
help: Convert to lazy `%` formatting

A004 Import `SystemError` is shadowing a Python builtin
  --> app/services/form_service/scheduler_job_service.py:15:39
   |
14 | from app.constants.scheduler_jobs import BUILTIN_TASK_IDS
15 | from app.errors import NotFoundError, SystemError, ValidationError
   |                                       ^^^^^^^^^^^
16 | from app.scheduler import get_scheduler
17 | from app.services.form_service.resource_service import BaseResourceService, ServiceResult
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/services/form_service/scheduler_job_service.py:71:38
   |
70 |         """
71 |         scheduler = get_scheduler()  # type: ignore
   |                                      ^^^^^^^^^^^^^^
72 |         if not scheduler.running:
73 |             log_error("调度器未启动,无法加载任务", module="scheduler")
   |

ARG002 Unused method argument: `data`
   --> app/services/form_service/scheduler_job_service.py:127:52
    |
125 |         scheduler.modify_job(job.id, trigger=data["trigger"])
126 |
127 |     def after_save(self, instance: dict[str, Any], data: dict[str, Any]) -> None:
    |                                                    ^^^^
128 |         """触发器更新后的善后处理,负责记录下一次执行时间.
    |

E501 Line too long (122 > 120)
   --> app/services/form_service/scheduler_job_service.py:149:121
    |
147 |         )
148 |
149 |     def upsert(self, payload: Mapping[str, Any], resource: dict[str, Any] | None = None) -> ServiceResult[dict[str, Any]]:
    |                                                                                                                         ^^
150 |         """更新内置任务的触发器配置.
    |

E501 Line too long (131 > 120)
   --> app/services/form_service/scheduler_job_service.py:163:117
    |
161 | …rce)
162 | …
163 | …"验证失败", message_key=validation.message_key, extra=validation.extra)
    |                                                              ^^^^^^^^^^^
164 | …
165 | …
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/scheduler_job_service.py:172:16
    |
170 |         except ValidationError:
171 |             raise
172 |         except Exception as exc:
    |                ^^^^^^^^^
173 |             log_error("更新任务触发器失败", module="scheduler", job_id=resource["job"].id, error=str(exc))
174 |             return ServiceResult.fail("更新任务触发器失败", extra={"exception": str(exc)})
    |

C901 `_build_trigger` is too complex (29 > 10)
   --> app/services/form_service/scheduler_job_service.py:179:9
    |
177 |         return ServiceResult.ok(resource)
178 |
179 |     def _build_trigger(self, data: Mapping[str, Any]) -> CronTrigger | IntervalTrigger | DateTrigger | None:
    |         ^^^^^^^^^^^^^^
180 |         """根据表单数据构建 APScheduler 触发器.
    |

PLR0911 Too many return statements (10 > 6)
   --> app/services/form_service/scheduler_job_service.py:179:9
    |
177 |         return ServiceResult.ok(resource)
178 |
179 |     def _build_trigger(self, data: Mapping[str, Any]) -> CronTrigger | IntervalTrigger | DateTrigger | None:
    |         ^^^^^^^^^^^^^^
180 |         """根据表单数据构建 APScheduler 触发器.
    |

PLR0912 Too many branches (25 > 12)
   --> app/services/form_service/scheduler_job_service.py:179:9
    |
177 |         return ServiceResult.ok(resource)
178 |
179 |     def _build_trigger(self, data: Mapping[str, Any]) -> CronTrigger | IntervalTrigger | DateTrigger | None:
    |         ^^^^^^^^^^^^^^
180 |         """根据表单数据构建 APScheduler 触发器.
    |

PLR0915 Too many statements (70 > 50)
   --> app/services/form_service/scheduler_job_service.py:179:9
    |
177 |         return ServiceResult.ok(resource)
178 |
179 |     def _build_trigger(self, data: Mapping[str, Any]) -> CronTrigger | IntervalTrigger | DateTrigger | None:
    |         ^^^^^^^^^^^^^^
180 |         """根据表单数据构建 APScheduler 触发器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `pick`
   --> app/services/form_service/scheduler_job_service.py:196:37
    |
194 |             parts: list[str] = expr.split() if expr else []
195 |
196 |             def pick(*keys: str) -> Any:
    |                                     ^^^
197 |                 for key in keys:
198 |                     value = data.get(key)
    |

PLR2004 Magic value used in comparison, consider replacing `7` with a constant variable
   --> app/services/form_service/scheduler_job_service.py:212:34
    |
211 |             try:
212 |                 if len(parts) == 7:
    |                                  ^
213 |                     second, minute, hour, day, month, day_of_week, year = [
214 |                         pick_value or part for pick_value, part in zip(
    |

PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   --> app/services/form_service/scheduler_job_service.py:218:36
    |
216 |                         )
217 |                     ]
218 |                 elif len(parts) == 6:
    |                                    ^
219 |                     second, minute, hour, day, month, day_of_week = [
220 |                         pick_value or part for pick_value, part in zip(
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> app/services/form_service/scheduler_job_service.py:224:36
    |
222 |                         )
223 |                     ]
224 |                 elif len(parts) == 5:
    |                                    ^
225 |                     minute, hour, day, month, day_of_week = [
226 |                         pick_value or part for pick_value, part in zip(
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> app/services/form_service/scheduler_job_service.py:230:13
    |
228 |                           )
229 |                       ]
230 | /             except Exception:
231 | |                 pass
    | |____________________^
232 |
233 |               if year is not None:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/scheduler_job_service.py:230:20
    |
228 |                         )
229 |                     ]
230 |             except Exception:
    |                    ^^^^^^^^^
231 |                 pass
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/scheduler_job_service.py:251:20
    |
249 |                 cron_kwargs["timezone"] = "Asia/Shanghai"
250 |                 return CronTrigger(**cron_kwargs)
251 |             except Exception as exc:
    |                    ^^^^^^^^^
252 |                 log_error("CronTrigger 构建失败", module="scheduler", error=str(exc))
253 |                 return None
    |

S112 `try`-`except`-`continue` detected, consider logging the exception
   --> app/services/form_service/scheduler_job_service.py:265:17
    |
263 |                       if converted > 0:
264 |                           kwargs[key] = converted
265 | /                 except Exception:
266 | |                     continue
    | |____________________________^
267 |               if not kwargs:
268 |                   return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/scheduler_job_service.py:265:24
    |
263 |                     if converted > 0:
264 |                         kwargs[key] = converted
265 |                 except Exception:
    |                        ^^^^^^^^^
266 |                     continue
267 |             if not kwargs:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/scheduler_job_service.py:271:20
    |
269 |             try:
270 |                 return IntervalTrigger(**kwargs)
271 |             except Exception as exc:
    |                    ^^^^^^^^^
272 |                 log_error("IntervalTrigger 构建失败", module="scheduler", error=str(exc))
273 |                 return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/scheduler_job_service.py:282:20
    |
280 |             try:
281 |                 dt = time_utils.to_utc(str(run_date))
282 |             except Exception:
    |                    ^^^^^^^^^
283 |                 dt = None
284 |             if dt is None:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/scheduler_job_service.py:288:20
    |
286 |             try:
287 |                 return DateTrigger(run_date=dt)
288 |             except Exception as exc:
    |                    ^^^^^^^^^
289 |                 log_error("DateTrigger 构建失败", module="scheduler", error=str(exc))
290 |                 return None
    |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/tag_service.py:125:32
    |
123 |         )
124 |
125 |     def build_context(self, *, resource: Tag | None) -> dict[str, Any]:
    |                                ^^^^^^^^
126 |         """构建模板渲染上下文.
    |

PLR0911 Too many return statements (7 > 6)
   --> app/services/form_service/tag_service.py:175:9
    |
173 |         return normalized
174 |
175 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |         ^^^^^^^^^^^^
176 |         """将值转换为布尔类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/form_service/tag_service.py:175:35
    |
173 |         return normalized
174 |
175 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
176 |         """将值转换为布尔类型.
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/services/form_service/user_service.py:35:21
   |
33 |     model = User
34 |     USERNAME_PATTERN = re.compile(r"^[A-Za-z0-9_]{3,20}$")
35 |     ALLOWED_ROLES = {UserRole.ADMIN, UserRole.USER}
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 |     MESSAGE_USERNAME_EXISTS = "USERNAME_EXISTS"
37 |     MESSAGE_LAST_ADMIN_REQUIRED = "LAST_ADMIN_REQUIRED"
   |

C901 `validate` is too complex (11 > 10)
  --> app/services/form_service/user_service.py:51:9
   |
49 |         return sanitize_form_data(payload or {})
50 |
51 |     def validate(self, data: dict[str, Any], *, resource: User | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
52 |         """校验用户数据.
   |

PLR0911 Too many return statements (8 > 6)
  --> app/services/form_service/user_service.py:51:9
   |
49 |         return sanitize_form_data(payload or {})
50 |
51 |     def validate(self, data: dict[str, Any], *, resource: User | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
52 |         """校验用户数据.
   |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/user_service.py:141:32
    |
139 |         )
140 |
141 |     def build_context(self, *, resource: User | None) -> dict[str, Any]:
    |                                ^^^^^^^^
142 |         """构建模板渲染上下文.
    |

ANN202 Missing return type annotation for private function `_user_query`
   --> app/services/form_service/user_service.py:199:9
    |
197 |         return data.get("role") == UserRole.ADMIN and bool(data.get("is_active", True))
198 |
199 |     def _user_query(self):
    |         ^^^^^^^^^^^
200 |         """暴露 user query,便于单测注入."""
201 |         return User.query
    |
help: Add return type annotation

PLR0911 Too many return statements (7 > 6)
   --> app/services/form_service/user_service.py:203:9
    |
201 |         return User.query
202 |
203 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |         ^^^^^^^^^^^^
204 |         """将值转换为布尔类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/form_service/user_service.py:203:35
    |
201 |         return User.query
202 |
203 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
204 |         """将值转换为布尔类型.
    |

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   --> app/services/form_service/user_service.py:241:28
    |
240 |         """
241 |         if len(password) < 8:
    |                            ^
242 |             return "密码长度至少8位"
243 |         if not any(char.isupper() for char in password):
    |

A004 Import `SystemError` is shadowing a Python builtin
  --> app/services/instances/batch_service.py:12:24
   |
11 | from app import db
12 | from app.errors import SystemError, ValidationError
   |                        ^^^^^^^^^^^
13 | from app.models.account_change_log import AccountChangeLog
14 | from app.models.account_classification import AccountClassificationAssignment
   |

C901 `create_instances` is too complex (11 > 10)
  --> app/services/instances/batch_service.py:60:9
   |
58 |     """
59 |
60 |     def create_instances(
   |         ^^^^^^^^^^^^^^^^
61 |         self,
62 |         instances_data: list[dict[str, Any]],
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/instances/batch_service.py:299:13
    |
297 |             stats["deleted_sync_data"] = stats["deleted_account_permissions"]
298 |
299 |             return stats
    |             ^^^^^^^^^^^^
300 |         except SQLAlchemyError as exc:
301 |             db.session.rollback()
    |

INP001 File `app/services/ledgers/database_ledger_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/ledgers/database_ledger_service.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/services/ledgers/database_ledger_service.py:16:39
   |
14 | from app import db
15 | from app.constants import SyncStatus
16 | from app.errors import NotFoundError, SystemError
   |                                       ^^^^^^^^^^^
17 | from app.models.database_size_stat import DatabaseSizeStat
18 | from app.models.instance import Instance
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `session`
  --> app/services/ledgers/database_ledger_service.py:35:36
   |
33 |     MAX_TREND_DAYS = 90
34 |
35 |     def __init__(self, *, session: Any | None = None) -> None:
   |                                    ^^^^^^^^^^
36 |         """初始化服务.
   |

D417 Missing argument description in the docstring for `get_ledger`: `tags`
  --> app/services/ledgers/database_ledger_service.py:44:9
   |
42 |         self.session = session or db.session
43 |
44 |     def get_ledger(
   |         ^^^^^^^^^^
45 |         self,
46 |         *,
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/ledgers/database_ledger_service.py:96:13
    |
 94 |               ]
 95 |
 96 | /             return {
 97 | |                 "items": rows,
 98 | |                 "total": total,
 99 | |                 "page": page,
100 | |                 "per_page": per_page,
101 | |             }
    | |_____________^
102 |           except Exception as exc:
103 |               log_error(
    |

D417 Missing argument description in the docstring for `iterate_all`: `tags`
   --> app/services/ledgers/database_ledger_service.py:112:9
    |
110 |             raise SystemError(msg) from exc
111 |
112 |     def iterate_all(
    |         ^^^^^^^^^^^
113 |         self,
114 |         *,
    |

ANN202 Missing return type annotation for private function `_base_query`
   --> app/services/ledgers/database_ledger_service.py:217:9
    |
215 |         }
216 |
217 |     def _base_query(self):
    |         ^^^^^^^^^^^
218 |         """构造基础查询."""
219 |         return (
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `_apply_filters`
   --> app/services/ledgers/database_ledger_service.py:229:9
    |
227 |         )
228 |
229 |     def _apply_filters(
    |         ^^^^^^^^^^^^^^
230 |         self,
231 |         query,
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `query`
   --> app/services/ledgers/database_ledger_service.py:231:9
    |
229 |     def _apply_filters(
230 |         self,
231 |         query,
    |         ^^^^^
232 |         *,
233 |         search: str = "",
    |

ANN202 Missing return type annotation for private function `_with_latest_stats`
   --> app/services/ledgers/database_ledger_service.py:263:9
    |
261 |         return query
262 |
263 |     def _with_latest_stats(self, query):
    |         ^^^^^^^^^^^^^^^^^^
264 |         """为查询附加最新容量信息."""
265 |         latest_stats = (
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `query`
   --> app/services/ledgers/database_ledger_service.py:263:34
    |
261 |         return query
262 |
263 |     def _with_latest_stats(self, query):
    |                                  ^^^^^
264 |         """为查询附加最新容量信息."""
265 |         latest_stats = (
    |

ANN001 Missing type annotation for function argument `collected_at`
   --> app/services/ledgers/database_ledger_service.py:303:9
    |
301 |         record: InstanceDatabase,
302 |         instance: Instance,
303 |         collected_at,
    |         ^^^^^^^^^^^^
304 |         size_mb,
305 |         tags: list[dict[str, Any]] | None = None,
    |

ANN001 Missing type annotation for function argument `size_mb`
   --> app/services/ledgers/database_ledger_service.py:304:9
    |
302 |         instance: Instance,
303 |         collected_at,
304 |         size_mb,
    |         ^^^^^^^
305 |         tags: list[dict[str, Any]] | None = None,
306 |     ) -> dict[str, Any]:
    |

ANN001 Missing type annotation for function argument `collected_at`
   --> app/services/ledgers/database_ledger_service.py:365:36
    |
363 |         return mapping
364 |
365 |     def _resolve_sync_status(self, collected_at) -> dict[str, str]:
    |                                    ^^^^^^^^^^^^
366 |         """根据采集时间生成同步状态."""
367 |         if not collected_at:
    |

PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   --> app/services/ledgers/database_ledger_service.py:373:27
    |
371 |         delay_hours = (now - collected_at).total_seconds() / 3600
372 |
373 |         if delay_hours <= 6:
    |                           ^
374 |             return {"value": SyncStatus.COMPLETED, "label": "已更新", "variant": "success"}
375 |         if delay_hours <= 48:
    |

PLR2004 Magic value used in comparison, consider replacing `48` with a constant variable
   --> app/services/ledgers/database_ledger_service.py:375:27
    |
373 |         if delay_hours <= 6:
374 |             return {"value": SyncStatus.COMPLETED, "label": "已更新", "variant": "success"}
375 |         if delay_hours <= 48:
    |                           ^^
376 |             return {"value": SyncStatus.RUNNING, "label": "待刷新", "variant": "warning"}
377 |         return {"value": SyncStatus.FAILED, "label": "超时", "variant": "danger"}
    |

PLR2004 Magic value used in comparison, consider replacing `1024` with a constant variable
   --> app/services/ledgers/database_ledger_service.py:383:23
    |
381 |         if size_mb is None:
382 |             return "未采集"
383 |         if size_mb >= 1024:
    |                       ^^^^
384 |             size_gb = size_mb / 1024
385 |             return f"{size_gb:.2f} GB"
    |

D205 1 blank line required between summary line and description
 --> app/services/partition_management_service.py:1:1
  |
1 | / """分区管理服务
2 | | 负责创建、清理与查询数据库容量相关表的分区信息.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/services/partition_management_service.py:45:9
   |
43 |     """PostgreSQL 分区管理服务."""
44 |
45 |     def __init__(self) -> None:
   |         ^^^^^^^^
46 |         self.tables: dict[str, dict[str, str]] = {
47 |             "stats": {
   |

PLC0415 `import` should be at the top-level of a file
   --> app/services/partition_management_service.py:120:13
    |
119 |         for table_key, table_config in self.tables.items():
120 |             from app.utils.time_utils import time_utils
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
121 |             partition_name = f"{table_config['partition_prefix']}{time_utils.format_china_time(month_start, '%Y_%m')}"
122 |             if self._partition_exists(partition_name):
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/partition_management_service.py:183:20
    |
181 |                     exception=exc,
182 |                 )
183 |             except Exception as exc:  # pragma: no cover - 防御性分支
    |                    ^^^^^^^^^
184 |                 failures.append(
185 |                     {
    |

DTZ011 `datetime.date.today()` used
   --> app/services/partition_management_service.py:265:17
    |
263 |         created: list[dict[str, Any]] = []
264 |         issues: list[dict[str, Any]] = []
265 |         today = date.today()
    |                 ^^^^^^^^^^^^
266 |
267 |         for offset in range(months_ahead):
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

BLE001 Do not catch blind exception: `Exception`
   --> app/services/partition_management_service.py:281:20
    |
279 |                     issues=exc.extra,
280 |                 )
281 |             except Exception as exc:
    |                    ^^^^^^^^^
282 |                 issues.append({"month": target_month.isoformat(), "message": str(exc)})
283 |                 log_error(
    |

DTZ011 `datetime.date.today()` used
   --> app/services/partition_management_service.py:332:24
    |
331 |         """
332 |         cutoff_date = (date.today() - timedelta(days=retention_months * 31)).replace(day=1)
    |                        ^^^^^^^^^^^^
333 |         dropped: list[PartitionAction] = []
334 |         failures: list[dict[str, Any]] = []
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

BLE001 Do not catch blind exception: `Exception`
   --> app/services/partition_management_service.py:372:24
    |
370 |                         exception=exc,
371 |                     )
372 |                 except Exception as exc:  # pragma: no cover - 防御性分支
    |                        ^^^^^^^^^
373 |                     failures.append(
374 |                         {
    |

PLR2004 Magic value used in comparison, consider replacing `12` with a constant variable
   --> app/services/partition_management_service.py:434:33
    |
432 |         """
433 |         month_start = target_date.replace(day=1)
434 |         if month_start.month == 12:
    |                                 ^^
435 |             month_end = month_start.replace(year=month_start.year + 1, month=1)
436 |         else:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/partition_management_service.py:496:20
    |
494 |                     },
495 |                 )
496 |             except Exception as exc:  # pragma: no cover - 单条记录失败不影响总体
    |                    ^^^^^^^^^
497 |                 log_warning(
498 |                     "处理单个分区信息失败",
    |

DTZ007 Naive datetime constructed using `datetime.datetime.strptime()` without %z
   --> app/services/partition_management_service.py:580:34
    |
578 |                 continue
579 |             try:
580 |                 partition_date = datetime.strptime(date_str, "%Y/%m/%d").date()
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
581 |             except ValueError:
582 |                 continue
    |
help: Call `.replace(tzinfo=<timezone>)` or `.astimezone()` to convert to an aware datetime

TRY300 Consider moving this statement to an `else` block
   --> app/services/partition_management_service.py:602:13
    |
600 |             date_part = partition_name.replace(prefix, "")
601 |             year, month, *_ = date_part.split("_")
602 |             return f"{year}/{month}/01"
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
603 |         except ValueError:
604 |             return None
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/partition_management_service.py:616:17
    |
615 |         """
616 |         query = f"SELECT COUNT(*) FROM {partition_name};"
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
617 |         try:
618 |             result = db.session.execute(text(query)).scalar()
    |

DTZ007 Naive datetime constructed using `datetime.datetime.strptime()` without %z
   --> app/services/partition_management_service.py:643:30
    |
641 |             return "unknown"
642 |         try:
643 |             partition_date = datetime.strptime(date_str, "%Y/%m/%d").date()
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
644 |         except ValueError:
645 |             return "unknown"
    |
help: Call `.replace(tzinfo=<timezone>)` or `.astimezone()` to convert to an aware datetime

DTZ011 `datetime.date.today()` used
   --> app/services/partition_management_service.py:647:17
    |
645 |             return "unknown"
646 |
647 |         today = date.today()
    |                 ^^^^^^^^^^^^
648 |         current_month = today.replace(day=1)
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

PLR2004 Magic value used in comparison, consider replacing `1024` with a constant variable
   --> app/services/partition_management_service.py:722:25
    |
721 |         """
722 |         if size_bytes < 1024:
    |                         ^^^^
723 |             return f"{size_bytes} B"
724 |         if size_bytes < 1024**2:
    |

ANN205 Missing return type annotation for staticmethod `_rollback_on_error`
   --> app/services/partition_management_service.py:731:9
    |
730 |     @staticmethod
731 |     def _rollback_on_error():
    |         ^^^^^^^^^^^^^^^^^^
732 |         """提供一个上下文管理器用于异常时自动回滚事务.
    |
help: Add return type annotation

ANN204 Missing return type annotation for special method `__enter__`
   --> app/services/partition_management_service.py:743:17
    |
741 |         """
742 |         class _RollbackContext:
743 |             def __enter__(self):
    |                 ^^^^^^^^^
744 |                 return self
    |
help: Add return type annotation

ANN204 Missing return type annotation for special method `__exit__`
   --> app/services/partition_management_service.py:746:17
    |
744 |                 return self
745 |
746 |             def __exit__(self, exc_type, exc, tb):
    |                 ^^^^^^^^
747 |                 db.session.rollback()
748 |                 return False
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `exc_type`
   --> app/services/partition_management_service.py:746:32
    |
744 |                 return self
745 |
746 |             def __exit__(self, exc_type, exc, tb):
    |                                ^^^^^^^^
747 |                 db.session.rollback()
748 |                 return False
    |

ANN001 Missing type annotation for function argument `exc`
   --> app/services/partition_management_service.py:746:42
    |
744 |                 return self
745 |
746 |             def __exit__(self, exc_type, exc, tb):
    |                                          ^^^
747 |                 db.session.rollback()
748 |                 return False
    |

ANN001 Missing type annotation for function argument `tb`
   --> app/services/partition_management_service.py:746:47
    |
744 |                 return self
745 |
746 |             def __exit__(self, exc_type, exc, tb):
    |                                               ^^
747 |                 db.session.rollback()
748 |                 return False
    |

INP001 File `app/services/statistics/account_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/account_statistics_service.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/services/statistics/account_statistics_service.py:14:24
   |
12 | from app import db
13 | from app.constants import DatabaseType
14 | from app.errors import SystemError
   |                        ^^^^^^^^^^^
15 | from app.models.account_classification import (
16 |     AccountClassification,
   |

INP001 File `app/services/statistics/database_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/database_statistics_service.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/services/statistics/database_statistics_service.py:13:24
   |
12 | from app import db
13 | from app.errors import SystemError
   |                        ^^^^^^^^^^^
14 | from app.models.database_size_aggregation import DatabaseSizeAggregation
15 | from app.models.instance import Instance
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/statistics/database_statistics_service.py:67:9
   |
65 |           deleted_databases = deleted_databases.scalar() or 0
66 |
67 | /         return {
68 | |             "total_databases": total_databases,
69 | |             "active_databases": active_databases,
70 | |             "inactive_databases": inactive_databases,
71 | |             "deleted_databases": deleted_databases,
72 | |         }
   | |_________^
73 |       except Exception as exc:
74 |           log_error("获取数据库统计失败", module="database_statistics", exception=exc)
   |

C901 `fetch_aggregations` is too complex (12 > 10)
  --> app/services/statistics/database_statistics_service.py:94:5
   |
94 | def fetch_aggregations(
   |     ^^^^^^^^^^^^^^^^^^
95 |     *,
96 |     instance_id: int | None,
   |

PLR0913 Too many arguments in function definition (11 > 5)
  --> app/services/statistics/database_statistics_service.py:94:5
   |
94 | def fetch_aggregations(
   |     ^^^^^^^^^^^^^^^^^^
95 |     *,
96 |     instance_id: int | None,
   |

PLR0912 Too many branches (13 > 12)
  --> app/services/statistics/database_statistics_service.py:94:5
   |
94 | def fetch_aggregations(
   |     ^^^^^^^^^^^^^^^^^^
95 |     *,
96 |     instance_id: int | None,
   |

E501 Line too long (129 > 120)
   --> app/services/statistics/database_statistics_service.py:199:121
    |
197 |             pair_values = [(row.instance_id, row.database_name) for row in top_pairs]
198 |             aggregations = (
199 |                 query.filter(tuple_(DatabaseSizeAggregation.instance_id, DatabaseSizeAggregation.database_name).in_(pair_values))
    |                                                                                                                         ^^^^^^^^^
200 |                 .order_by(DatabaseSizeAggregation.period_start.asc())
201 |                 .all()
    |

C901 `fetch_aggregation_summary` is too complex (11 > 10)
   --> app/services/statistics/database_statistics_service.py:235:5
    |
235 | def fetch_aggregation_summary(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
236 |     *,
237 |     instance_id: int | None,
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> app/services/statistics/database_statistics_service.py:235:5
    |
235 | def fetch_aggregation_summary(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
236 |     *,
237 |     instance_id: int | None,
    |

INP001 File `app/services/statistics/instance_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/instance_statistics_service.py:1:1

A004 Import `SystemError` is shadowing a Python builtin
  --> app/services/statistics/instance_statistics_service.py:12:24
   |
11 | from app import db
12 | from app.errors import SystemError
   |                        ^^^^^^^^^^^
13 | from app.models.instance import Instance
14 | from app.utils.structlog_config import log_error
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/statistics/instance_statistics_service.py:55:9
   |
53 |           normal_instances = active_instances
54 |
55 | /         return {
56 | |             "total_instances": total_instances,
57 | |             "active_instances": active_instances,
58 | |             "normal_instances": normal_instances,
59 | |             "disabled_instances": disabled_instances,
60 | |             "deleted_instances": deleted_instances,
61 | |         }
   | |_________^
62 |       except Exception as exc:
63 |           log_error("获取实例汇总失败", module="instance_statistics", exception=exc)
   |

PLC0415 `import` should be at the top-level of a file
  --> app/services/statistics/instance_statistics_service.py:89:9
   |
87 |     """
88 |     try:
89 |         from app.models.instance_size_stat import InstanceSizeStat
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
90 |
91 |         recent_date = time_utils.now_china().date() - timedelta(days=recent_days)
   |

INP001 File `app/services/statistics/log_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/log_statistics_service.py:1:1

SLF001 Private member accessed: `_mapping`
   --> app/services/statistics/log_statistics_service.py:108:26
    |
106 |             .one_or_none()
107 |         )
108 |         result_mapping = result._mapping if result is not None else {}
    |                          ^^^^^^^^^^^^^^^
109 |
110 |         trend_data: list[dict[str, int | str]] = []
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/statistics/log_statistics_service.py:120:9
    |
118 |             )
119 |
120 |         return trend_data
    |         ^^^^^^^^^^^^^^^^^
121 |     except Exception as exc:
122 |         log_error("获取日志趋势数据失败", module="log_statistics", exception=exc)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/statistics/log_statistics_service.py:121:12
    |
120 |         return trend_data
121 |     except Exception as exc:
    |            ^^^^^^^^^
122 |         log_error("获取日志趋势数据失败", module="log_statistics", exception=exc)
123 |         return []
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/statistics/log_statistics_service.py:152:12
    |
151 |         return [{"level": stat.level.value, "count": stat.count} for stat in level_stats]
152 |     except Exception as exc:
    |            ^^^^^^^^^
153 |         log_error("获取日志级别分布失败", module="log_statistics", exception=exc)
154 |         return []
    |

INP001 File `app/services/statistics/partition_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/partition_statistics_service.py:1:1

D205 1 blank line required between summary line and description
 --> app/services/sync_session_service.py:1:1
  |
1 | / """鲸落 - 同步会话服务
2 | | 管理同步会话和实例记录的业务逻辑.
3 | | """
  | |___^
4 |
5 |   from typing import Any
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/services/sync_session_service.py:30:9
   |
28 |     """
29 |
30 |     def __init__(self) -> None:
   |         ^^^^^^^^
31 |         self.system_logger = get_system_logger()
32 |         self.sync_logger = get_sync_logger()
   |

ANN202 Missing return type annotation for private function `clean_value`
  --> app/services/sync_session_service.py:50:13
   |
48 |             return None
49 |
50 |         def clean_value(value):
   |             ^^^^^^^^^^^
51 |             if hasattr(value, "isoformat"):  # datetime 或 date 对象
52 |                 return value.isoformat()
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `value`
  --> app/services/sync_session_service.py:50:25
   |
48 |             return None
49 |
50 |         def clean_value(value):
   |                         ^^^^^
51 |             if hasattr(value, "isoformat"):  # datetime 或 date 对象
52 |                 return value.isoformat()
   |

E501 Line too long (123 > 120)
  --> app/services/sync_session_service.py:61:121
   |
59 |         return clean_value(sync_details)
60 |
61 |     def create_session(self, sync_type: str, sync_category: str = "account", created_by: int | None = None) -> SyncSession:
   |                                                                                                                         ^^^
62 |         """创建同步会话.
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/sync_session_service.py:95:13
   |
93 |             )
94 |
95 |             return session
   |             ^^^^^^^^^^^^^^
96 |         except Exception as e:
97 |             db.session.rollback()
   |

E501 Line too long (137 > 120)
   --> app/services/sync_session_service.py:107:121
    |
105 | …
106 | …
107 | …s: list[int], sync_category: str = "account") -> list[SyncInstanceRecord]:
    |                                                           ^^^^^^^^^^^^^^^^^
108 | …
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:152:13
    |
150 |             )
151 |
152 |             return records
    |             ^^^^^^^^^^^^^^
153 |         except Exception as e:
154 |             db.session.rollback()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:192:13
    |
190 |             )
191 |
192 |             return True
    |             ^^^^^^^^^^^
193 |         except Exception as e:
194 |             db.session.rollback()
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/services/sync_session_service.py:203:9
    |
201 |             return False
202 |
203 |     def complete_instance_sync(
    |         ^^^^^^^^^^^^^^^^^^^^^^
204 |         self,
205 |         record_id: int,
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:257:13
    |
255 |             )
256 |
257 |             return True
    |             ^^^^^^^^^^^
258 |         except Exception as e:
259 |             db.session.rollback()
    |

E501 Line too long (121 > 120)
   --> app/services/sync_session_service.py:268:121
    |
266 |             return False
267 |
268 |     def fail_instance_sync(self, record_id: int, error_message: str, sync_details: dict[str, Any] | None = None) -> bool:
    |                                                                                                                         ^
269 |         """标记实例同步失败.
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:302:13
    |
300 |             )
301 |
302 |             return True
    |             ^^^^^^^^^^^
303 |         except Exception as e:
304 |             db.session.rollback()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:495:13
    |
493 |                 self.sync_logger.info("取消同步会话", module="sync_session", session_id=session_id)
494 |
495 |             return True
    |             ^^^^^^^^^^^
496 |         except Exception as e:
497 |             db.session.rollback()
    |

PLR0915 Too many statements (66 > 50)
  --> app/tasks/accounts_sync_tasks.py:15:5
   |
15 | def sync_accounts(manual_run: bool = False, created_by: int | None = None, **kwargs: Any) -> None:
   |     ^^^^^^^^^^^^^
16 |     """同步账户任务 - 同步所有实例的账户信息.
   |

FBT001 Boolean-typed positional argument in function definition
  --> app/tasks/accounts_sync_tasks.py:15:19
   |
15 | def sync_accounts(manual_run: bool = False, created_by: int | None = None, **kwargs: Any) -> None:
   |                   ^^^^^^^^^^
16 |     """同步账户任务 - 同步所有实例的账户信息.
   |

FBT002 Boolean default positional argument in function definition
  --> app/tasks/accounts_sync_tasks.py:15:19
   |
15 | def sync_accounts(manual_run: bool = False, created_by: int | None = None, **kwargs: Any) -> None:
   |                   ^^^^^^^^^^
16 |     """同步账户任务 - 同步所有实例的账户信息.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> app/tasks/accounts_sync_tasks.py:15:86
   |
15 | def sync_accounts(manual_run: bool = False, created_by: int | None = None, **kwargs: Any) -> None:
   |                                                                                      ^^^
16 |     """同步账户任务 - 同步所有实例的账户信息.
   |

E501 Line too long (136 > 120)
   --> app/tasks/accounts_sync_tasks.py:115:121
    |
113 | …         continue
114 | …     except PermissionSyncError as permission_error:
115 | …         sync_session_service.fail_instance_sync(record.id, str(permission_error), sync_details=permission_error.summary)
    |                                                                                                           ^^^^^^^^^^^^^^^^
116 | …         sync_logger.exception(
117 | …             "账户同步权限阶段失败",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/accounts_sync_tasks.py:169:33
    |
167 |                     sync_session_service.fail_instance_sync(record.id, str(exc))
168 |
169 |                     sync_logger.error(
    |                                 ^^^^^
170 |                         "实例账户同步异常",
171 |                         module="accounts_sync",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/accounts_sync_tasks.py:205:25
    |
203 |                 db.session.commit()
204 |
205 |             sync_logger.error(
    |                         ^^^^^
206 |                 "账户同步任务失败",
207 |                 module="accounts_sync",
    |

D205 1 blank line required between summary line and description
 --> app/tasks/capacity_aggregation_tasks.py:1:1
  |
1 | / """数据库大小统计聚合定时任务
2 | | 负责计算每周、每月、每季度的统计聚合数据.
3 | | """
  | |___^
4 |
5 |   from collections.abc import Sequence
  |
help: Insert single blank line

ANN001 Missing type annotation for function argument `logger`
  --> app/tasks/capacity_aggregation_tasks.py:23:54
   |
23 | def _select_periods(requested: Sequence[str] | None, logger, allowed_periods: Sequence[str]) -> list[str]:
   |                                                      ^^^^^^
24 |     """根据请求的周期返回有效周期列表.
   |

C901 `calculate_database_size_aggregations` is too complex (26 > 10)
   --> app/tasks/capacity_aggregation_tasks.py:105:5
    |
105 | def calculate_database_size_aggregations(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
106 |     manual_run: bool = False,
107 |     periods: list[str] | None = None,
    |

PLR0912 Too many branches (30 > 12)
   --> app/tasks/capacity_aggregation_tasks.py:105:5
    |
105 | def calculate_database_size_aggregations(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
106 |     manual_run: bool = False,
107 |     periods: list[str] | None = None,
    |

PLR0915 Too many statements (119 > 50)
   --> app/tasks/capacity_aggregation_tasks.py:105:5
    |
105 | def calculate_database_size_aggregations(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
106 |     manual_run: bool = False,
107 |     periods: list[str] | None = None,
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/tasks/capacity_aggregation_tasks.py:106:5
    |
105 | def calculate_database_size_aggregations(
106 |     manual_run: bool = False,
    |     ^^^^^^^^^^
107 |     periods: list[str] | None = None,
108 |     created_by: int | None = None,
    |

FBT002 Boolean default positional argument in function definition
   --> app/tasks/capacity_aggregation_tasks.py:106:5
    |
105 | def calculate_database_size_aggregations(
106 |     manual_run: bool = False,
    |     ^^^^^^^^^^
107 |     periods: list[str] | None = None,
108 |     created_by: int | None = None,
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_aggregation_tasks.py:121:5
    |
120 |     """
121 |     from app import create_app
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
122 |     from app.services.sync_session_service import sync_session_service
123 |     from app.utils.structlog_config import get_sync_logger
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_aggregation_tasks.py:122:5
    |
120 |     """
121 |     from app import create_app
122 |     from app.services.sync_session_service import sync_session_service
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
123 |     from app.utils.structlog_config import get_sync_logger
124 |     from app.utils.time_utils import time_utils
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_aggregation_tasks.py:123:5
    |
121 |     from app import create_app
122 |     from app.services.sync_session_service import sync_session_service
123 |     from app.utils.structlog_config import get_sync_logger
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
124 |     from app.utils.time_utils import time_utils
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_aggregation_tasks.py:124:5
    |
122 |     from app.services.sync_session_service import sync_session_service
123 |     from app.utils.structlog_config import get_sync_logger
124 |     from app.utils.time_utils import time_utils
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
125 |
126 |     app = create_app(init_scheduler_on_start=False)
    |

SIM105 Use `contextlib.suppress(Exception)` instead of `try`-`except`-`pass`
   --> app/tasks/capacity_aggregation_tasks.py:450:17
    |
448 |               )
449 |               if session is not None:
450 | /                 try:
451 | |                     db.session.rollback()
452 | |                 except Exception:  # pragma: no cover - 防御性处理
453 | |                     pass
    | |________________________^
454 |                   # 将仍处于运行状态的实例记录标记为失败
455 |                   leftover_ids = (
    |
help: Replace `try`-`except`-`pass` with `with contextlib.suppress(Exception): ...`

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> app/tasks/capacity_aggregation_tasks.py:452:17
    |
450 |                   try:
451 |                       db.session.rollback()
452 | /                 except Exception:  # pragma: no cover - 防御性处理
453 | |                     pass
    | |________________________^
454 |                   # 将仍处于运行状态的实例记录标记为失败
455 |                   leftover_ids = (
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:452:24
    |
450 |                 try:
451 |                     db.session.rollback()
452 |                 except Exception:  # pragma: no cover - 防御性处理
    |                        ^^^^^^^^^
453 |                     pass
454 |                 # 将仍处于运行状态的实例记录标记为失败
    |

S112 `try`-`except`-`continue` detected, consider logging the exception
   --> app/tasks/capacity_aggregation_tasks.py:465:21
    |
463 |                               error_message=f"聚合任务异常: {exc}",
464 |                           )
465 | /                     except Exception:
466 | |                         continue
    | |________________________________^
467 |                   session.status = "failed"
468 |                   session.completed_at = time_utils.now()
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:465:28
    |
463 |                             error_message=f"聚合任务异常: {exc}",
464 |                         )
465 |                     except Exception:
    |                            ^^^^^^^^^
466 |                         continue
467 |                 session.status = "failed"
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_aggregation_tasks.py:492:5
    |
491 |     """
492 |     from app import create_app
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
493 |
494 |     app = create_app(init_scheduler_on_start=False)
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_aggregation_tasks.py:532:13
    |
530 |                 message=result.get("message"),
531 |             )
532 |             return result
    |             ^^^^^^^^^^^^^
533 |
534 |         except Exception as exc:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:534:16
    |
532 |             return result
533 |
534 |         except Exception as exc:
    |                ^^^^^^^^^
535 |             log_error(
536 |                 "计算实例统计聚合失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_aggregation_tasks.py:560:5
    |
559 |     """
560 |     from app import create_app
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
561 |
562 |     app = create_app(init_scheduler_on_start=False)
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_aggregation_tasks.py:587:13
    |
585 |             )
586 |
587 |             return result
    |             ^^^^^^^^^^^^^
588 |
589 |         except Exception as exc:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:589:16
    |
587 |             return result
588 |
589 |         except Exception as exc:
    |                ^^^^^^^^^
590 |             log_error(
591 |                 "计算指定周期统计聚合失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_aggregation_tasks.py:612:5
    |
611 |     """
612 |     from app import create_app
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
613 |
614 |     app = create_app(init_scheduler_on_start=False)
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_aggregation_tasks.py:617:13
    |
615 |     with app.app_context():
616 |         try:
617 |             from sqlalchemy import desc, func
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
618 |
619 |             from app.models.database_size_aggregation import DatabaseSizeAggregation
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_aggregation_tasks.py:619:13
    |
617 |             from sqlalchemy import desc, func
618 |
619 |             from app.models.database_size_aggregation import DatabaseSizeAggregation
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
620 |
621 |             # 获取今日聚合统计
    |

DTZ011 `datetime.date.today()` used
   --> app/tasks/capacity_aggregation_tasks.py:622:21
    |
621 |             # 获取今日聚合统计
622 |             today = date.today()
    |                     ^^^^^^^^^^^^
623 |
624 |             # 获取最近聚合时间
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:646:16
    |
644 |             }
645 |
646 |         except Exception as exc:
    |                ^^^^^^^^^
647 |             log_error(
648 |                 "获取聚合状态失败",
    |

PLR2004 Magic value used in comparison, consider replacing `23` with a constant variable
   --> app/tasks/capacity_aggregation_tasks.py:675:96
    |
673 |         # 检查聚合时间配置
674 |         aggregation_hour = getattr(Config, "AGGREGATION_HOUR", 4)
675 |         if not isinstance(aggregation_hour, int) or aggregation_hour < 0 or aggregation_hour > 23:
    |                                                                                                ^^
676 |             config_issues.append("聚合时间配置无效,应为0-23之间的整数")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:691:12
    |
689 |         }
690 |
691 |     except Exception as exc:
    |            ^^^^^^^^^
692 |         log_error(
693 |             "验证聚合配置失败",
    |

D205 1 blank line required between summary line and description
 --> app/tasks/capacity_collection_tasks.py:1:1
  |
1 | / """数据库大小采集定时任务
2 | | 负责每日自动采集所有数据库实例的大小信息.
3 | | """
  | |___^
4 |
5 |   from typing import Any
  |
help: Insert single blank line

C901 `collect_database_sizes` is too complex (12 > 10)
  --> app/tasks/capacity_collection_tasks.py:14:5
   |
14 | def collect_database_sizes():
   |     ^^^^^^^^^^^^^^^^^^^^^^
15 |     """容量同步定时任务.
   |

PLR0915 Too many statements (101 > 50)
  --> app/tasks/capacity_collection_tasks.py:14:5
   |
14 | def collect_database_sizes():
   |     ^^^^^^^^^^^^^^^^^^^^^^
15 |     """容量同步定时任务.
   |

ANN201 Missing return type annotation for public function `collect_database_sizes`
  --> app/tasks/capacity_collection_tasks.py:14:5
   |
14 | def collect_database_sizes():
   |     ^^^^^^^^^^^^^^^^^^^^^^
15 |     """容量同步定时任务.
   |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
  --> app/tasks/capacity_collection_tasks.py:24:5
   |
23 |     """
24 |     from app import create_app
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |     from app.services.sync_session_service import sync_session_service
26 |     from app.utils.time_utils import time_utils
   |

PLC0415 `import` should be at the top-level of a file
  --> app/tasks/capacity_collection_tasks.py:25:5
   |
23 |     """
24 |     from app import create_app
25 |     from app.services.sync_session_service import sync_session_service
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 |     from app.utils.time_utils import time_utils
27 |     # 创建Flask应用上下文,确保数据库操作正常
   |

PLC0415 `import` should be at the top-level of a file
  --> app/tasks/capacity_collection_tasks.py:26:5
   |
24 |     from app import create_app
25 |     from app.services.sync_session_service import sync_session_service
26 |     from app.utils.time_utils import time_utils
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |     # 创建Flask应用上下文,确保数据库操作正常
28 |     app = create_app(init_scheduler_on_start=False)
   |

E501 Line too long (140 > 120)
  --> app/tasks/capacity_collection_tasks.py:69:121
   |
67 | …
68 | …]
69 | …session.session_id, instance_ids, sync_category=SyncCategory.CAPACITY.value)
   |                                                          ^^^^^^^^^^^^^^^^^^^^
70 | …
   |

G004 Logging statement uses f-string
  --> app/tasks/capacity_collection_tasks.py:88:25
   |
87 |                     sync_logger.info(
88 |                         f"开始同步实例: {instance.name} (ID: {instance.id})",
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
89 |                         module="capacity_sync",
90 |                         session_id=session.session_id,
   |
help: Convert to lazy `%` formatting

PLC0415 `import` should be at the top-level of a file
  --> app/tasks/capacity_collection_tasks.py:96:21
   |
95 |                       # 调用数据库大小采集服务
96 | /                     from app.services.database_sync import (
97 | |                         DatabaseSizeCollectorService,
98 | |                     )
   | |_____________________^
99 |                       collector = DatabaseSizeCollectorService(instance)
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:126:41
    |
124 |                         except Exception as inventory_error:
125 |                             error_msg = f"同步数据库列表失败: {inventory_error}"
126 |                             sync_logger.error(
    |                                         ^^^^^
127 |                                 error_msg,
128 |                                 module="capacity_sync",
    |

E501 Line too long (124 > 120)
   --> app/tasks/capacity_collection_tasks.py:152:121
    |
150 | …                     items_synced=0,
151 | …                     items_created=inventory_result.get("created", 0),
152 | …                     items_updated=inventory_result.get("refreshed", 0) + inventory_result.get("reactivated", 0),
    |                                                                                                               ^^^^
153 | …                     items_deleted=inventory_result.get("deactivated", 0),
154 | …                     sync_details={
    |

G004 Logging statement uses f-string
   --> app/tasks/capacity_collection_tasks.py:203:33
    |
201 | …                     error_msg = "未采集到任何数据库大小数据"
202 | …                     sync_logger.error(
203 | …                         f"实例容量同步失败: {instance.name} - {error_msg}",
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
204 | …                         module="capacity_sync",
205 | …                         session_id=session.session_id,
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/tasks/capacity_collection_tasks.py:250:29
    |
249 |                         sync_logger.info(
250 |                             f"实例容量同步成功: {instance.name}",
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
251 |                             module="capacity_sync",
252 |                             session_id=session.session_id,
    |
help: Convert to lazy `%` formatting

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:275:33
    |
273 |                 except Exception as e:
274 |                     error_msg = f"实例同步异常: {e!s}"
275 |                     sync_logger.error(
    |                                 ^^^^^
276 |                         error_msg,
277 |                         module="capacity_sync",
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_collection_tasks.py:318:13
    |
316 |             )
317 |
318 |             return result
    |             ^^^^^^^^^^^^^
319 |
320 |         except Exception as e:
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:321:25
    |
320 |         except Exception as e:
321 |             sync_logger.error(
    |                         ^^^^^
322 |                 "容量同步任务执行失败",
323 |                 module="capacity_sync",
    |

C901 `collect_specific_instance_database_sizes` is too complex (11 > 10)
   --> app/tasks/capacity_collection_tasks.py:342:5
    |
342 | def collect_specific_instance_database_sizes(instance_id: int) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
343 |     """采集指定实例的数据库大小信息.
    |

PLR0911 Too many return statements (9 > 6)
   --> app/tasks/capacity_collection_tasks.py:342:5
    |
342 | def collect_specific_instance_database_sizes(instance_id: int) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
343 |     """采集指定实例的数据库大小信息.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_collection_tasks.py:355:5
    |
354 |     """
355 |     from app import create_app
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
356 |     from app.services.database_sync import DatabaseSizeCollectorService
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_collection_tasks.py:356:5
    |
354 |     """
355 |     from app import create_app
356 |     from app.services.database_sync import DatabaseSizeCollectorService
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
357 |
358 |     # 创建Flask应用上下文
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:397:33
    |
395 |                     inventory_result = collector.synchronize_database_inventory()
396 |                 except Exception as inventory_error:
397 |                     sync_logger.error(
    |                                 ^^^^^
398 |                         "同步数据库列表失败",
399 |                         module="capacity_sync",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:435:37
    |
433 |                         saved_count = collector.save_collected_data(databases_data)
434 |                     except Exception as save_error:
435 |                         sync_logger.error(
    |                                     ^^^^^
436 |                             "保存实例容量数据失败",
437 |                             module="capacity_sync",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_collection_tasks.py:461:25
    |
459 |                     # 更新统计聚合,确保图表与报表同步最新容量
460 |                     try:
461 |                         from app.services.aggregation.aggregation_service import AggregationService
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
462 |
463 |                         aggregation_service = AggregationService()
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:467:37
    |
465 |                         aggregation_service.calculate_daily_aggregations_for_instance(instance.id)
466 |                     except Exception as agg_exc:  # pragma: no cover - 防御性日志
467 |                         sync_logger.error(
    |                                     ^^^^^
468 |                             "实例容量聚合刷新失败",
469 |                             module="capacity_sync",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:496:25
    |
495 |         except Exception as e:
496 |             sync_logger.error(
    |                         ^^^^^
497 |                 "采集实例数据库大小失败",
498 |                 module="capacity_sync",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_collection_tasks.py:520:5
    |
519 |     """
520 |     from app import create_app
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
521 |
522 |     # 创建Flask应用上下文
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_collection_tasks.py:565:24
    |
563 |                     else:
564 |                         errors.append(f"实例 {instance.name}: {result['message']}")
565 |                 except Exception as e:
    |                        ^^^^^^^^^
566 |                     errors.append(f"实例 {instance.name}: {e!s}")
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_collection_tasks.py:568:13
    |
566 |                       errors.append(f"实例 {instance.name}: {e!s}")
567 |
568 | /             return {
569 | |                 "success": True,
570 | |                 "message": f"{db_type} 类型数据库大小采集完成",
571 | |                 "instances_processed": total_processed,
572 | |                 "total_size_mb": total_size_mb,
573 | |                 "errors": errors,
574 | |             }
    | |_____________^
575 |
576 |           except Exception as e:
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:577:25
    |
576 |         except Exception as e:
577 |             sync_logger.error(
    |                         ^^^^^
578 |                 "按类型采集数据库容量失败",
579 |                 module="capacity_sync",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_collection_tasks.py:598:5
    |
597 |     """
598 |     from app import create_app
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
599 |     from app.models.instance_size_stat import InstanceSizeStat
600 |     from app.utils.time_utils import time_utils
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_collection_tasks.py:599:5
    |
597 |     """
598 |     from app import create_app
599 |     from app.models.instance_size_stat import InstanceSizeStat
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
600 |     from app.utils.time_utils import time_utils
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_collection_tasks.py:600:5
    |
598 |     from app import create_app
599 |     from app.models.instance_size_stat import InstanceSizeStat
600 |     from app.utils.time_utils import time_utils
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
601 |
602 |     # 创建Flask应用上下文
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:629:25
    |
627 |         except Exception as e:
628 |             sync_logger = get_sync_logger()
629 |             sync_logger.error(
    |                         ^^^^^
630 |                 "获取容量采集状态失败",
631 |                 module="capacity_sync",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/capacity_collection_tasks.py:658:9
    |
657 |           # 检查服务可用性
658 | /         from app.services.database_sync import (
659 | |             DatabaseSizeCollectorService,
660 | |         )
    | |_________^
661 |           DatabaseSizeCollectorService()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_collection_tasks.py:663:9
    |
661 |           DatabaseSizeCollectorService()
662 |
663 | /         return {
664 | |             "success": True,
665 | |             "config": config_checks,
666 | |             "service_available": True,
667 | |             "message": "配置验证通过",
668 | |         }
    | |_________^
669 |
670 |       except Exception as e:
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:672:21
    |
670 |     except Exception as e:
671 |         sync_logger = get_sync_logger()
672 |         sync_logger.error(
    |                     ^^^^^
673 |             "容量采集配置验证失败",
674 |             module="capacity_sync",
    |

PLC0415 `import` should be at the top-level of a file
  --> app/tasks/log_cleanup_tasks.py:35:13
   |
33 |             cleaned_files = _cleanup_temp_files()
34 |
35 |             from app.models.sync_instance_record import SyncInstanceRecord
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 |             from app.models.sync_session import SyncSession
   |

PLC0415 `import` should be at the top-level of a file
  --> app/tasks/log_cleanup_tasks.py:36:13
   |
35 |             from app.models.sync_instance_record import SyncInstanceRecord
36 |             from app.models.sync_session import SyncSession
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 |
38 |             deleted_sync_sessions = SyncSession.query.filter(SyncSession.created_at < cutoff_date).delete()
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
  --> app/tasks/log_cleanup_tasks.py:60:25
   |
58 |         except Exception as exc:
59 |             db.session.rollback()
60 |             task_logger.error(
   |                         ^^^^^
61 |                 "定时任务清理失败",
62 |                 module="task",
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> app/tasks/log_cleanup_tasks.py:82:19
   |
81 |     try:
82 |         log_dir = os.path.join(os.getcwd(), "userdata", "log")
   |                   ^^^^^^^^^^^^
83 |         if os.path.exists(log_dir):
84 |             for filename in os.listdir(log_dir):
   |

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
  --> app/tasks/log_cleanup_tasks.py:82:32
   |
81 |     try:
82 |         log_dir = os.path.join(os.getcwd(), "userdata", "log")
   |                                ^^^^^^^^^
83 |         if os.path.exists(log_dir):
84 |             for filename in os.listdir(log_dir):
   |
help: Replace with `Path.cwd()`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> app/tasks/log_cleanup_tasks.py:83:12
   |
81 |     try:
82 |         log_dir = os.path.join(os.getcwd(), "userdata", "log")
83 |         if os.path.exists(log_dir):
   |            ^^^^^^^^^^^^^^
84 |             for filename in os.listdir(log_dir):
85 |                 if filename.endswith((".tmp", ".temp", ".log.old")):
   |
help: Replace with `Path(...).exists()`

PTH208 Use `pathlib.Path.iterdir()` instead.
  --> app/tasks/log_cleanup_tasks.py:84:29
   |
82 |         log_dir = os.path.join(os.getcwd(), "userdata", "log")
83 |         if os.path.exists(log_dir):
84 |             for filename in os.listdir(log_dir):
   |                             ^^^^^^^^^^
85 |                 if filename.endswith((".tmp", ".temp", ".log.old")):
86 |                     file_path = os.path.join(log_dir, filename)
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> app/tasks/log_cleanup_tasks.py:86:33
   |
84 |             for filename in os.listdir(log_dir):
85 |                 if filename.endswith((".tmp", ".temp", ".log.old")):
86 |                     file_path = os.path.join(log_dir, filename)
   |                                 ^^^^^^^^^^^^
87 |                     try:
88 |                         os.remove(file_path)
   |

PTH107 `os.remove()` should be replaced by `Path.unlink()`
  --> app/tasks/log_cleanup_tasks.py:88:25
   |
86 |                     file_path = os.path.join(log_dir, filename)
87 |                     try:
88 |                         os.remove(file_path)
   |                         ^^^^^^^^^
89 |                         cleaned_count += 1
90 |                     except OSError:
   |
help: Replace with `Path(...).unlink()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> app/tasks/log_cleanup_tasks.py:93:22
   |
91 |                         pass
92 |
93 |         export_dir = os.path.join(os.getcwd(), "userdata", "exports")
   |                      ^^^^^^^^^^^^
94 |         if os.path.exists(export_dir):
95 |             for filename in os.listdir(export_dir):
   |

PTH109 `os.getcwd()` should be replaced by `Path.cwd()`
  --> app/tasks/log_cleanup_tasks.py:93:35
   |
91 |                         pass
92 |
93 |         export_dir = os.path.join(os.getcwd(), "userdata", "exports")
   |                                   ^^^^^^^^^
94 |         if os.path.exists(export_dir):
95 |             for filename in os.listdir(export_dir):
   |
help: Replace with `Path.cwd()`

PTH110 `os.path.exists()` should be replaced by `Path.exists()`
  --> app/tasks/log_cleanup_tasks.py:94:12
   |
93 |         export_dir = os.path.join(os.getcwd(), "userdata", "exports")
94 |         if os.path.exists(export_dir):
   |            ^^^^^^^^^^^^^^
95 |             for filename in os.listdir(export_dir):
96 |                 if filename.endswith((".tmp", ".temp")):
   |
help: Replace with `Path(...).exists()`

PTH208 Use `pathlib.Path.iterdir()` instead.
  --> app/tasks/log_cleanup_tasks.py:95:29
   |
93 |         export_dir = os.path.join(os.getcwd(), "userdata", "exports")
94 |         if os.path.exists(export_dir):
95 |             for filename in os.listdir(export_dir):
   |                             ^^^^^^^^^^
96 |                 if filename.endswith((".tmp", ".temp")):
97 |                     file_path = os.path.join(export_dir, filename)
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> app/tasks/log_cleanup_tasks.py:97:33
   |
95 |             for filename in os.listdir(export_dir):
96 |                 if filename.endswith((".tmp", ".temp")):
97 |                     file_path = os.path.join(export_dir, filename)
   |                                 ^^^^^^^^^^^^
98 |                     try:
99 |                         os.remove(file_path)
   |

PTH107 `os.remove()` should be replaced by `Path.unlink()`
   --> app/tasks/log_cleanup_tasks.py:99:25
    |
 97 |                     file_path = os.path.join(export_dir, filename)
 98 |                     try:
 99 |                         os.remove(file_path)
    |                         ^^^^^^^^^
100 |                         cleaned_count += 1
101 |                     except OSError:
    |
help: Replace with `Path(...).unlink()`

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/log_cleanup_tasks.py:104:12
    |
102 |                         pass
103 |
104 |     except Exception as exc:
    |            ^^^^^^^^^
105 |         get_task_logger().warning(f"清理临时文件时出错: {exc}")
    |

D205 1 blank line required between summary line and description
 --> app/tasks/partition_management_tasks.py:1:1
  |
1 | / """分区管理定时任务
2 | | 负责自动创建、清理和监控数据库大小统计表的分区.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

TRY300 Consider moving this statement to an `else` block
  --> app/tasks/partition_management_tasks.py:56:9
   |
54 |             message="分区创建任务已完成",
55 |         )
56 |         return payload
   |         ^^^^^^^^^^^^^^
57 |     except Exception as exc:
58 |         app_error = _as_app_error(exc)
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/tasks/partition_management_tasks.py:57:12
   |
55 |         )
56 |         return payload
57 |     except Exception as exc:
   |            ^^^^^^^^^
58 |         app_error = _as_app_error(exc)
59 |         log_error("分区创建任务失败", module=MODULE, exception=exc)
   |

TRY300 Consider moving this statement to an `else` block
  --> app/tasks/partition_management_tasks.py:93:9
   |
91 |             message="旧分区清理任务已完成",
92 |         )
93 |         return payload
   |         ^^^^^^^^^^^^^^
94 |     except Exception as exc:
95 |         app_error = _as_app_error(exc)
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/tasks/partition_management_tasks.py:94:12
   |
92 |         )
93 |         return payload
94 |     except Exception as exc:
   |            ^^^^^^^^^
95 |         app_error = _as_app_error(exc)
96 |         log_error("旧分区清理任务失败", module=MODULE, exception=exc)
   |

DTZ011 `datetime.date.today()` used
   --> app/tasks/partition_management_tasks.py:118:24
    |
116 |         stats = stats_service.get_partition_statistics()
117 |
118 |         current_date = date.today()
    |                        ^^^^^^^^^^^^
119 |         next_month = (current_date.replace(day=1) + timedelta(days=32)).replace(day=1)
120 |         from app.utils.time_utils import time_utils
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

PLC0415 `import` should be at the top-level of a file
   --> app/tasks/partition_management_tasks.py:120:9
    |
118 |         current_date = date.today()
119 |         next_month = (current_date.replace(day=1) + timedelta(days=32)).replace(day=1)
120 |         from app.utils.time_utils import time_utils
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
121 |         next_partition_name = f"database_size_stats_{time_utils.format_china_time(next_month, '%Y_%m')}"
122 |         partitions = partition_info["partitions"]
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/partition_management_tasks.py:158:9
    |
156 |             message="分区健康监控完成",
157 |         )
158 |         return payload
    |         ^^^^^^^^^^^^^^
159 |     except Exception as exc:
160 |         app_error = _as_app_error(exc)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/partition_management_tasks.py:159:12
    |
157 |         )
158 |         return payload
159 |     except Exception as exc:
    |            ^^^^^^^^^
160 |         app_error = _as_app_error(exc)
161 |         log_error("分区健康监控任务失败", module=MODULE, exception=exc)
    |

DTZ011 `datetime.date.today()` used
   --> app/tasks/partition_management_tasks.py:182:24
    |
181 |         partitions = partition_info["partitions"]
182 |         current_date = date.today()
    |                        ^^^^^^^^^^^^
183 |
184 |         required_partitions: list[str] = []
    |
help: Use `datetime.datetime.now(tz=...).date()` instead

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/partition_management_tasks.py:201:12
    |
199 |             "partitions": partitions,
200 |         }
201 |     except Exception as exc:
    |            ^^^^^^^^^
202 |         app_error = _as_app_error(exc)
203 |         log_error("获取分区管理状态失败", module=MODULE, exception=exc)
    |

B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   --> app/tasks/partition_management_tasks.py:204:9
    |
202 |         app_error = _as_app_error(exc)
203 |         log_error("获取分区管理状态失败", module=MODULE, exception=exc)
204 |         raise app_error
    |         ^^^^^^^^^^^^^^^
    |

D205 1 blank line required between summary line and description
 --> app/utils/cache_utils.py:1:1
  |
1 | / """鲸落 - 缓存管理工具
2 | | 基于Flask-Caching的通用缓存管理器,提供装饰器和通用缓存功能.
3 | | """
  | |___^
4 |
5 |   import hashlib
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/utils/cache_utils.py:28:9
   |
26 |     """
27 |
28 |     def __init__(self, cache: Cache) -> None:
   |         ^^^^^^^^
29 |         self.cache = cache
30 |         self.default_timeout = 300  # 5分钟默认超时
   |

ANN002 Missing type annotation for `*args`
  --> app/utils/cache_utils.py:33:42
   |
31 |         self.system_logger = get_system_logger()
32 |
33 |     def _generate_key(self, prefix: str, *args, **kwargs: Any) -> str:
   |                                          ^^^^^
34 |         """生成缓存键.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> app/utils/cache_utils.py:33:59
   |
31 |         self.system_logger = get_system_logger()
32 |
33 |     def _generate_key(self, prefix: str, *args, **kwargs: Any) -> str:
   |                                                           ^^^
34 |         """生成缓存键.
   |

ERA001 Found commented-out code
  --> app/utils/cache_utils.py:51:9
   |
49 |         key_string = json.dumps(key_data, sort_keys=True, default=str)
50 |
51 |         # 生成哈希值(使用SHA256替代MD5)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
52 |         key_hash = hashlib.sha256(key_string.encode()).hexdigest()
   |
help: Remove commented-out code

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get`
  --> app/utils/cache_utils.py:56:32
   |
54 |         return f"{prefix}:{key_hash}"
55 |
56 |     def get(self, key: str) -> Any | None:
   |                                ^^^^^^^^^^
57 |         """获取缓存值.
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/utils/cache_utils.py:68:16
   |
66 |         try:
67 |             return self.cache.get(key)
68 |         except Exception as e:
   |                ^^^^^^^^^
69 |             self.system_logger.warning("获取缓存失败", module="cache", key=key, exception=str(e))
70 |             return None
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
  --> app/utils/cache_utils.py:72:36
   |
70 |             return None
71 |
72 |     def set(self, key: str, value: Any, timeout: int | None = None) -> bool:
   |                                    ^^^
73 |         """设置缓存值.
   |

TRY300 Consider moving this statement to an `else` block
  --> app/utils/cache_utils.py:87:13
   |
85 |             timeout = timeout or self.default_timeout
86 |             self.cache.set(key, value, timeout=timeout)
87 |             return True
   |             ^^^^^^^^^^^
88 |         except Exception as e:
89 |             self.system_logger.warning("设置缓存失败", module="cache", key=key, exception=str(e))
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/utils/cache_utils.py:88:16
   |
86 |             self.cache.set(key, value, timeout=timeout)
87 |             return True
88 |         except Exception as e:
   |                ^^^^^^^^^
89 |             self.system_logger.warning("设置缓存失败", module="cache", key=key, exception=str(e))
90 |             return False
   |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/cache_utils.py:104:13
    |
102 |         try:
103 |             self.cache.delete(key)
104 |             return True
    |             ^^^^^^^^^^^
105 |         except Exception:
106 |             self.system_logger.warning("删除缓存失败: {key}, 错误: {e}")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/cache_utils.py:105:16
    |
103 |             self.cache.delete(key)
104 |             return True
105 |         except Exception:
    |                ^^^^^^^^^
106 |             self.system_logger.warning("删除缓存失败: {key}, 错误: {e}")
107 |             return False
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/cache_utils.py:118:13
    |
116 |         try:
117 |             self.cache.clear()
118 |             return True
    |             ^^^^^^^^^^^
119 |         except Exception:
120 |             self.system_logger.warning("清空缓存失败: {e}")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/cache_utils.py:119:16
    |
117 |             self.cache.clear()
118 |             return True
119 |         except Exception:
    |                ^^^^^^^^^
120 |             self.system_logger.warning("清空缓存失败: {e}")
121 |             return False
    |

ANN002 Missing type annotation for `*args`
   --> app/utils/cache_utils.py:123:80
    |
121 |             return False
122 |
123 |     def get_or_set(self, key: str, func: Callable, timeout: int | None = None, *args, **kwargs: Any) -> Any:
    |                                                                                ^^^^^
124 |         """获取缓存值,如果不存在则调用函数生成并写入.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/cache_utils.py:123:97
    |
121 |             return False
122 |
123 |     def get_or_set(self, key: str, func: Callable, timeout: int | None = None, *args, **kwargs: Any) -> Any:
    |                                                                                                 ^^^
124 |         """获取缓存值,如果不存在则调用函数生成并写入.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get_or_set`
   --> app/utils/cache_utils.py:123:105
    |
121 |             return False
122 |
123 |     def get_or_set(self, key: str, func: Callable, timeout: int | None = None, *args, **kwargs: Any) -> Any:
    |                                                                                                         ^^^
124 |         """获取缓存值,如果不存在则调用函数生成并写入.
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/cache_utils.py:159:13
    |
157 |                 return self.cache.cache.delete_pattern(pattern)
158 |             self.system_logger.warning("当前缓存后端不支持模式删除")
159 |             return 0
    |             ^^^^^^^^
160 |         except Exception:
161 |             self.system_logger.warning("模式删除缓存失败: {pattern}, 错误: {e}")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/cache_utils.py:160:16
    |
158 |             self.system_logger.warning("当前缓存后端不支持模式删除")
159 |             return 0
160 |         except Exception:
    |                ^^^^^^^^^
161 |             self.system_logger.warning("模式删除缓存失败: {pattern}, 错误: {e}")
162 |             return 0
    |

PLW0603 Using the global statement to update `cache_manager` is discouraged
   --> app/utils/cache_utils.py:179:12
    |
178 |     """
179 |     global cache_manager
    |            ^^^^^^^^^^^^^
180 |     cache_manager = CacheManager(cache)
181 |     system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   --> app/utils/cache_utils.py:206:39
    |
204 |     def cache_decorator(f: Callable) -> Callable:
205 |         @wraps(f)
206 |         def decorated_function(*args: "Any", **kwargs: "Any") -> "Any":
    |                                       ^^^^^
207 |             # 检查是否跳过缓存
208 |             if unless and unless():
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/cache_utils.py:206:56
    |
204 |     def cache_decorator(f: Callable) -> Callable:
205 |         @wraps(f)
206 |         def decorated_function(*args: "Any", **kwargs: "Any") -> "Any":
    |                                                        ^^^^^
207 |             # 检查是否跳过缓存
208 |             if unless and unless():
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
   --> app/utils/cache_utils.py:206:66
    |
204 |     def cache_decorator(f: Callable) -> Callable:
205 |         @wraps(f)
206 |         def decorated_function(*args: "Any", **kwargs: "Any") -> "Any":
    |                                                                  ^^^^^
207 |             # 检查是否跳过缓存
208 |             if unless and unless():
    |

SLF001 Private member accessed: `_generate_key`
   --> app/utils/cache_utils.py:215:29
    |
213 |                 cache_key = key_func(*args, **kwargs)
214 |             else:
215 |                 cache_key = cache_manager._generate_key(f"{key_prefix}:{f.__name__}", *args, **kwargs)
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
216 |
217 |             # 尝试获取缓存
    |

D205 1 blank line required between summary line and description
 --> app/utils/data_validator.py:1:1
  |
1 | / """数据验证工具类
2 | | 提供严格的数据验证功能,防止无效数据进入系统.
3 | | """
  | |___^
4 |
5 |   import html
  |
help: Insert single blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/utils/data_validator.py:34:26
   |
33 |     # 支持的数据库类型
34 |     SUPPORTED_DB_TYPES = ["mysql", "postgresql", "sqlserver", "oracle", "sqlite"]
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
35 |
36 |     # 支持的凭据类型
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/utils/data_validator.py:37:34
   |
36 |     # 支持的凭据类型
37 |     SUPPORTED_CREDENTIAL_TYPES = ["database", "ssh", "windows", "api", "ldap"]
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |     _custom_db_types: set[str] | None = None
   |

C901 `validate_instance_data` is too complex (14 > 10)
  --> app/utils/data_validator.py:51:9
   |
50 |     @classmethod
51 |     def validate_instance_data(cls, data: dict[str, Any]) -> tuple[bool, str | None]:
   |         ^^^^^^^^^^^^^^^^^^^^^^
52 |         """验证实例数据.
   |

PLR0911 Too many return statements (10 > 6)
  --> app/utils/data_validator.py:51:9
   |
50 |     @classmethod
51 |     def validate_instance_data(cls, data: dict[str, Any]) -> tuple[bool, str | None]:
   |         ^^^^^^^^^^^^^^^^^^^^^^
52 |         """验证实例数据.
   |

PLR0912 Too many branches (13 > 12)
  --> app/utils/data_validator.py:51:9
   |
50 |     @classmethod
51 |     def validate_instance_data(cls, data: dict[str, Any]) -> tuple[bool, str | None]:
   |         ^^^^^^^^^^^^^^^^^^^^^^
52 |         """验证实例数据.
   |

ERA001 Found commented-out code
  --> app/utils/data_validator.py:93:13
   |
91 |                 return False, port_error
92 |
93 |             # 验证数据库名称(可选)
   |             ^^^^^^^^^^^^^^^^^^^^^^
94 |             if data.get("database_name"):
95 |                 db_name_error = cls._validate_database_name(data.get("database_name"))
   |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/data_validator.py:99:13
    |
 97 |                     return False, db_name_error
 98 |
 99 |             # 验证描述(可选)
    |             ^^^^^^^^^^^^^^^^
100 |             if data.get("description"):
101 |                 desc_error = cls._validate_description(data.get("description"))
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/data_validator.py:105:13
    |
103 |                     return False, desc_error
104 |
105 |             # 验证凭据ID(可选)
    |             ^^^^^^^^^^^^^^^^^^
106 |             if data.get("credential_id"):
107 |                 cred_error = cls._validate_credential_id(data.get("credential_id"))
    |
help: Remove commented-out code

TRY300 Consider moving this statement to an `else` block
   --> app/utils/data_validator.py:111:13
    |
109 |                     return False, cred_error
110 |
111 |             return True, None
    |             ^^^^^^^^^^^^^^^^^
112 |
113 |         except Exception as e:
    |

G004 Logging statement uses f-string
   --> app/utils/data_validator.py:114:30
    |
113 |         except Exception as e:
114 |             logger.exception(f"数据验证过程中发生错误: {e!s}")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
115 |             return False, f"数据验证失败: {e!s}"
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/utils/data_validator.py:114:46
    |
113 |         except Exception as e:
114 |             logger.exception(f"数据验证过程中发生错误: {e!s}")
    |                                                         ^
115 |             return False, f"数据验证失败: {e!s}"
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `name`
   --> app/utils/data_validator.py:118:35
    |
117 |     @classmethod
118 |     def _validate_name(cls, name: Any) -> str | None:
    |                                   ^^^
119 |         """验证实例名称并返回错误信息.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `db_type`
   --> app/utils/data_validator.py:145:41
    |
144 |     @classmethod
145 |     def _validate_db_type(cls, db_type: Any) -> str | None:
    |                                         ^^^
146 |         """验证数据库类型是否在受支持范围.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `host`
   --> app/utils/data_validator.py:166:35
    |
165 |     @classmethod
166 |     def _validate_host(cls, host: Any) -> str | None:
    |                                   ^^^
167 |         """验证主机地址格式.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `port`
   --> app/utils/data_validator.py:193:35
    |
192 |     @classmethod
193 |     def _validate_port(cls, port: Any) -> str | None:
    |                                   ^^^
194 |         """验证端口号是否处于允许范围.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `db_name`
   --> app/utils/data_validator.py:214:47
    |
213 |     @classmethod
214 |     def _validate_database_name(cls, db_name: Any) -> str | None:
    |                                               ^^^
215 |         """验证数据库名称长度与字符集合.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `description`
   --> app/utils/data_validator.py:241:49
    |
240 |     @classmethod
241 |     def _validate_description(cls, description: Any) -> str | None:
    |                                                 ^^^
242 |         """验证描述字段长度.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `credential_id`
   --> app/utils/data_validator.py:261:53
    |
260 |     @classmethod
261 |     def _validate_credential_id(cls, credential_id: Any) -> str | None:
    |                                                     ^^^
262 |         """验证凭据 ID 是否为正整数.
    |

PLR2004 Magic value used in comparison, consider replacing `255` with a constant variable
   --> app/utils/data_validator.py:295:42
    |
293 |         if re.match(ip_pattern, host):
294 |             parts = host.split(".")
295 |             return all(0 <= int(part) <= 255 for part in parts)
    |                                          ^^^
296 |
297 |         # 检查域名格式
    |

E501 Line too long (123 > 120)
   --> app/utils/data_validator.py:298:121
    |
297 |         # 检查域名格式
298 |         domain_pattern = r"^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$"
    |                                                                                                                         ^^^
299 |         return bool(re.match(domain_pattern, host))
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/utils/data_validator.py:329:37
    |
328 |     @classmethod
329 |     def sanitize_string(cls, value: Any) -> str:
    |                                     ^^^
330 |         """清理字符串,移除潜在的危险内容.
    |

C901 `sanitize_form_data` is too complex (12 > 10)
   --> app/utils/data_validator.py:380:9
    |
379 |     @classmethod
380 |     def sanitize_form_data(cls, data: Mapping[str, Any]) -> dict[str, Any]:
    |         ^^^^^^^^^^^^^^^^^^
381 |         """清理表单提交的数据结构.
    |

PLR0912 Too many branches (14 > 12)
   --> app/utils/data_validator.py:380:9
    |
379 |     @classmethod
380 |     def sanitize_form_data(cls, data: Mapping[str, Any]) -> dict[str, Any]:
    |         ^^^^^^^^^^^^^^^^^^
381 |         """清理表单提交的数据结构.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `db_type`
   --> app/utils/data_validator.py:448:40
    |
447 |     @classmethod
448 |     def validate_db_type(cls, db_type: Any) -> str | None:
    |                                        ^^^
449 |         """验证数据库类型是否受支持.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/data_validator.py:488:13
    |
487 |         try:
488 |             from app.services.database_type_service import DatabaseTypeService
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
489 |
490 |             configs = DatabaseTypeService.get_active_types()
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/data_validator.py:494:16
    |
492 |             if dynamic_types:
493 |                 return dynamic_types
494 |         except Exception as exc:
    |                ^^^^^^^^^
495 |             logger.warning("获取数据库类型配置失败,回退到静态白名单: %s", exc)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `credential_type`
   --> app/utils/data_validator.py:500:56
    |
499 |     @classmethod
500 |     def validate_credential_type(cls, credential_type: Any) -> str | None:
    |                                                        ^^^
501 |         """验证凭据类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `username`
   --> app/utils/data_validator.py:526:37
    |
525 |     @staticmethod
526 |     def validate_username(username: Any) -> str | None:
    |                                     ^^^
527 |         """验证用户名格式.
    |

PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   --> app/utils/data_validator.py:545:30
    |
544 |         normalized = username.strip()
545 |         if len(normalized) < 3:
    |                              ^
546 |             return "用户名长度至少3个字符"
    |

PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   --> app/utils/data_validator.py:548:30
    |
546 |             return "用户名长度至少3个字符"
547 |
548 |         if len(normalized) > 50:
    |                              ^^
549 |             return "用户名长度不能超过50个字符"
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `password`
   --> app/utils/data_validator.py:557:37
    |
556 |     @staticmethod
557 |     def validate_password(password: Any) -> str | None:
    |                                     ^^^
558 |         """验证密码强度.
    |

PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   --> app/utils/data_validator.py:575:28
    |
573 |             return "密码必须是字符串"
574 |
575 |         if len(password) < 6:
    |                            ^
576 |             return "密码长度至少6个字符"
    |

PLR2004 Magic value used in comparison, consider replacing `128` with a constant variable
   --> app/utils/data_validator.py:578:28
    |
576 |             return "密码长度至少6个字符"
577 |
578 |         if len(password) > 128:
    |                            ^^^
579 |             return "密码长度不能超过128个字符"
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `db_type`
   --> app/utils/data_validator.py:613:31
    |
613 | def validate_db_type(db_type: Any) -> str | None:
    |                               ^^^
614 |     """函数式入口校验数据库类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `credential_type`
   --> app/utils/data_validator.py:626:47
    |
626 | def validate_credential_type(credential_type: Any) -> str | None:
    |                                               ^^^
627 |     """函数式入口校验凭据类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `username`
   --> app/utils/data_validator.py:639:33
    |
639 | def validate_username(username: Any) -> str | None:
    |                                 ^^^
640 |     """函数式入口校验用户名.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `password`
   --> app/utils/data_validator.py:652:33
    |
652 | def validate_password(password: Any) -> str | None:
    |                                 ^^^
653 |     """函数式入口校验密码.
    |

D205 1 blank line required between summary line and description
 --> app/utils/database_batch_manager.py:1:1
  |
1 | / """鲸落 - 数据库批量操作管理器
2 | | 提供高效的批量提交机制,优化大量数据处理性能.
3 | | """
  | |___^
4 |
5 |   from typing import Any
  |
help: Insert single blank line

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `logger`
  --> app/utils/database_batch_manager.py:36:55
   |
34 |     """
35 |
36 |     def __init__(self, batch_size: int = 100, logger: Any | None = None, instance_name: str = "") -> None:
   |                                                       ^^^^^^^^^^
37 |         """初始化批量管理器.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `entity`
  --> app/utils/database_batch_manager.py:65:58
   |
63 |         )
64 |
65 |     def add_operation(self, operation_type: str, entity: Any, description: str = "") -> None:
   |                                                          ^^^
66 |         """添加数据库操作到批次队列.
   |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/database_batch_manager.py:160:13
    |
158 |             # 清空当前批次
159 |             self.pending_operations.clear()
160 |             return True
    |             ^^^^^^^^^^^
161 |
162 |         except Exception as e:
    |

ANN204 Missing return type annotation for special method `__enter__`
   --> app/utils/database_batch_manager.py:263:9
    |
261 |         }
262 |
263 |     def __enter__(self):
    |         ^^^^^^^^^
264 |         """上下文管理器入口.
    |
help: Add return type annotation

PYI036 The first argument in `__exit__` should be annotated with `object` or `type[BaseException] | None`
   --> app/utils/database_batch_manager.py:272:34
    |
270 |         return self
271 |
272 |     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
    |                                  ^^^
273 |         """上下文管理器出口.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `exc_type`
   --> app/utils/database_batch_manager.py:272:34
    |
270 |         return self
271 |
272 |     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
    |                                  ^^^
273 |         """上下文管理器出口.
    |

PYI036 The second argument in `__exit__` should be annotated with `object` or `BaseException | None`
   --> app/utils/database_batch_manager.py:272:48
    |
270 |         return self
271 |
272 |     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
    |                                                ^^^
273 |         """上下文管理器出口.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `exc_val`
   --> app/utils/database_batch_manager.py:272:48
    |
270 |         return self
271 |
272 |     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
    |                                                ^^^
273 |         """上下文管理器出口.
    |

PYI036 The third argument in `__exit__` should be annotated with `object` or `types.TracebackType | None`
   --> app/utils/database_batch_manager.py:272:61
    |
270 |         return self
271 |
272 |     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
    |                                                             ^^^
273 |         """上下文管理器出口.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `exc_tb`
   --> app/utils/database_batch_manager.py:272:61
    |
270 |         return self
271 |
272 |     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
    |                                                             ^^^
273 |         """上下文管理器出口.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
  --> app/utils/decorators.py:18:23
   |
16 | SAFE_CSRF_METHODS = {"GET", "HEAD", "OPTIONS", "TRACE"}
17 |
18 | def admin_required(f: Any) -> Any:
   |                       ^^^
19 |     """确保被装饰函数仅允许管理员访问的装饰器.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `admin_required`
  --> app/utils/decorators.py:18:31
   |
16 | SAFE_CSRF_METHODS = {"GET", "HEAD", "OPTIONS", "TRACE"}
17 |
18 | def admin_required(f: Any) -> Any:
   |                               ^^^
19 |     """确保被装饰函数仅允许管理员访问的装饰器.
   |

ANN002 Missing type annotation for `*args`
  --> app/utils/decorators.py:37:28
   |
36 |     @wraps(f)
37 |     def decorated_function(*args, **kwargs: Any) -> Any:
   |                            ^^^^^
38 |         system_logger = get_system_logger()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> app/utils/decorators.py:37:45
   |
36 |     @wraps(f)
37 |     def decorated_function(*args, **kwargs: Any) -> Any:
   |                                             ^^^
38 |         system_logger = get_system_logger()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
  --> app/utils/decorators.py:37:53
   |
36 |     @wraps(f)
37 |     def decorated_function(*args, **kwargs: Any) -> Any:
   |                                                     ^^^
38 |         system_logger = get_system_logger()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:111:23
    |
111 | def login_required(f: Any) -> Any:
    |                       ^^^
112 |     """要求调用者已登录的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `login_required`
   --> app/utils/decorators.py:111:31
    |
111 | def login_required(f: Any) -> Any:
    |                               ^^^
112 |     """要求调用者已登录的装饰器.
    |

ANN002 Missing type annotation for `*args`
   --> app/utils/decorators.py:123:28
    |
122 |     @wraps(f)
123 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                            ^^^^^
124 |         system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/decorators.py:123:45
    |
122 |     @wraps(f)
123 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                                             ^^^
124 |         system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
   --> app/utils/decorators.py:123:53
    |
122 |     @wraps(f)
123 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                                                     ^^^
124 |         system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `permission_required`
   --> app/utils/decorators.py:168:45
    |
168 | def permission_required(permission: str) -> Any:
    |                                             ^^^
169 |     """校验指定权限(view/create/update/delete)的装饰器工厂.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:179:22
    |
177 |     """
178 |
179 |     def decorator(f: Any) -> Any:
    |                      ^^^
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:179:30
    |
177 |     """
178 |
179 |     def decorator(f: Any) -> Any:
    |                              ^^^
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |

ANN002 Missing type annotation for `*args`
   --> app/utils/decorators.py:181:32
    |
179 |     def decorator(f: Any) -> Any:
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |                                ^^^^^
182 |             system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/decorators.py:181:49
    |
179 |     def decorator(f: Any) -> Any:
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |                                                 ^^^
182 |             system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
   --> app/utils/decorators.py:181:57
    |
179 |     def decorator(f: Any) -> Any:
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |                                                         ^^^
182 |             system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:283:21
    |
283 | def require_csrf(f: Any) -> Any:
    |                     ^^^
284 |     """统一的 CSRF 校验装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `require_csrf`
   --> app/utils/decorators.py:283:29
    |
283 | def require_csrf(f: Any) -> Any:
    |                             ^^^
284 |     """统一的 CSRF 校验装饰器.
    |

ANN002 Missing type annotation for `*args`
   --> app/utils/decorators.py:295:28
    |
294 |     @wraps(f)
295 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                            ^^^^^
296 |         if request.method.upper() in SAFE_CSRF_METHODS:
297 |             return f(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/decorators.py:295:45
    |
294 |     @wraps(f)
295 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                                             ^^^
296 |         if request.method.upper() in SAFE_CSRF_METHODS:
297 |             return f(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
   --> app/utils/decorators.py:295:53
    |
294 |     @wraps(f)
295 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                                                     ^^^
296 |         if request.method.upper() in SAFE_CSRF_METHODS:
297 |             return f(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `user`
   --> app/utils/decorators.py:347:26
    |
347 | def has_permission(user: Any, permission: str) -> bool:
    |                          ^^^
348 |     """检查给定用户是否具备指定权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:382:22
    |
382 | def view_required(f: Any = None, *, permission: str = "view") -> Any:
    |                      ^^^
383 |     """校验查看权限的装饰器,可直接使用或指定自定义权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `view_required`
   --> app/utils/decorators.py:382:66
    |
382 | def view_required(f: Any = None, *, permission: str = "view") -> Any:
    |                                                                  ^^^
383 |     """校验查看权限的装饰器,可直接使用或指定自定义权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/utils/decorators.py:394:25
    |
392 |     """
393 |
394 |     def decorator(func: Any) -> Any:
    |                         ^^^
395 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:394:33
    |
392 |     """
393 |
394 |     def decorator(func: Any) -> Any:
    |                                 ^^^
395 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:402:24
    |
402 | def create_required(f: Any = None, *, permission: str = "create") -> Any:
    |                        ^^^
403 |     """校验创建权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `create_required`
   --> app/utils/decorators.py:402:70
    |
402 | def create_required(f: Any = None, *, permission: str = "create") -> Any:
    |                                                                      ^^^
403 |     """校验创建权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/utils/decorators.py:414:25
    |
412 |     """
413 |
414 |     def decorator(func: Any) -> Any:
    |                         ^^^
415 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:414:33
    |
412 |     """
413 |
414 |     def decorator(func: Any) -> Any:
    |                                 ^^^
415 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:422:24
    |
422 | def update_required(f: Any = None, *, permission: str = "update") -> Any:
    |                        ^^^
423 |     """校验更新权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `update_required`
   --> app/utils/decorators.py:422:70
    |
422 | def update_required(f: Any = None, *, permission: str = "update") -> Any:
    |                                                                      ^^^
423 |     """校验更新权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/utils/decorators.py:434:25
    |
432 |     """
433 |
434 |     def decorator(func: Any) -> Any:
    |                         ^^^
435 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:434:33
    |
432 |     """
433 |
434 |     def decorator(func: Any) -> Any:
    |                                 ^^^
435 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:442:24
    |
442 | def delete_required(f: Any = None, *, permission: str = "delete") -> Any:
    |                        ^^^
443 |     """校验删除权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `delete_required`
   --> app/utils/decorators.py:442:70
    |
442 | def delete_required(f: Any = None, *, permission: str = "delete") -> Any:
    |                                                                      ^^^
443 |     """校验删除权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/utils/decorators.py:454:25
    |
452 |     """
453 |
454 |     def decorator(func: Any) -> Any:
    |                         ^^^
455 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:454:33
    |
452 |     """
453 |
454 |     def decorator(func: Any) -> Any:
    |                                 ^^^
455 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:462:32
    |
462 | def scheduler_view_required(f: Any) -> Any:
    |                                ^^^
463 |     """定时任务查看权限装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `scheduler_view_required`
   --> app/utils/decorators.py:462:40
    |
462 | def scheduler_view_required(f: Any) -> Any:
    |                                        ^^^
463 |     """定时任务查看权限装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:475:34
    |
475 | def scheduler_manage_required(f: Any) -> Any:
    |                                  ^^^
476 |     """定时任务管理权限装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `scheduler_manage_required`
   --> app/utils/decorators.py:475:42
    |
475 | def scheduler_manage_required(f: Any) -> Any:
    |                                          ^^^
476 |     """定时任务管理权限装饰器.
    |

PLC0415 `import` should be at the top-level of a file
  --> app/utils/logging/error_adapter.py:60:13
   |
58 |         """
59 |         if self.request is None and has_request_context():
60 |             from flask import request as flask_request
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |
62 |             self.request = flask_request
   |

FBT001 Boolean-typed positional argument in function definition
  --> app/utils/logging/handlers.py:27:24
   |
25 |     """
26 |
27 |     def __init__(self, enabled: bool = False) -> None:
   |                        ^^^^^^^
28 |         """初始化 DEBUG 过滤器.
   |

FBT002 Boolean default positional argument in function definition
  --> app/utils/logging/handlers.py:27:24
   |
25 |     """
26 |
27 |     def __init__(self, enabled: bool = False) -> None:
   |                        ^^^^^^^
28 |         """初始化 DEBUG 过滤器.
   |

FBT001 Boolean-typed positional argument in function definition
  --> app/utils/logging/handlers.py:36:27
   |
34 |         self.enabled = enabled
35 |
36 |     def set_enabled(self, enabled: bool) -> None:
   |                           ^^^^^^^
37 |         """设置是否启用 DEBUG 日志.
   |

ANN204 Missing return type annotation for special method `__call__`
  --> app/utils/logging/handlers.py:48:9
   |
46 |         self.enabled = enabled
47 |
48 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]):
   |         ^^^^^^^^
49 |         """处理日志事件,根据配置决定是否丢弃 DEBUG 日志.
   |
help: Add return type annotation

ARG002 Unused method argument: `logger`
  --> app/utils/logging/handlers.py:48:24
   |
46 |         self.enabled = enabled
47 |
48 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]):
   |                        ^^^^^^
49 |         """处理日志事件,根据配置决定是否丢弃 DEBUG 日志.
   |

ARG002 Unused method argument: `method_name`
  --> app/utils/logging/handlers.py:48:55
   |
46 |         self.enabled = enabled
47 |
48 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]):
   |                                                       ^^^^^^^^^^^
49 |         """处理日志事件,根据配置决定是否丢弃 DEBUG 日志.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `worker`
  --> app/utils/logging/handlers.py:77:32
   |
75 |     """
76 |
77 |     def __init__(self, worker: Any | None = None) -> None:
   |                                ^^^^^^^^^^
78 |         """初始化数据库日志处理器.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `worker`
  --> app/utils/logging/handlers.py:86:34
   |
84 |         self.worker = worker
85 |
86 |     def set_worker(self, worker: Any | None) -> None:
   |                                  ^^^^^^^^^^
87 |         """设置日志队列工作线程.
   |

ANN204 Missing return type annotation for special method `__call__`
  --> app/utils/logging/handlers.py:98:9
   |
96 |         self.worker = worker
97 |
98 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]):
   |         ^^^^^^^^
99 |         """处理日志事件,将其入队等待写入数据库.
   |
help: Add return type annotation

ARG002 Unused method argument: `logger`
  --> app/utils/logging/handlers.py:98:24
   |
96 |         self.worker = worker
97 |
98 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]):
   |                        ^^^^^^
99 |         """处理日志事件,将其入队等待写入数据库.
   |

ARG002 Unused method argument: `method_name`
  --> app/utils/logging/handlers.py:98:55
   |
96 |         self.worker = worker
97 |
98 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]):
   |                                                       ^^^^^^^^^^^
99 |         """处理日志事件,将其入队等待写入数据库.
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/logging/handlers.py:156:16
    |
154 |         try:
155 |             timestamp = time_utils.to_utc(timestamp)
156 |         except Exception:
    |                ^^^^^^^^^
157 |             timestamp = time_utils.now()
158 |     if timestamp is None:
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> app/utils/logging/handlers.py:230:5
    |
228 |               else:
229 |                   context["is_admin"] = bool(is_admin)
230 | /     except Exception:
231 | |         pass
    | |____________^
232 |
233 |       for key, value in event_dict.items():
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/logging/handlers.py:230:12
    |
228 |             else:
229 |                 context["is_admin"] = bool(is_admin)
230 |     except Exception:
    |            ^^^^^^^^^
231 |         pass
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/logging/handlers.py:241:20
    |
239 |             try:
240 |                 context[key] = value.to_dict()
241 |             except Exception:
    |                    ^^^^^^^^^
242 |                 context[key] = str(value)
243 |         else:
    |

I001 [*] Import block is un-sorted or un-formatted
  --> app/utils/logging/queue_worker.py:3:1
   |
 1 |   """负责异步持久化结构化日志的队列工作线程."""
 2 |
 3 | / from __future__ import annotations
 4 | |
 5 | | import contextlib
 6 | | import logging
 7 | | import threading
 8 | | import time
 9 | | from queue import Empty, Full, Queue
10 | | from typing import Any
   | |______________________^
   |
help: Organize imports

ANN001 Missing type annotation for function argument `app`
  --> app/utils/logging/queue_worker.py:27:9
   |
25 |     def __init__(
26 |         self,
27 |         app,
   |         ^^^
28 |         *,
29 |         queue_size: int = 1000,
   |

LOG015 `warning()` call on root logger
  --> app/utils/logging/queue_worker.py:67:13
   |
65 |               self.queue.put_nowait(log_entry)
66 |           except Full:
67 | /             logging.warning(
68 | |                 "结构化日志队列已满,丢弃一条日志", extra={"queue_size": self.queue.qsize()},
69 | |             )
   | |_____________^
70 |
71 |       def shutdown(self, timeout: float = 5.0) -> None:
   |
help: Use own logger instead

PLC0415 `import` should be at the top-level of a file
   --> app/utils/logging/queue_worker.py:134:13
    |
133 |         try:
134 |             from app import db
    |             ^^^^^^^^^^^^^^^^^^
135 |             from app.models.unified_log import UnifiedLog
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/logging/queue_worker.py:135:13
    |
133 |         try:
134 |             from app import db
135 |             from app.models.unified_log import UnifiedLog
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
136 |
137 |             with self.app.app_context():
    |

LOG015 `exception()` call on root logger
   --> app/utils/logging/queue_worker.py:143:13
    |
141 |                     db.session.commit()
142 |         except Exception:
143 |             logging.exception("写入结构化日志到数据库失败")
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
144 |             with contextlib.suppress(Exception):
145 |                 db.session.rollback()
    |
help: Use own logger instead

D205 1 blank line required between summary line and description
 --> app/utils/password_crypto_utils.py:1:1
  |
1 | / """密码管理工具
2 | | 用于安全地存储和获取数据库密码.
3 | | """
  | |___^
4 |
5 |   import base64
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/utils/password_crypto_utils.py:30:9
   |
28 |     """
29 |
30 |     def __init__(self) -> None:
   |         ^^^^^^^^
31 |         self.key = self._get_or_create_key()
32 |         self.cipher = Fernet(self.key)
   |

ANN202 Missing return type annotation for private function `_get_or_create_key`
  --> app/utils/password_crypto_utils.py:34:9
   |
32 |         self.cipher = Fernet(self.key)
33 |
34 |     def _get_or_create_key(self):
   |         ^^^^^^^^^^^^^^^^^^
35 |         """获取或创建加密密钥.
   |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
  --> app/utils/password_crypto_utils.py:50:17
   |
48 |             # 延迟导入避免循环导入
49 |             try:
50 |                 from app.utils.structlog_config import get_system_logger
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |                 system_logger = get_system_logger()
52 |                 system_logger.warning("没有设置PASSWORD_ENCRYPTION_KEY环境变量", module="password_manager")
   |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/password_crypto_utils.py:101:13
    |
 99 |             return decrypted.decode()
100 |         except Exception as e:
101 |             from app.utils.structlog_config import get_system_logger
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
102 |
103 |             system_logger = get_system_logger()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/password_crypto_utils.py:127:13
    |
125 |         try:
126 |             base64.b64decode(password.encode())
127 |             return True
    |             ^^^^^^^^^^^
128 |         except Exception:
129 |             return False
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/password_crypto_utils.py:128:16
    |
126 |             base64.b64decode(password.encode())
127 |             return True
128 |         except Exception:
    |                ^^^^^^^^^
129 |             return False
    |

ERA001 Found commented-out code
   --> app/utils/password_crypto_utils.py:132:1
    |
132 | # 全局密码管理器实例(延迟初始化)
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
133 | _password_manager = None
    |
help: Remove commented-out code

PLW0603 Using the global statement to update `_password_manager` is discouraged
   --> app/utils/password_crypto_utils.py:142:12
    |
141 |     """
142 |     global _password_manager
    |            ^^^^^^^^^^^^^^^^^
143 |     if _password_manager is None:
144 |         _password_manager = PasswordManager()
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/query_filter_utils.py:264:9
    |
262 |     query = db.session.query(distinct(UnifiedLog.module))
263 |     if limit_hours is not None:
264 |         from datetime import timedelta
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
265 |
266 |         from app.utils.time_utils import time_utils
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/query_filter_utils.py:266:9
    |
264 |         from datetime import timedelta
265 |
266 |         from app.utils.time_utils import time_utils
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
267 |
268 |         start_time = time_utils.now() - timedelta(hours=limit_hours)
    |

BLE001 Do not catch blind exception: `Exception`
  --> app/utils/rate_limiter.py:86:20
   |
84 |             try:
85 |                 return self._check_cache(identifier, endpoint, limit, window, current_time, window_start)
86 |             except Exception as e:
   |                    ^^^^^^^^^
87 |                 system_logger = get_system_logger()
88 |                 system_logger.warning(
   |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/utils/rate_limiter.py:98:9
    |
 96 |             return self._check_memory(identifier, endpoint, limit, window, current_time, window_start)
 97 |
 98 |     def _check_cache(
    |         ^^^^^^^^^^^^
 99 |         self,
100 |         identifier: str,
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/utils/rate_limiter.py:151:9
    |
149 |         }
150 |
151 |     def _check_memory(
    |         ^^^^^^^^^^^^^
152 |         self,
153 |         identifier: str,
    |

ANN201 Missing return type annotation for public function `login_rate_limit`
   --> app/utils/rate_limiter.py:207:5
    |
207 | def login_rate_limit(func=None, *, limit: int | None = None, window: int | None = None):
    |     ^^^^^^^^^^^^^^^^
208 |     """登录接口速率限制装饰器.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `func`
   --> app/utils/rate_limiter.py:207:22
    |
207 | def login_rate_limit(func=None, *, limit: int | None = None, window: int | None = None):
    |                      ^^^^
208 |     """登录接口速率限制装饰器.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/rate_limiter.py:219:5
    |
218 |     """
219 |     from app.config import Config
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
220 |
221 |     if limit is None:
    |

ANN202 Missing return type annotation for private function `wrapped`
   --> app/utils/rate_limiter.py:228:13
    |
226 |     def decorator(f: Callable) -> Callable:
227 |         @wraps(f)
228 |         def wrapped(*args, **kwargs):
    |             ^^^^^^^
229 |             if request.method.upper() in SAFE_METHODS:
230 |                 return f(*args, **kwargs)
    |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
   --> app/utils/rate_limiter.py:228:21
    |
226 |     def decorator(f: Callable) -> Callable:
227 |         @wraps(f)
228 |         def wrapped(*args, **kwargs):
    |                     ^^^^^
229 |             if request.method.upper() in SAFE_METHODS:
230 |                 return f(*args, **kwargs)
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/rate_limiter.py:228:28
    |
226 |     def decorator(f: Callable) -> Callable:
227 |         @wraps(f)
228 |         def wrapped(*args, **kwargs):
    |                            ^^^^^^^^
229 |             if request.method.upper() in SAFE_METHODS:
230 |                 return f(*args, **kwargs)
    |

ANN201 Missing return type annotation for public function `password_reset_rate_limit`
   --> app/utils/rate_limiter.py:291:5
    |
291 | def password_reset_rate_limit(func=None, *, limit: int | None = None, window: int | None = None):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
292 |     """密码重置速率限制装饰器.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `func`
   --> app/utils/rate_limiter.py:291:31
    |
291 | def password_reset_rate_limit(func=None, *, limit: int | None = None, window: int | None = None):
    |                               ^^^^
292 |     """密码重置速率限制装饰器.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/rate_limiter.py:310:5
    |
309 |     """
310 |     from app.config import Config
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
311 |
312 |     if limit is None:
    |

PLW0603 Using the global statement to update `rate_limiter` is discouraged
   --> app/utils/rate_limiter.py:337:12
    |
336 |     """
337 |     global rate_limiter
    |            ^^^^^^^^^^^^
338 |     rate_limiter = RateLimiter(cache)
339 |     system_logger = get_system_logger()
    |

D205 1 blank line required between summary line and description
 --> app/utils/response_utils.py:1:1
  |
1 | / """鲸落 - 统一响应工具
2 | | 提供统一的成功/错误响应结构,避免在业务层散落 JSON 拼装逻辑.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `data`
  --> app/utils/response_utils.py:22:11
   |
21 | def unified_success_response(
22 |     data: Any | None = None,
   |           ^^^^^^^^^^
23 |     message: str | None = None,
24 |     *,
   |

ANN201 Missing return type annotation for public function `jsonify_unified_success`
  --> app/utils/response_utils.py:83:5
   |
83 | def jsonify_unified_success(*args, **kwargs):
   |     ^^^^^^^^^^^^^^^^^^^^^^^
84 |     """返回 Flask Response 对象的成功响应便捷函数.
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> app/utils/response_utils.py:83:29
   |
83 | def jsonify_unified_success(*args, **kwargs):
   |                             ^^^^^
84 |     """返回 Flask Response 对象的成功响应便捷函数.
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/utils/response_utils.py:83:36
   |
83 | def jsonify_unified_success(*args, **kwargs):
   |                                    ^^^^^^^^
84 |     """返回 Flask Response 对象的成功响应便捷函数.
   |

ANN201 Missing return type annotation for public function `jsonify_unified_error`
  --> app/utils/response_utils.py:98:5
   |
98 | def jsonify_unified_error(*args, **kwargs):
   |     ^^^^^^^^^^^^^^^^^^^^^
99 |     """返回 Flask Response 对象的错误响应便捷函数.
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> app/utils/response_utils.py:98:27
   |
98 | def jsonify_unified_error(*args, **kwargs):
   |                           ^^^^^
99 |     """返回 Flask Response 对象的错误响应便捷函数.
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/utils/response_utils.py:98:34
   |
98 | def jsonify_unified_error(*args, **kwargs):
   |                                  ^^^^^^^^
99 |     """返回 Flask Response 对象的错误响应便捷函数.
   |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/utils/response_utils.py:113:5
    |
113 | def jsonify_unified_error_message(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
114 |     message: str,
115 |     *,
    |

ANN201 Missing return type annotation for public function `jsonify_unified_error_message`
   --> app/utils/response_utils.py:113:5
    |
113 | def jsonify_unified_error_message(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
114 |     message: str,
115 |     *,
    |
help: Add return type annotation

D205 1 blank line required between summary line and description
 --> app/utils/safe_query_builder.py:1:1
  |
1 | / """鲸落 - 安全查询构建器
2 | | 提供安全的SQL查询构建功能,防止SQL注入攻击
3 | | 支持MySQL、PostgreSQL、SQL Server、Oracle等多种数据库.
4 | | """
  | |___^
5 |
6 |   from typing import Any
  |
help: Insert single blank line

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*params`
  --> app/utils/safe_query_builder.py:54:54
   |
52 |             self.parameters: list[Any] = []
53 |
54 |     def add_condition(self, condition: str, *params: Any) -> "SafeQueryBuilder":
   |                                                      ^^^
55 |         """添加查询条件.
   |

ERA001 Found commented-out code
   --> app/utils/safe_query_builder.py:118:9
    |
116 |             # SQL Server使用%s占位符
117 |             return ", ".join(["%s"] * count)
118 |         # MySQL, PostgreSQL使用%s
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
119 |         return ", ".join(["%s"] * count)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/safe_query_builder.py:314:13
    |
312 |         # 处理排除用户
313 |         if values:
314 |             # PostgreSQL特殊处理:保留postgres用户
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
315 |             if self.db_type == DatabaseType.POSTGRESQL and "postgres" in values:
316 |                 filtered_values = [v for v in values if v != "postgres"]
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/safe_query_builder.py:324:13
    |
322 |         # 处理排除模式
323 |         for pattern in patterns:
324 |             # PostgreSQL特殊处理:pg_%模式不排除postgres用户
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
325 |             if self.db_type == DatabaseType.POSTGRESQL and pattern == "pg_%":
326 |                 self.add_condition(f"({field} NOT LIKE %s OR {field} = %s)", pattern, "postgres")
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/safe_query_builder.py:420:5
    |
418 |     where_clause, params = build_safe_filter_conditions(db_type, username_field, filter_rules)
419 |
420 |     # 如果是Oracle返回的dict,转换为list(虽然会丢失命名信息,但保持兼容性)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
421 |     if isinstance(params, dict):
422 |         return where_clause, list(params.values())
    |
help: Remove commented-out code

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
  --> app/utils/sensitive_data.py:49:23
   |
47 |         normalized_keys.update(str(key).lower() for key in extra_keys)
48 |
49 |     def _scrub(value: Any, *, field_name: str | None = None) -> Any:
   |                       ^^^
50 |         key_lower = field_name.lower() if field_name else None
51 |         if key_lower and key_lower in normalized_keys:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_scrub`
  --> app/utils/sensitive_data.py:49:65
   |
47 |         normalized_keys.update(str(key).lower() for key in extra_keys)
48 |
49 |     def _scrub(value: Any, *, field_name: str | None = None) -> Any:
   |                                                                 ^^^
50 |         key_lower = field_name.lower() if field_name else None
51 |         if key_lower and key_lower in normalized_keys:
   |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/sqlserver_connection_utils.py:150:13
    |
148 |         try:
149 |             socket.gethostbyname(host)
150 |             return True
    |             ^^^^^^^^^^^
151 |         except socket.gaierror:
152 |             return False
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/sqlserver_connection_utils.py:172:13
    |
170 |             result = sock.connect_ex((host, port))
171 |             sock.close()
172 |             return result == 0
    |             ^^^^^^^^^^^^^^^^^^
173 |         except Exception:
174 |             return False
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/sqlserver_connection_utils.py:173:16
    |
171 |             sock.close()
172 |             return result == 0
173 |         except Exception:
    |                ^^^^^^^^^
174 |             return False
    |

E501 Line too long (124 > 120)
   --> app/utils/sqlserver_connection_utils.py:176:121
    |
174 |             return False
175 |
176 |     def get_connection_string_suggestions(self, host: str, port: int, username: str, database: str = "master") -> list[str]:
    |                                                                                                                         ^^^^
177 |         """获取连接字符串建议.
    |

E501 Line too long (126 > 120)
   --> app/utils/sqlserver_connection_utils.py:204:121
    |
203 |         # 带超时的连接字符串
204 |         suggestions.append(f"Server={host},{port};Database={database};User Id={username};Password=***;Connection Timeout=60;")
    |                                                                                                                         ^^^^^^
205 |
206 |         # 带加密的连接字符串
    |

E501 Line too long (145 > 120)
   --> app/utils/sqlserver_connection_utils.py:207:121
    |
206 | …
207 | …e};User Id={username};Password=***;Encrypt=True;TrustServerCertificate=True;")
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^
208 | …
209 | …
    |

E501 Line too long (146 > 120)
   --> app/utils/sqlserver_connection_utils.py:210:121
    |
209 | …
210 | …e};User Id={username};Password=***;Connection Timeout=60;Command Timeout=300;")
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^
211 | …
212 | …
    |

E501 Line too long (138 > 120)
   --> app/utils/sqlserver_connection_utils.py:237:121
    |
235 | …
236 | …
237 | …ower() for keyword in ["timeout", "connection", "network", "unreachable"]),
    |                                                           ^^^^^^^^^^^^^^^^^^
238 | …r() for keyword in ["login", "authentication", "password", "user"]),
239 | …wer() for keyword in ["server", "service", "database", "sql"]),
    |

E501 Line too long (131 > 120)
   --> app/utils/sqlserver_connection_utils.py:238:121
    |
236 | …
237 | …e.lower() for keyword in ["timeout", "connection", "network", "unreachable"]),
238 | …ower() for keyword in ["login", "authentication", "password", "user"]),
    |                                                              ^^^^^^^^^^^
239 | ….lower() for keyword in ["server", "service", "database", "sql"]),
240 | …sage.lower() for keyword in ["permission", "access", "denied", "unauthorized"]),
    |

E501 Line too long (126 > 120)
   --> app/utils/sqlserver_connection_utils.py:239:121
    |
237 | …         "has_network_error": any(keyword in error_message.lower() for keyword in ["timeout", "connection", "network", "unreachable"…
238 | …         "has_auth_error": any(keyword in error_message.lower() for keyword in ["login", "authentication", "password", "user"]),
239 | …         "has_server_error": any(keyword in error_message.lower() for keyword in ["server", "service", "database", "sql"]),
    |                                                                                                                       ^^^^^^
240 | …         "has_permission_error": any(keyword in error_message.lower() for keyword in ["permission", "access", "denied", "unauthorize…
241 | …     }
    |

E501 Line too long (140 > 120)
   --> app/utils/sqlserver_connection_utils.py:240:121
    |
238 | …() for keyword in ["login", "authentication", "password", "user"]),
239 | …er() for keyword in ["server", "service", "database", "sql"]),
240 | ….lower() for keyword in ["permission", "access", "denied", "unauthorized"]),
    |                                                          ^^^^^^^^^^^^^^^^^^^^
241 | …
    |

ANN001 Missing type annotation for function argument `app`
  --> app/utils/structlog_config.py:55:25
   |
53 |         self.configured = False
54 |
55 |     def configure(self, app=None) -> None:
   |                         ^^^
56 |         """初始化 structlog 处理器(幂等).
   |

ANN001 Missing type annotation for function argument `app`
  --> app/utils/structlog_config.py:93:27
   |
91 |             self._attach_app(app)
92 |
93 |     def _attach_app(self, app) -> None:
   |                           ^^^
94 |         """绑定位于 Flask 应用上的队列配置.
   |

ANN202 Missing return type annotation for private function `_add_request_context`
   --> app/utils/structlog_config.py:118:9
    |
116 |         self.debug_filter.set_enabled(enable_debug)
117 |
118 |     def _add_request_context(self, logger, method_name, event_dict):
    |         ^^^^^^^^^^^^^^^^^^^^
119 |         """向事件字典写入请求上下文.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `logger`
   --> app/utils/structlog_config.py:118:36
    |
116 |         self.debug_filter.set_enabled(enable_debug)
117 |
118 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                    ^^^^^^
119 |         """向事件字典写入请求上下文.
    |

ARG002 Unused method argument: `logger`
   --> app/utils/structlog_config.py:118:36
    |
116 |         self.debug_filter.set_enabled(enable_debug)
117 |
118 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                    ^^^^^^
119 |         """向事件字典写入请求上下文.
    |

ANN001 Missing type annotation for function argument `method_name`
   --> app/utils/structlog_config.py:118:44
    |
116 |         self.debug_filter.set_enabled(enable_debug)
117 |
118 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                            ^^^^^^^^^^^
119 |         """向事件字典写入请求上下文.
    |

ARG002 Unused method argument: `method_name`
   --> app/utils/structlog_config.py:118:44
    |
116 |         self.debug_filter.set_enabled(enable_debug)
117 |
118 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                            ^^^^^^^^^^^
119 |         """向事件字典写入请求上下文.
    |

ANN001 Missing type annotation for function argument `event_dict`
   --> app/utils/structlog_config.py:118:57
    |
116 |         self.debug_filter.set_enabled(enable_debug)
117 |
118 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                                         ^^^^^^^^^^
119 |         """向事件字典写入请求上下文.
    |

ANN202 Missing return type annotation for private function `_add_user_context`
   --> app/utils/structlog_config.py:135:9
    |
133 |         return event_dict
134 |
135 |     def _add_user_context(self, logger, method_name, event_dict):
    |         ^^^^^^^^^^^^^^^^^
136 |         """附加当前用户上下文.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `logger`
   --> app/utils/structlog_config.py:135:33
    |
133 |         return event_dict
134 |
135 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                 ^^^^^^
136 |         """附加当前用户上下文.
    |

ARG002 Unused method argument: `logger`
   --> app/utils/structlog_config.py:135:33
    |
133 |         return event_dict
134 |
135 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                 ^^^^^^
136 |         """附加当前用户上下文.
    |

ANN001 Missing type annotation for function argument `method_name`
   --> app/utils/structlog_config.py:135:41
    |
133 |         return event_dict
134 |
135 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                         ^^^^^^^^^^^
136 |         """附加当前用户上下文.
    |

ARG002 Unused method argument: `method_name`
   --> app/utils/structlog_config.py:135:41
    |
133 |         return event_dict
134 |
135 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                         ^^^^^^^^^^^
136 |         """附加当前用户上下文.
    |

ANN001 Missing type annotation for function argument `event_dict`
   --> app/utils/structlog_config.py:135:54
    |
133 |         return event_dict
134 |
135 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                                      ^^^^^^^^^^
136 |         """附加当前用户上下文.
    |

S110 `try`-`except`-`pass` detected, consider logging the exception
   --> app/utils/structlog_config.py:151:9
    |
149 |                   event_dict["current_user_id"] = getattr(current_user, "id", None)
150 |                   event_dict["current_username"] = getattr(current_user, "username", None)
151 | /         except Exception:
152 | |             pass
    | |________________^
153 |           return event_dict
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/structlog_config.py:151:16
    |
149 |                 event_dict["current_user_id"] = getattr(current_user, "id", None)
150 |                 event_dict["current_username"] = getattr(current_user, "username", None)
151 |         except Exception:
    |                ^^^^^^^^^
152 |             pass
153 |         return event_dict
    |

ANN202 Missing return type annotation for private function `_add_global_context`
   --> app/utils/structlog_config.py:155:9
    |
153 |         return event_dict
154 |
155 |     def _add_global_context(self, logger, method_name, event_dict):
    |         ^^^^^^^^^^^^^^^^^^^
156 |         """附加环境、版本等全局上下文.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `logger`
   --> app/utils/structlog_config.py:155:35
    |
153 |         return event_dict
154 |
155 |     def _add_global_context(self, logger, method_name, event_dict):
    |                                   ^^^^^^
156 |         """附加环境、版本等全局上下文.
    |

ANN001 Missing type annotation for function argument `method_name`
   --> app/utils/structlog_config.py:155:43
    |
153 |         return event_dict
154 |
155 |     def _add_global_context(self, logger, method_name, event_dict):
    |                                           ^^^^^^^^^^^
156 |         """附加环境、版本等全局上下文.
    |

ARG002 Unused method argument: `method_name`
   --> app/utils/structlog_config.py:155:43
    |
153 |         return event_dict
154 |
155 |     def _add_global_context(self, logger, method_name, event_dict):
    |                                           ^^^^^^^^^^^
156 |         """附加环境、版本等全局上下文.
    |

ANN001 Missing type annotation for function argument `event_dict`
   --> app/utils/structlog_config.py:155:56
    |
153 |         return event_dict
154 |
155 |     def _add_global_context(self, logger, method_name, event_dict):
    |                                                        ^^^^^^^^^^
156 |         """附加环境、版本等全局上下文.
    |

ANN202 Missing return type annotation for private function `_get_console_renderer`
   --> app/utils/structlog_config.py:181:9
    |
179 |         return event_dict
180 |
181 |     def _get_console_renderer(self):
    |         ^^^^^^^^^^^^^^^^^^^^^
182 |         """根据终端能力返回渲染器.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `app`
   --> app/utils/structlog_config.py:233:25
    |
233 | def configure_structlog(app) -> None:
    |                         ^^^
234 |     """配置 structlog 并注册 Flask 钩子.
    |

ANN001 Missing type annotation for function argument `exception`
   --> app/utils/structlog_config.py:246:28
    |
245 |     @app.teardown_appcontext
246 |     def log_teardown_error(exception) -> None:
    |                            ^^^^^^^^^
247 |         if exception:
248 |             get_logger("app").error("应用请求处理异常", module="system", exception=str(exception))
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:264:49
    |
264 | def log_info(message: str, module: str = "app", **kwargs) -> None:
    |                                                 ^^^^^^^^
265 |     """记录信息级别日志.
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:283:88
    |
283 | def log_warning(message: str, module: str = "app", exception: Exception | None = None, **kwargs) -> None:
    |                                                                                        ^^^^^^^^
284 |     """记录警告级别日志.
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:306:86
    |
306 | def log_error(message: str, module: str = "app", exception: Exception | None = None, **kwargs) -> None:
    |                                                                                      ^^^^^^^^
307 |     """记录错误级别日志.
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:332:89
    |
332 | def log_critical(message: str, module: str = "app", exception: Exception | None = None, **kwargs) -> None:
    |                                                                                         ^^^^^^^^
333 |     """记录严重错误级别日志.
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:355:50
    |
355 | def log_debug(message: str, module: str = "app", **kwargs) -> None:
    |                                                  ^^^^^^^^
356 |     """记录调试级别日志.
    |

ANN201 Missing return type annotation for public function `error_handler`
   --> app/utils/structlog_config.py:530:5
    |
530 | def error_handler(func: Callable):
    |     ^^^^^^^^^^^^^
531 |     """Flask 视图装饰器,统一捕获异常并输出结构化日志.
    |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
   --> app/utils/structlog_config.py:540:5
    |
539 |     """
540 |     from functools import wraps
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
541 |
542 |     from flask import jsonify
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/structlog_config.py:542:5
    |
540 |     from functools import wraps
541 |
542 |     from flask import jsonify
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
543 |
544 |     @wraps(func)
    |

ANN202 Missing return type annotation for private function `wrapper`
   --> app/utils/structlog_config.py:545:9
    |
544 |     @wraps(func)
545 |     def wrapper(*args, **kwargs):
    |         ^^^^^^^
546 |         try:
547 |             return func(*args, **kwargs)
    |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
   --> app/utils/structlog_config.py:545:17
    |
544 |     @wraps(func)
545 |     def wrapper(*args, **kwargs):
    |                 ^^^^^
546 |         try:
547 |             return func(*args, **kwargs)
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:545:24
    |
544 |     @wraps(func)
545 |     def wrapper(*args, **kwargs):
    |                        ^^^^^^^^
546 |         try:
547 |             return func(*args, **kwargs)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/structlog_config.py:548:16
    |
546 |         try:
547 |             return func(*args, **kwargs)
548 |         except Exception as error:
    |                ^^^^^^^^^
549 |             context = ErrorContext(error)
550 |             payload = enhanced_error_handler(error, context)
    |

D205 1 blank line required between summary line and description
 --> app/utils/time_utils.py:1:1
  |
1 | / """统一时间处理工具模块
2 | | 基于Python 3.9+的zoneinfo模块,提供一致的时间处理功能.
3 | | """
  | |___^
4 |
5 |   from datetime import UTC, date, datetime
  |
help: Insert single blank line

PLC0415 `import` should be at the top-level of a file
  --> app/utils/time_utils.py:93:13
   |
91 |             return dt.astimezone(CHINA_TZ)
92 |         except (ValueError, TypeError) as e:
93 |             from app.utils.structlog_config import get_system_logger
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
94 |
95 |             get_system_logger().warning(f"时间转换错误: {e}")
   |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/time_utils.py:126:13
    |
124 |             return dt.astimezone(UTC_TZ)
125 |         except (ValueError, TypeError) as e:
126 |             from app.utils.structlog_config import get_system_logger
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 |
128 |             get_system_logger().warning(f"时间转换错误: {e}")
    |

PLR0911 Too many return statements (7 > 6)
   --> app/utils/time_utils.py:176:9
    |
175 |     @staticmethod
176 |     def get_relative_time(dt: str | date | datetime | None) -> str:
    |         ^^^^^^^^^^^^^^^^^
177 |         """获取相对时间描述.
    |

PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
   --> app/utils/time_utils.py:196:39
    |
194 |             diff = now - china_dt
195 |
196 |             if diff.total_seconds() < 60:
    |                                       ^^
197 |                 return "刚刚"
198 |             if diff.total_seconds() < TimeConstants.ONE_HOUR:
    |

PLR2004 Magic value used in comparison, consider replacing `7` with a constant variable
   --> app/utils/time_utils.py:204:28
    |
202 |                 hours = int(diff.total_seconds() / TimeConstants.ONE_HOUR)
203 |                 return f"{hours}小时前"
204 |             if diff.days < 7:
    |                            ^
205 |                 return f"{diff.days}天前"
206 |             return TimeUtils.format_china_time(china_dt)
    |

PLR2004 Magic value used in comparison, consider replacing `24` with a constant variable
   --> app/utils/time_utils.py:244:20
    |
242 |         now = TimeUtils.now_china()
243 |         start = now.replace(hour=0, minute=0, second=0, microsecond=0)
244 |         if hours < 24:
    |                    ^^
245 |             start = now.replace(hour=now.hour - hours, minute=0, second=0, microsecond=0)
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/time_utils.py:275:13
    |
273 |             if isinstance(dt, date):
274 |                 return dt.isoformat()
275 |             return None
    |             ^^^^^^^^^^^
276 |         except (ValueError, TypeError):
277 |             return None
    |

ERA001 Found commented-out code
   --> app/utils/time_utils.py:287:1
    |
287 | # 常量(向后兼容)
    | ^^^^^^^^^^^^^^^^
288 | # UTC_TZ 已在文件顶部定义
    |
help: Remove commented-out code

EXE001 Shebang is present but file is not executable
 --> app/utils/version_parser.py:1:1
  |
1 | #!/usr/bin/env python3
  | ^^^^^^^^^^^^^^^^^^^^^^
2 | """数据库版本解析工具
3 | 使用正则表达式提取简洁的版本信息.
  |

D205 1 blank line required between summary line and description
 --> app/utils/version_parser.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """数据库版本解析工具
3 | | 使用正则表达式提取简洁的版本信息.
4 | | """
  | |___^
5 |
6 |   import re
  |
help: Insert single blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/utils/version_parser.py:29:24
   |
28 |       # 版本提取正则表达式
29 |       VERSION_PATTERNS = {
   |  ________________________^
30 | |         "mysql": [
31 | |             r"(\d+\.\d+\.\d+)",  # 8.0.32
32 | |             r"(\d+\.\d+)",  # 8.0
33 | |         ],
34 | |         "postgresql": [
35 | |             r"PostgreSQL\s+(\d+\.\d+)",  # PostgreSQL 13.4
36 | |             r"(\d+\.\d+)",  # 13.4
37 | |         ],
38 | |         "sqlserver": [
39 | |             r"Microsoft SQL Server \d+\s+\([^)]+\)\s+\([^)]+\)\s+-\s+(\d+\.\d+\.\d+\.\d+)",  # 14.0.3465.1
40 | |             r"(\d+\.\d+\.\d+\.\d+)",  # 14.0.3465.1
41 | |         ],
42 | |         "oracle": [
43 | |             r"Oracle Database \d+g Release (\d+\.\d+\.\d+\.\d+\.\d+)",  # Oracle Database 11g Release 11.2.0.1.0
44 | |             r"(\d+\.\d+\.\d+\.\d+\.\d+)",  # 11.2.0.1.0
45 | |         ],
46 | |     }
   | |_____^
47 |
48 |       @classmethod
   |

PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
  --> app/utils/version_parser.py:87:86
   |
85 |         return {
86 |             "main_version": "未知",
87 |             "detailed_version": version_string[:50] + "..." if len(version_string) > 50 else version_string,
   |                                                                                      ^^
88 |             "original": version_string,
89 |         }
   |

C901 `_extract_main_version` is too complex (11 > 10)
  --> app/utils/version_parser.py:92:9
   |
91 |     @classmethod
92 |     def _extract_main_version(cls, version: str, db_type: str) -> str:
   |         ^^^^^^^^^^^^^^^^^^^^^
93 |         """提取主版本号.
   |

PLR0911 Too many return statements (11 > 6)
  --> app/utils/version_parser.py:92:9
   |
91 |     @classmethod
92 |     def _extract_main_version(cls, version: str, db_type: str) -> str:
   |         ^^^^^^^^^^^^^^^^^^^^^
93 |         """提取主版本号.
   |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:116:30
    |
114 |             # MySQL: 8.0.32 -> 8.0
115 |             parts = version.split(".")
116 |             if len(parts) >= 2:
    |                              ^
117 |                 return f"{parts[0]}.{parts[1]}"
118 |             return version
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:123:30
    |
121 |             # PostgreSQL: 13.4 -> 13.4
122 |             parts = version.split(".")
123 |             if len(parts) >= 2:
    |                              ^
124 |                 return f"{parts[0]}.{parts[1]}"
125 |             return version
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:130:30
    |
128 |             # SQL Server: 14.0.3465.1 -> 14.0
129 |             parts = version.split(".")
130 |             if len(parts) >= 2:
    |                              ^
131 |                 return f"{parts[0]}.{parts[1]}"
132 |             return version
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:137:30
    |
135 |             # Oracle: 11.2.0.1.0 -> 11.2
136 |             parts = version.split(".")
137 |             if len(parts) >= 2:
    |                              ^
138 |                 return f"{parts[0]}.{parts[1]}"
139 |             return version
    |

ERA001 Found commented-out code
   --> app/utils/version_parser.py:141:9
    |
139 |             return version
140 |
141 |         # 默认情况:取前两个部分
    |         ^^^^^^^^^^^^^^^^^^^^^^^
142 |         parts = version.split(".")
143 |         if len(parts) >= 2:
    |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:143:26
    |
141 |         # 默认情况:取前两个部分
142 |         parts = version.split(".")
143 |         if len(parts) >= 2:
    |                          ^
144 |             return f"{parts[0]}.{parts[1]}"
145 |         return version
    |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/classification_forms.py:20:9
   |
18 |     form_definition = CLASSIFICATION_FORM_DEFINITION
19 |
20 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
21 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:20:41
   |
18 |     form_definition = CLASSIFICATION_FORM_DEFINITION
19 |
20 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
21 |         """解析成功后的重定向地址.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:20:41
   |
18 |     form_definition = CLASSIFICATION_FORM_DEFINITION
19 |
20 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
21 |         """解析成功后的重定向地址.
   |

ANN202 Missing return type annotation for private function `_success_redirect_kwargs`
  --> app/views/classification_forms.py:32:9
   |
30 |         return url_for("account_classification.index")
31 |
32 |     def _success_redirect_kwargs(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
33 |         """获取重定向的额外参数.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:32:40
   |
30 |         return url_for("account_classification.index")
31 |
32 |     def _success_redirect_kwargs(self, instance):
   |                                        ^^^^^^^^
33 |         """获取重定向的额外参数.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:32:40
   |
30 |         return url_for("account_classification.index")
31 |
32 |     def _success_redirect_kwargs(self, instance):
   |                                        ^^^^^^^^
33 |         """获取重定向的额外参数.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:44:35
   |
42 |         return {}
43 |
44 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
45 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:44:35
   |
42 |         return {}
43 |
44 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
45 |         """获取成功消息.
   |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/classification_forms.py:67:9
   |
65 |     form_definition = CLASSIFICATION_RULE_FORM_DEFINITION
66 |
67 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
68 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:67:41
   |
65 |     form_definition = CLASSIFICATION_RULE_FORM_DEFINITION
66 |
67 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
68 |         """解析成功后的重定向地址.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:67:41
   |
65 |     form_definition = CLASSIFICATION_RULE_FORM_DEFINITION
66 |
67 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
68 |         """解析成功后的重定向地址.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:79:35
   |
77 |         return url_for("account_classification.index")
78 |
79 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
80 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:79:35
   |
77 |         return url_for("account_classification.index")
78 |
79 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
80 |         """获取成功消息.
   |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/credential_forms.py:19:9
   |
17 |     form_definition = CREDENTIAL_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
20 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/credential_forms.py:19:41
   |
17 |     form_definition = CREDENTIAL_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
20 |         """解析成功后的重定向地址.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/credential_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/credential_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/instance_forms.py:19:9
   |
17 |     form_definition = INSTANCE_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
20 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/instance_forms.py:19:41
   |
17 |     form_definition = INSTANCE_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
20 |         """解析成功后的重定向地址.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/instance_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/instance_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

D205 1 blank line required between summary line and description
 --> app/views/mixins/resource_forms.py:1:1
  |
1 | / """通用资源表单视图.
2 | | ------------------
3 | | 集成 GET/POST 逻辑,依赖 ResourceFormDefinition 与 BaseResourceService.
4 | | """
  | |___^
5 |
6 |   from __future__ import annotations
  |
help: Insert single blank line

ANN003 Missing type annotation for `**kwargs`
  --> app/views/mixins/resource_forms.py:58:51
   |
56 |     # HTTP Methods
57 |     # ------------------------------------------------------------------ #
58 |     def get(self, resource_id: int | None = None, **kwargs) -> str:
   |                                                   ^^^^^^^^
59 |         """GET 请求处理,显示表单.
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/views/mixins/resource_forms.py:73:52
   |
71 |         return render_template(self.form_definition.template, **context)
72 |
73 |     def post(self, resource_id: int | None = None, **kwargs) -> str | Response:
   |                                                    ^^^^^^^^
74 |         """POST 请求处理,提交表单.
   |

ANN202 Missing return type annotation for private function `_load_resource`
   --> app/views/mixins/resource_forms.py:102:9
    |
100 |     # Helpers
101 |     # ------------------------------------------------------------------ #
102 |     def _load_resource(self, resource_id: int | None):
    |         ^^^^^^^^^^^^^^
103 |         """加载资源对象.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `req`
   --> app/views/mixins/resource_forms.py:136:32
    |
134 |         return None
135 |
136 |     def _extract_payload(self, req) -> Mapping[str, Any]:
    |                                ^^^
137 |         """提取请求负载数据.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `resource`
   --> app/views/mixins/resource_forms.py:152:19
    |
150 |     def _build_context(
151 |         self,
152 |         resource: Any | None,
    |                   ^^^^^^^^^^
153 |         form_data: Mapping[str, Any] | None,
154 |         errors: str | None = None,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/views/mixins/resource_forms.py:185:51
    |
183 |         return base_context
184 |
185 |     def _resolve_success_redirect(self, instance: Any) -> str:
    |                                                   ^^^
186 |         """解析成功后的重定向地址.
    |

ARG002 Unused method argument: `instance`
   --> app/views/mixins/resource_forms.py:200:40
    |
198 |         return url_for(endpoint, **self._success_redirect_kwargs(instance))
199 |
200 |     def _success_redirect_kwargs(self, instance: Any) -> dict[str, Any]:
    |                                        ^^^^^^^^
201 |         """获取重定向的额外参数.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/views/mixins/resource_forms.py:200:50
    |
198 |         return url_for(endpoint, **self._success_redirect_kwargs(instance))
199 |
200 |     def _success_redirect_kwargs(self, instance: Any) -> dict[str, Any]:
    |                                                  ^^^
201 |         """获取重定向的额外参数.
    |

ARG002 Unused method argument: `instance`
   --> app/views/mixins/resource_forms.py:212:35
    |
210 |         return {}
211 |
212 |     def get_success_message(self, instance: Any) -> str:
    |                                   ^^^^^^^^
213 |         """获取成功消息.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/views/mixins/resource_forms.py:212:45
    |
210 |         return {}
211 |
212 |     def get_success_message(self, instance: Any) -> str:
    |                                             ^^^
213 |         """获取成功消息.
    |

ANN202 Missing return type annotation for private function `_load_resource`
  --> app/views/password_forms.py:19:9
   |
17 |     form_definition = CHANGE_PASSWORD_FORM_DEFINITION
18 |
19 |     def _load_resource(self, resource_id):
   |         ^^^^^^^^^^^^^^
20 |         """加载用户资源.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `resource_id`
  --> app/views/password_forms.py:19:30
   |
17 |     form_definition = CHANGE_PASSWORD_FORM_DEFINITION
18 |
19 |     def _load_resource(self, resource_id):
   |                              ^^^^^^^^^^^
20 |         """加载用户资源.
   |

ARG002 Unused method argument: `resource_id`
  --> app/views/password_forms.py:19:30
   |
17 |     form_definition = CHANGE_PASSWORD_FORM_DEFINITION
18 |
19 |     def _load_resource(self, resource_id):
   |                              ^^^^^^^^^^^
20 |         """加载用户资源.
   |

A004 Import `SystemError` is shadowing a Python builtin
 --> app/views/scheduler_forms.py:7:39
  |
5 | from flask import Response, request
6 |
7 | from app.errors import NotFoundError, SystemError, ValidationError
  |                                       ^^^^^^^^^^^
8 | from app.forms.definitions.scheduler_job import SCHEDULER_JOB_FORM_DEFINITION
9 | from app.utils.response_utils import jsonify_unified_error_message, jsonify_unified_success
  |

ANN002 Missing type annotation for `*args`
  --> app/views/scheduler_forms.py:23:19
   |
21 |     form_definition = SCHEDULER_JOB_FORM_DEFINITION
22 |
23 |     def get(self, *args, **kwargs) -> Never:
   |                   ^^^^^
24 |         """GET 请求处理(不支持).
   |

ARG002 Unused method argument: `args`
  --> app/views/scheduler_forms.py:23:20
   |
21 |     form_definition = SCHEDULER_JOB_FORM_DEFINITION
22 |
23 |     def get(self, *args, **kwargs) -> Never:
   |                    ^^^^
24 |         """GET 请求处理(不支持).
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/views/scheduler_forms.py:23:26
   |
21 |     form_definition = SCHEDULER_JOB_FORM_DEFINITION
22 |
23 |     def get(self, *args, **kwargs) -> Never:
   |                          ^^^^^^^^
24 |         """GET 请求处理(不支持).
   |

ARG002 Unused method argument: `kwargs`
  --> app/views/scheduler_forms.py:23:28
   |
21 |     form_definition = SCHEDULER_JOB_FORM_DEFINITION
22 |
23 |     def get(self, *args, **kwargs) -> Never:
   |                            ^^^^^^
24 |         """GET 请求处理(不支持).
   |

ANN002 Missing type annotation for `*args`
  --> app/views/scheduler_forms.py:36:20
   |
34 |         raise NotFoundError(msg)
35 |
36 |     def post(self, *args, **kwargs) -> Never:
   |                    ^^^^^
37 |         """POST 请求处理(不支持).
   |

ARG002 Unused method argument: `args`
  --> app/views/scheduler_forms.py:36:21
   |
34 |         raise NotFoundError(msg)
35 |
36 |     def post(self, *args, **kwargs) -> Never:
   |                     ^^^^
37 |         """POST 请求处理(不支持).
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/views/scheduler_forms.py:36:27
   |
34 |         raise NotFoundError(msg)
35 |
36 |     def post(self, *args, **kwargs) -> Never:
   |                           ^^^^^^^^
37 |         """POST 请求处理(不支持).
   |

ARG002 Unused method argument: `kwargs`
  --> app/views/scheduler_forms.py:36:29
   |
34 |         raise NotFoundError(msg)
35 |
36 |     def post(self, *args, **kwargs) -> Never:
   |                             ^^^^^^
37 |         """POST 请求处理(不支持).
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/views/scheduler_forms.py:49:32
   |
47 |         raise NotFoundError(msg)
48 |
49 |     def put(self, job_id: str, **kwargs) -> Response:
   |                                ^^^^^^^^
50 |         """PUT 请求处理,更新定时任务.
   |

ARG002 Unused method argument: `kwargs`
  --> app/views/scheduler_forms.py:49:34
   |
47 |         raise NotFoundError(msg)
48 |
49 |     def put(self, job_id: str, **kwargs) -> Response:
   |                                  ^^^^^^
50 |         """PUT 请求处理,更新定时任务.
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/views/scheduler_forms.py:78:16
   |
76 |         except (NotFoundError, ValidationError, SystemError):
77 |             raise
78 |         except Exception as exc:
   |                ^^^^^^^^^
79 |             return jsonify_unified_error_message(message="任务更新失败", extra={"exception": str(exc)})
   |

ANN202 Missing return type annotation for private function `_load_resource`
  --> app/views/scheduler_forms.py:81:9
   |
79 |             return jsonify_unified_error_message(message="任务更新失败", extra={"exception": str(exc)})
80 |
81 |     def _load_resource(self, job_id):
   |         ^^^^^^^^^^^^^^
82 |         """加载任务资源.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `job_id`
  --> app/views/scheduler_forms.py:81:30
   |
79 |             return jsonify_unified_error_message(message="任务更新失败", extra={"exception": str(exc)})
80 |
81 |     def _load_resource(self, job_id):
   |                              ^^^^^^
82 |         """加载任务资源.
   |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/tag_forms.py:19:9
   |
17 |     form_definition = TAG_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
20 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/tag_forms.py:19:41
   |
17 |     form_definition = TAG_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
20 |         """解析成功后的重定向地址.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/tag_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/tag_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/user_forms.py:19:35
   |
17 |     form_definition = USER_FORM_DEFINITION
18 |
19 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
20 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/user_forms.py:19:35
   |
17 |     form_definition = USER_FORM_DEFINITION
18 |
19 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
20 |         """获取成功消息.
   |

INP001 File `examples/logging/unified_logging_example.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/logging/unified_logging_example.py:1:1

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> examples/logging/unified_logging_example.py:43:15
   |
41 |     """模拟一次请求处理生命周期."""
42 |     request_id = str(uuid.uuid4())
43 |     user_id = random.randint(1, 100)
   |               ^^^^^^^^^^^^^^^^^^^^^^
44 |
45 |     bind_request_context(request_id=request_id, user_id=user_id)
   |

S311 Standard pseudo-random generators are not suitable for cryptographic purposes
  --> examples/logging/unified_logging_example.py:50:37
   |
48 |     try:
49 |         # 模拟业务校验
50 |         validate_payload({"amount": random.choice([10, -5, 20])})
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |
52 |         # 模拟业务逻辑与外部调用
   |

BLE001 Do not catch blind exception: `Exception`
  --> examples/logging/unified_logging_example.py:65:12
   |
63 |             payload=exc.extra,
64 |         )
65 |     except Exception as exc:
   |            ^^^^^^^^^
66 |         log_error(
67 |             "请求处理发生未预期错误",
   |

D103 Missing docstring in public function
  --> examples/logging/unified_logging_example.py:94:5
   |
94 | def main() -> None:
   |     ^^^^
95 |     bootstrap_logging()
96 |     for path in ("/api/accounts", "/api/databases", "/api/aggregations"):
   |

INP001 File `examples/time/unified_time_example.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/time/unified_time_example.py:1:1

PLC0415 `import` should be at the top-level of a file
   --> examples/time/unified_time_example.py:209:5
    |
207 | def demonstrate_performance_considerations() -> None:
208 |     """演示性能考虑."""
209 |     import time as time_module
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
210 |
211 |     # 测试批量时间格式化性能
    |

INP001 File `examples/validation/standard_api_templates.py` is part of an implicit namespace package. Add an `__init__.py`.
--> examples/validation/standard_api_templates.py:1:1

ERA001 Found commented-out code
  --> examples/validation/standard_api_templates.py:18:1
   |
17 | # ============================================================================
18 | # 模板1: JSON写接口(POST)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
19 | # ============================================================================
   |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `create_resource`
  --> examples/validation/standard_api_templates.py:23:5
   |
21 | @blueprint.route("/api/resources", methods=["POST"])
22 | @create_required
23 | def create_resource():
   |     ^^^^^^^^^^^^^^^
24 |     """创建资源接口模板.
   |
help: Add return type annotation

ERA001 Found commented-out code
  --> examples/validation/standard_api_templates.py:50:5
   |
49 |     # 4. 业务逻辑
50 |     # resource = Resource(**data)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |     # db.session.add(resource)
52 |     # db.session.commit()
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> examples/validation/standard_api_templates.py:51:5
   |
49 |     # 4. 业务逻辑
50 |     # resource = Resource(**data)
51 |     # db.session.add(resource)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
52 |     # db.session.commit()
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> examples/validation/standard_api_templates.py:52:5
   |
50 |     # resource = Resource(**data)
51 |     # db.session.add(resource)
52 |     # db.session.commit()
   |     ^^^^^^^^^^^^^^^^^^^^^
53 |
54 |     # 5. 返回成功响应
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> examples/validation/standard_api_templates.py:62:1
   |
61 | # ============================================================================
62 | # 模板2: 查询接口(GET)
   | ^^^^^^^^^^^^^^^^^^^^^^
63 | # ============================================================================
   |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `list_resources`
  --> examples/validation/standard_api_templates.py:67:5
   |
65 | @blueprint.route("/api/resources")
66 | @view_required
67 | def list_resources():
   |     ^^^^^^^^^^^^^^
68 |     """查询资源列表接口模板.
   |
help: Add return type annotation

PLR2004 Magic value used in comparison, consider replacing `100` with a constant variable
  --> examples/validation/standard_api_templates.py:85:35
   |
83 |         msg = "页码必须大于0"
84 |         raise ValidationError(msg)
85 |     if per_page < 1 or per_page > 100:
   |                                   ^^^
86 |         msg = "每页数量必须在1-100之间"
87 |         raise ValidationError(msg)
   |

ERA001 Found commented-out code
  --> examples/validation/standard_api_templates.py:90:5
   |
89 |     # 3. 构建查询
90 |     # query = Resource.query
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
91 |     #
92 |     # if search:
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> examples/validation/standard_api_templates.py:93:5
   |
91 |     #
92 |     # if search:
93 |     #     query = query.filter(Resource.name.contains(search))
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
94 |     #
95 |     # if status:
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> examples/validation/standard_api_templates.py:96:5
   |
94 |     #
95 |     # if status:
96 |     #     query = query.filter(Resource.status == status)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
97 |
98 |     # 4. 分页
   |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:99:5
    |
 98 |     # 4. 分页
 99 |     # pagination = query.paginate(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 |     #     page=page,
101 |     #     per_page=per_page,
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:100:5
    |
 98 |     # 4. 分页
 99 |     # pagination = query.paginate(
100 |     #     page=page,
    |     ^^^^^^^^^^^^^^^^
101 |     #     per_page=per_page,
102 |     #     error_out=False
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:101:5
    |
 99 |     # pagination = query.paginate(
100 |     #     page=page,
101 |     #     per_page=per_page,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
102 |     #     error_out=False
103 |     # )
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:102:5
    |
100 |     #     page=page,
101 |     #     per_page=per_page,
102 |     #     error_out=False
    |     ^^^^^^^^^^^^^^^^^^^^^
103 |     # )
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:103:5
    |
101 |     #     per_page=per_page,
102 |     #     error_out=False
103 |     # )
    |     ^^^
104 |
105 |     # 5. 返回响应
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:122:1
    |
121 | # ============================================================================
122 | # 模板3: 更新接口(PUT/PATCH)
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
123 | # ============================================================================
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `update_resource`
   --> examples/validation/standard_api_templates.py:127:5
    |
125 | @blueprint.route("/api/resources/<int:resource_id>", methods=["PUT"])
126 | @update_required
127 | def update_resource(resource_id: int):
    |     ^^^^^^^^^^^^^^^
128 |     """更新资源接口模板.
    |
help: Add return type annotation

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:136:5
    |
134 |     """
135 |     # 1. 查找资源
136 |     # resource = Resource.query.get(resource_id)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
137 |     # if not resource:
138 |     #     raise NotFoundError("资源不存在")
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:138:5
    |
136 |     # resource = Resource.query.get(resource_id)
137 |     # if not resource:
138 |     #     raise NotFoundError("资源不存在")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
139 |
140 |     # 2. 获取并清理数据
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:159:5
    |
157 |     # for key, value in data.items():
158 |     #     if hasattr(resource, key):
159 |     #         setattr(resource, key, value)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
160 |     #
161 |     # db.session.commit()
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:161:5
    |
159 |     #         setattr(resource, key, value)
160 |     #
161 |     # db.session.commit()
    |     ^^^^^^^^^^^^^^^^^^^^^
162 |
163 |     # 5. 返回成功响应
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:171:1
    |
170 | # ============================================================================
171 | # 模板4: 删除接口(DELETE)
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
172 | # ============================================================================
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `delete_resource`
   --> examples/validation/standard_api_templates.py:176:5
    |
174 | @blueprint.route("/api/resources/<int:resource_id>", methods=["DELETE"])
175 | @delete_required
176 | def delete_resource(resource_id: int):
    |     ^^^^^^^^^^^^^^^
177 |     """删除资源接口模板.
    |
help: Add return type annotation

ARG001 Unused function argument: `resource_id`
   --> examples/validation/standard_api_templates.py:176:21
    |
174 | @blueprint.route("/api/resources/<int:resource_id>", methods=["DELETE"])
175 | @delete_required
176 | def delete_resource(resource_id: int):
    |                     ^^^^^^^^^^^
177 |     """删除资源接口模板.
    |

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:185:5
    |
183 |     """
184 |     # 1. 查找资源
185 |     # resource = Resource.query.get(resource_id)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
186 |     # if not resource:
187 |     #     raise NotFoundError("资源不存在")
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:187:5
    |
185 |     # resource = Resource.query.get(resource_id)
186 |     # if not resource:
187 |     #     raise NotFoundError("资源不存在")
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
188 |
189 |     # 2. 删除资源
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:190:5
    |
189 |     # 2. 删除资源
190 |     # db.session.delete(resource)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
191 |     # db.session.commit()
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:191:5
    |
189 |     # 2. 删除资源
190 |     # db.session.delete(resource)
191 |     # db.session.commit()
    |     ^^^^^^^^^^^^^^^^^^^^^
192 |
193 |     # 3. 返回成功响应
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:198:1
    |
197 | # ============================================================================
198 | # 模板5: 批量操作接口(POST)
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
199 | # ============================================================================
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `batch_operation`
   --> examples/validation/standard_api_templates.py:203:5
    |
201 | @blueprint.route("/api/resources/batch", methods=["POST"])
202 | @update_required
203 | def batch_operation():
    |     ^^^^^^^^^^^^^^^
204 |     """批量操作接口模板.
    |
help: Add return type annotation

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:240:5
    |
239 |     # for resource_id in ids:
240 |     #     try:
    |     ^^^^^^^^^^
241 |     #         resource = Resource.query.get(resource_id)
242 |     #         if resource:
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:241:5
    |
239 |     # for resource_id in ids:
240 |     #     try:
241 |     #         resource = Resource.query.get(resource_id)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
242 |     #         if resource:
243 |     #             if action == "enable":
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:244:5
    |
242 |     #         if resource:
243 |     #             if action == "enable":
244 |     #                 resource.is_active = True
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
245 |     #             elif action == "disable":
246 |     #                 resource.is_active = False
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:245:5
    |
243 |     #             if action == "enable":
244 |     #                 resource.is_active = True
245 |     #             elif action == "disable":
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
246 |     #                 resource.is_active = False
247 |     #             elif action == "delete":
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:246:5
    |
244 |     #                 resource.is_active = True
245 |     #             elif action == "disable":
246 |     #                 resource.is_active = False
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
247 |     #             elif action == "delete":
248 |     #                 db.session.delete(resource)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:247:5
    |
245 |     #             elif action == "disable":
246 |     #                 resource.is_active = False
247 |     #             elif action == "delete":
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
248 |     #                 db.session.delete(resource)
249 |     #             success_count += 1
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:248:5
    |
246 |     #                 resource.is_active = False
247 |     #             elif action == "delete":
248 |     #                 db.session.delete(resource)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
249 |     #             success_count += 1
250 |     #         else:
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:249:5
    |
247 |     #             elif action == "delete":
248 |     #                 db.session.delete(resource)
249 |     #             success_count += 1
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
250 |     #         else:
251 |     #             failed_count += 1
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:250:5
    |
248 |     #                 db.session.delete(resource)
249 |     #             success_count += 1
250 |     #         else:
    |     ^^^^^^^^^^^^^^^
251 |     #             failed_count += 1
252 |     #     except Exception:
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:251:5
    |
249 |     #             success_count += 1
250 |     #         else:
251 |     #             failed_count += 1
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
252 |     #     except Exception:
253 |     #         failed_count += 1
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:252:5
    |
250 |     #         else:
251 |     #             failed_count += 1
252 |     #     except Exception:
    |     ^^^^^^^^^^^^^^^^^^^^^^^
253 |     #         failed_count += 1
254 |     #
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:253:5
    |
251 |     #             failed_count += 1
252 |     #     except Exception:
253 |     #         failed_count += 1
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
254 |     #
255 |     # db.session.commit()
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:255:5
    |
253 |     #         failed_count += 1
254 |     #
255 |     # db.session.commit()
    |     ^^^^^^^^^^^^^^^^^^^^^
256 |
257 |     # 4. 返回操作结果
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:269:1
    |
268 | # ============================================================================
269 | # 反面示例:不要这样写
    | ^^^^^^^^^^^^^^^^^^^^^
270 | # ============================================================================
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `bad_example_create`
   --> examples/validation/standard_api_templates.py:272:5
    |
270 | # ============================================================================
271 |
272 | def bad_example_create():
    |     ^^^^^^^^^^^^^^^^^^
273 |     """❌ 错误示例:不要这样写.
    |
help: Add return type annotation

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:293:5
    |
292 |     # ❌ 没有数据清理
293 |     # resource = Resource(**data)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
294 |
295 |     return {"success": True, "data": {}}, 200
    |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `bad_example_list`
   --> examples/validation/standard_api_templates.py:298:5
    |
298 | def bad_example_list():
    |     ^^^^^^^^^^^^^^^^
299 |     """❌ 错误示例:不要这样写.
    |
help: Add return type annotation

ERA001 Found commented-out code
   --> examples/validation/standard_api_templates.py:311:5
    |
310 |     # ❌ 没有参数验证
311 |     # query = Resource.query.paginate(page=page, per_page=per_page)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
312 |
313 |     # ❌ 响应格式不统一
    |
help: Remove commented-out code

INP001 File `migrations/env.py` is part of an implicit namespace package. Add an `__init__.py`.
--> migrations/env.py:1:1

D100 Missing docstring in public module
--> migrations/env.py:1:1

ANN201 Missing return type annotation for public function `get_engine`
  --> migrations/env.py:17:5
   |
17 | def get_engine():
   |     ^^^^^^^^^^
18 |     try:
19 |         # this works with Flask-SQLAlchemy<3 and Alchemical
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> migrations/env.py:17:5
   |
17 | def get_engine():
   |     ^^^^^^^^^^
18 |     try:
19 |         # this works with Flask-SQLAlchemy<3 and Alchemical
   |

ANN201 Missing return type annotation for public function `get_engine_url`
  --> migrations/env.py:26:5
   |
26 | def get_engine_url():
   |     ^^^^^^^^^^^^^^
27 |     try:
28 |         return get_engine().url.render_as_string(hide_password=False).replace(
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> migrations/env.py:26:5
   |
26 | def get_engine_url():
   |     ^^^^^^^^^^^^^^
27 |     try:
28 |         return get_engine().url.render_as_string(hide_password=False).replace(
   |

ERA001 Found commented-out code
  --> migrations/env.py:36:1
   |
34 | # add your model's MetaData object here
35 | # for 'autogenerate' support
36 | # from myapp import mymodel
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 | # target_metadata = mymodel.Base.metadata
38 | config.set_main_option("sqlalchemy.url", get_engine_url())
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> migrations/env.py:37:1
   |
35 | # for 'autogenerate' support
36 | # from myapp import mymodel
37 | # target_metadata = mymodel.Base.metadata
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 | config.set_main_option("sqlalchemy.url", get_engine_url())
39 | target_db = current_app.extensions["migrate"].db
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> migrations/env.py:43:1
   |
41 | # other values from the config, defined by the needs of env.py,
42 | # can be acquired:
43 | # my_important_option = config.get_main_option("my_important_option")
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
44 | # ... etc.
   |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `get_metadata`
  --> migrations/env.py:47:5
   |
47 | def get_metadata():
   |     ^^^^^^^^^^^^
48 |     if hasattr(target_db, "metadatas"):
49 |         return target_db.metadatas[None]
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> migrations/env.py:47:5
   |
47 | def get_metadata():
   |     ^^^^^^^^^^^^
48 |     if hasattr(target_db, "metadatas"):
49 |         return target_db.metadatas[None]
   |

ANN001 Missing type annotation for function argument `context`
  --> migrations/env.py:85:37
   |
83 |     # when there are no changes to the schema
84 |     # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
85 |     def process_revision_directives(context, revision, directives) -> None:
   |                                     ^^^^^^^
86 |         if getattr(config.cmd_opts, "autogenerate", False):
87 |             script = directives[0]
   |

ARG001 Unused function argument: `context`
  --> migrations/env.py:85:37
   |
83 |     # when there are no changes to the schema
84 |     # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
85 |     def process_revision_directives(context, revision, directives) -> None:
   |                                     ^^^^^^^
86 |         if getattr(config.cmd_opts, "autogenerate", False):
87 |             script = directives[0]
   |

ANN001 Missing type annotation for function argument `revision`
  --> migrations/env.py:85:46
   |
83 |     # when there are no changes to the schema
84 |     # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
85 |     def process_revision_directives(context, revision, directives) -> None:
   |                                              ^^^^^^^^
86 |         if getattr(config.cmd_opts, "autogenerate", False):
87 |             script = directives[0]
   |

ARG001 Unused function argument: `revision`
  --> migrations/env.py:85:46
   |
83 |     # when there are no changes to the schema
84 |     # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
85 |     def process_revision_directives(context, revision, directives) -> None:
   |                                              ^^^^^^^^
86 |         if getattr(config.cmd_opts, "autogenerate", False):
87 |             script = directives[0]
   |

ANN001 Missing type annotation for function argument `directives`
  --> migrations/env.py:85:56
   |
83 |     # when there are no changes to the schema
84 |     # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
85 |     def process_revision_directives(context, revision, directives) -> None:
   |                                                        ^^^^^^^^^^
86 |         if getattr(config.cmd_opts, "autogenerate", False):
87 |             script = directives[0]
   |

INP001 File `nginx/gunicorn/gunicorn-dev.conf.py` is part of an implicit namespace package. Add an `__init__.py`.
--> nginx/gunicorn/gunicorn-dev.conf.py:1:1

D100 Missing docstring in public module
--> nginx/gunicorn/gunicorn-dev.conf.py:1:1

RUF003 Comment contains ambiguous `，` (FULLWIDTH COMMA). Did you mean `,` (COMMA)?
  --> nginx/gunicorn/gunicorn-dev.conf.py:9:33
   |
 7 | # 工作进程 - 开发环境简化配置
 8 | workers = 1  # 开发环境使用单进程
 9 | worker_class = "sync"  # 使用同步工作器，便于调试
   |                                        ^^
10 | timeout = 60  # 开发环境超时时间更长
11 | keepalive = 2
   |

INP001 File `nginx/gunicorn/gunicorn-prod.conf.py` is part of an implicit namespace package. Add an `__init__.py`.
--> nginx/gunicorn/gunicorn-prod.conf.py:1:1

D100 Missing docstring in public module
--> nginx/gunicorn/gunicorn-prod.conf.py:1:1

RUF003 Comment contains ambiguous `，` (FULLWIDTH COMMA). Did you mean `,` (COMMA)?
  --> nginx/gunicorn/gunicorn-prod.conf.py:8:22
   |
 7 | # 工作进程 - 简化配置
 8 | workers = 1  # 固定2个进程，避免复杂配置
   |                           ^^
 9 | worker_class = "gevent"  # 使用gevent工作器，支持异步
10 | worker_connections = 1000  # gevent工作器连接数
   |

RUF003 Comment contains ambiguous `，` (FULLWIDTH COMMA). Did you mean `,` (COMMA)?
  --> nginx/gunicorn/gunicorn-prod.conf.py:9:39
   |
 7 | # 工作进程 - 简化配置
 8 | workers = 1  # 固定2个进程，避免复杂配置
 9 | worker_class = "gevent"  # 使用gevent工作器，支持异步
   |                                            ^^
10 | worker_connections = 1000  # gevent工作器连接数
11 | timeout = 120
   |

RUF003 Comment contains ambiguous `，` (FULLWIDTH COMMA). Did you mean `,` (COMMA)?
  --> nginx/gunicorn/gunicorn-prod.conf.py:22:30
   |
20 | accesslog = "/app/userdata/logs/gunicorn_access.log"
21 | errorlog = "/app/userdata/logs/gunicorn_error.log"
22 | loglevel = "info"  # 改为info级别，减少日志量
   |                                  ^^
23 | access_log_format = '%(h)s %(l)s %(u)s %(t)s "%(r)s" %(s)s %(b)s "%(f)s" "%(a)s" %(D)s'
   |

S108 Probable insecure usage of temporary file or directory: "/dev/shm"
  --> nginx/gunicorn/gunicorn-prod.conf.py:48:18
   |
47 | # Gevent特定配置
48 | worker_tmp_dir = "/dev/shm"  # 使用内存文件系统提高性能
   |                  ^^^^^^^^^^
   |

D103 Missing docstring in public function
  --> scripts/audit_colors.py:38:5
   |
38 | def iter_files(paths: Sequence[Path]) -> Sequence[Path]:
   |     ^^^^^^^^^^
39 |     for base in paths:
40 |         if not base.exists():
   |

D103 Missing docstring in public function
  --> scripts/audit_colors.py:54:5
   |
54 | def scan_file(path: Path) -> list[tuple[int, str]]:
   |     ^^^^^^^^^
55 |     if path in ALLOWLIST:
56 |         return []
   |

D103 Missing docstring in public function
  --> scripts/audit_colors.py:76:5
   |
76 | def format_report(results: dict[str, list[tuple[int, str]]]) -> str:
   |     ^^^^^^^^^^^^^
77 |     lines: list[str] = []
78 |     for path, entries in sorted(results.items()):
   |

D103 Missing docstring in public function
  --> scripts/audit_colors.py:86:5
   |
86 | def main(argv: Sequence[str]) -> int:
   |     ^^^^
87 |     parser = argparse.ArgumentParser(description=__doc__)
88 |     parser.add_argument("paths", nargs="*", type=Path, default=DEFAULT_SCAN_ROOTS,
   |

EXE001 Shebang is present but file is not executable
 --> scripts/check_missing_docs_smart.py:1:1
  |
1 | #!/usr/bin/env python3
  | ^^^^^^^^^^^^^^^^^^^^^^
2 | """Docstring 缺失检测脚本.
  |

C901 `analyze_python_file` is too complex (16 > 10)
   --> scripts/check_missing_docs_smart.py:141:5
    |
141 | def analyze_python_file(path: Path) -> MissingDocReport | None:
    |     ^^^^^^^^^^^^^^^^^^^
142 |     """Create a missing docstring report for a single Python file.
    |

PLR0912 Too many branches (17 > 12)
   --> scripts/check_missing_docs_smart.py:141:5
    |
141 | def analyze_python_file(path: Path) -> MissingDocReport | None:
    |     ^^^^^^^^^^^^^^^^^^^
142 |     """Create a missing docstring report for a single Python file.
    |

C901 `analyze_js_file` is too complex (18 > 10)
   --> scripts/check_missing_docs_smart.py:241:5
    |
241 | def analyze_js_file(path: Path) -> MissingDocReport | None:
    |     ^^^^^^^^^^^^^^^
242 |     """Create a missing JSDoc report for a JavaScript file.
    |

PLR0912 Too many branches (19 > 12)
   --> scripts/check_missing_docs_smart.py:241:5
    |
241 | def analyze_js_file(path: Path) -> MissingDocReport | None:
    |     ^^^^^^^^^^^^^^^
242 |     """Create a missing JSDoc report for a JavaScript file.
    |

PLR0915 Too many statements (59 > 50)
   --> scripts/check_missing_docs_smart.py:241:5
    |
241 | def analyze_js_file(path: Path) -> MissingDocReport | None:
    |     ^^^^^^^^^^^^^^^
242 |     """Create a missing JSDoc report for a JavaScript file.
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> scripts/check_missing_docs_smart.py:423:17
    |
421 |     missing_classes = sum(len(rpt.classes) for rpt in results.values())
422 |     missing_functions = sum(len(rpt.functions) for rpt in results.values())
423 |     timestamp = dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    |                 ^^^^^^^^^^^^^^^^^
424 |     lines = [
425 |         "# 缺失 Docstring 统计报告",
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

PERF401 Use `list.extend` to create a transformed list
   --> scripts/check_missing_docs_smart.py:447:17
    |
445 |             lines.append(f"- 类缺少 {doc_label}:")
446 |             for entry in rpt.classes:
447 |                 lines.append(f"  - `{entry.name}` (行 {entry.line})")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
448 |         if rpt.functions:
449 |             lines.append(f"- 函数/方法缺少 {doc_label}:")
    |
help: Replace for loop with list.extend

PERF401 Use `list.extend` to create a transformed list
   --> scripts/check_missing_docs_smart.py:451:17
    |
449 |             lines.append(f"- 函数/方法缺少 {doc_label}:")
450 |             for entry in rpt.functions:
451 |                 lines.append(f"  - `{entry.name}` (行 {entry.line})")
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
452 |         if rpt.function_sections:
453 |             lines.append("- 函数/方法文档不完整:")
    |
help: Replace for loop with list.extend

RUF001 String contains ambiguous `，` (FULLWIDTH COMMA). Did you mean `,` (COMMA)?
  --> scripts/cleanup_fullwidth_punct.py:11:6
   |
10 | TRANSLATION_MAP = {
11 |     "，": ",",
   |      ^^
12 |     "。": ".",
13 |     "：": ":",
   |

RUF001 String contains ambiguous `：` (FULLWIDTH COLON). Did you mean `:` (COLON)?
  --> scripts/cleanup_fullwidth_punct.py:13:6
   |
11 |     "，": ",",
12 |     "。": ".",
13 |     "：": ":",
   |      ^^
14 |     "；": ";",
15 |     "！": "!",
   |

RUF001 String contains ambiguous `；` (FULLWIDTH SEMICOLON). Did you mean `;` (SEMICOLON)?
  --> scripts/cleanup_fullwidth_punct.py:14:6
   |
12 |     "。": ".",
13 |     "：": ":",
14 |     "；": ";",
   |      ^^
15 |     "！": "!",
16 |     "？": "?",
   |

RUF001 String contains ambiguous `！` (FULLWIDTH EXCLAMATION MARK). Did you mean `!` (EXCLAMATION MARK)?
  --> scripts/cleanup_fullwidth_punct.py:15:6
   |
13 |     "：": ":",
14 |     "；": ";",
15 |     "！": "!",
   |      ^^
16 |     "？": "?",
17 |     "（": "(",
   |

RUF001 String contains ambiguous `？` (FULLWIDTH QUESTION MARK). Did you mean `?` (QUESTION MARK)?
  --> scripts/cleanup_fullwidth_punct.py:16:6
   |
14 |     "；": ";",
15 |     "！": "!",
16 |     "？": "?",
   |      ^^
17 |     "（": "(",
18 |     "）": ")",
   |

RUF001 String contains ambiguous `（` (FULLWIDTH LEFT PARENTHESIS). Did you mean `(` (LEFT PARENTHESIS)?
  --> scripts/cleanup_fullwidth_punct.py:17:6
   |
15 |     "！": "!",
16 |     "？": "?",
17 |     "（": "(",
   |      ^^
18 |     "）": ")",
19 |     "【": "[",
   |

RUF001 String contains ambiguous `）` (FULLWIDTH RIGHT PARENTHESIS). Did you mean `)` (RIGHT PARENTHESIS)?
  --> scripts/cleanup_fullwidth_punct.py:18:6
   |
16 |     "？": "?",
17 |     "（": "(",
18 |     "）": ")",
   |      ^^
19 |     "【": "[",
20 |     "】": "]",
   |

RUF001 String contains ambiguous `‘` (LEFT SINGLE QUOTATION MARK). Did you mean ``` (GRAVE ACCENT)?
  --> scripts/cleanup_fullwidth_punct.py:23:6
   |
21 |     "“": '"',
22 |     "”": '"',
23 |     "‘": "'",
   |      ^
24 |     "’": "'",
25 | }
   |

RUF001 String contains ambiguous `’` (RIGHT SINGLE QUOTATION MARK). Did you mean ``` (GRAVE ACCENT)?
  --> scripts/cleanup_fullwidth_punct.py:24:6
   |
22 |     "”": '"',
23 |     "‘": "'",
24 |     "’": "'",
   |      ^
25 | }
   |

D103 Missing docstring in public function
  --> scripts/cleanup_fullwidth_punct.py:31:5
   |
31 | def should_process(path: Path) -> bool:
   |     ^^^^^^^^^^^^^^
32 |     return path.suffix in SUPPORTED_SUFFIXES
   |

D103 Missing docstring in public function
  --> scripts/cleanup_fullwidth_punct.py:35:5
   |
35 | def normalize_text(text: str) -> str:
   |     ^^^^^^^^^^^^^^
36 |     result = text
37 |     for full, half in TRANSLATION_MAP.items():
   |

D103 Missing docstring in public function
  --> scripts/cleanup_fullwidth_punct.py:42:5
   |
42 | def process_file(path: Path) -> bool:
   |     ^^^^^^^^^^^^
43 |     original = path.read_text(encoding="utf-8")
44 |     updated = normalize_text(original)
   |

ANN201 Missing return type annotation for public function `iter_files`
  --> scripts/cleanup_fullwidth_punct.py:51:5
   |
51 | def iter_files(root: Path):
   |     ^^^^^^^^^^
52 |     if root.is_file():
53 |         yield root
   |
help: Add return type annotation

D103 Missing docstring in public function
  --> scripts/cleanup_fullwidth_punct.py:51:5
   |
51 | def iter_files(root: Path):
   |     ^^^^^^^^^^
52 |     if root.is_file():
53 |         yield root
   |

D103 Missing docstring in public function
  --> scripts/cleanup_fullwidth_punct.py:60:5
   |
60 | def main() -> int:
   |     ^^^^
61 |     parser = argparse.ArgumentParser("cleanup_fullwidth_punct")
62 |     parser.add_argument("paths", nargs="*", default=["app"], help="目标路径,默认 app")
   |

T201 `print` found
  --> scripts/cleanup_fullwidth_punct.py:71:13
   |
69 |         root = Path(path_str).resolve()
70 |         if not root.exists():
71 |             print(f"路径不存在: {root}", file=sys.stderr)
   |             ^^^^^
72 |             continue
73 |         for file_path in iter_files(root):
   |
help: Remove `print`

T201 `print` found
  --> scripts/cleanup_fullwidth_punct.py:84:5
   |
82 |                 skipped_files.append(file_path)
83 |
84 |     print(f"处理完成: 修改 {len(changed_files)} 个文件,跳过 {len(skipped_files)} 个文件.")
   |     ^^^^^
85 |     for file_path in changed_files:
86 |         print(f"更新 -> {file_path}")
   |
help: Remove `print`

T201 `print` found
  --> scripts/cleanup_fullwidth_punct.py:86:9
   |
84 |     print(f"处理完成: 修改 {len(changed_files)} 个文件,跳过 {len(skipped_files)} 个文件.")
85 |     for file_path in changed_files:
86 |         print(f"更新 -> {file_path}")
   |         ^^^^^
87 |     return 0
   |
help: Remove `print`

D205 1 blank line required between summary line and description
 --> scripts/code/analyze_code.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """代码统计分析脚本
3 | | 用于生成项目代码的详细统计报告.
4 | | """
  | |___^
5 |
6 |   import json
  |
help: Insert single blank line

ANN201 Missing return type annotation for public function `count_lines`
  --> scripts/code/analyze_code.py:18:5
   |
18 | def count_lines(filepath):
   |     ^^^^^^^^^^^
19 |     """统计指定文件的有效行数.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `filepath`
  --> scripts/code/analyze_code.py:18:17
   |
18 | def count_lines(filepath):
   |                 ^^^^^^^^
19 |     """统计指定文件的有效行数.
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> scripts/code/analyze_code.py:29:14
   |
27 |     """
28 |     try:
29 |         with open(filepath, encoding="utf-8") as f:
   |              ^^^^
30 |             return len(f.readlines())
31 |     except:
   |
help: Replace with `Path.open()`

E722 Do not use bare `except`
  --> scripts/code/analyze_code.py:31:5
   |
29 |         with open(filepath, encoding="utf-8") as f:
30 |             return len(f.readlines())
31 |     except:
   |     ^^^^^^
32 |         return 0
   |

ANN201 Missing return type annotation for public function `analyze_directory`
  --> scripts/code/analyze_code.py:34:5
   |
32 |         return 0
33 |
34 | def analyze_directory(base_dir, exclude_patterns=None):
   |     ^^^^^^^^^^^^^^^^^
35 |     """分析目录结构和代码统计.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `base_dir`
  --> scripts/code/analyze_code.py:34:23
   |
32 |         return 0
33 |
34 | def analyze_directory(base_dir, exclude_patterns=None):
   |                       ^^^^^^^^
35 |     """分析目录结构和代码统计.
   |

ANN001 Missing type annotation for function argument `exclude_patterns`
  --> scripts/code/analyze_code.py:34:33
   |
32 |         return 0
33 |
34 | def analyze_directory(base_dir, exclude_patterns=None):
   |                                 ^^^^^^^^^^^^^^^^
35 |     """分析目录结构和代码统计.
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> scripts/code/analyze_code.py:63:28
   |
61 |         for file in files:
62 |             if file.endswith(valid_extensions):
63 |                 filepath = os.path.join(root, file)
   |                            ^^^^^^^^^^^^
64 |                 lines = count_lines(filepath)
65 |                 rel_path = os.path.relpath(filepath, base_dir)
   |

PTH122 `os.path.splitext()` should be replaced by `Path.suffix`, `Path.stem`, and `Path.parent`
  --> scripts/code/analyze_code.py:66:23
   |
64 |                 lines = count_lines(filepath)
65 |                 rel_path = os.path.relpath(filepath, base_dir)
66 |                 ext = os.path.splitext(file)[1]
   |                       ^^^^^^^^^^^^^^^^
67 |
68 |                 # 获取目录
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> scripts/code/analyze_code.py:69:28
   |
68 |                 # 获取目录
69 |                 dir_path = os.path.dirname(rel_path) if os.path.dirname(rel_path) else "根目录"
   |                            ^^^^^^^^^^^^^^^
70 |
71 |                 files_by_dir[dir_path].append({
   |
help: Replace with `Path(...).parent`

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> scripts/code/analyze_code.py:69:57
   |
68 |                 # 获取目录
69 |                 dir_path = os.path.dirname(rel_path) if os.path.dirname(rel_path) else "根目录"
   |                                                         ^^^^^^^^^^^^^^^
70 |
71 |                 files_by_dir[dir_path].append({
   |
help: Replace with `Path(...).parent`

ANN001 Missing type annotation for function argument `stats`
  --> scripts/code/analyze_code.py:90:19
   |
88 |     }
89 |
90 | def print_summary(stats) -> None:
   |                   ^^^^^
91 |     """打印汇总统计信息.
   |

ANN001 Missing type annotation for function argument `stats`
   --> scripts/code/analyze_code.py:115:21
    |
113 |     _echo("")
114 |
115 | def print_top_files(stats, top_n=20) -> None:
    |                     ^^^^^
116 |     """展示行数最多的文件列表.
    |

ANN001 Missing type annotation for function argument `top_n`
   --> scripts/code/analyze_code.py:115:28
    |
113 |     _echo("")
114 |
115 | def print_top_files(stats, top_n=20) -> None:
    |                            ^^^^^
116 |     """展示行数最多的文件列表.
    |

PERF401 Use `list.extend` to create a transformed list
   --> scripts/code/analyze_code.py:129:13
    |
127 |       for files in stats["files_by_dir"].values():
128 |           for file_info in files:
129 | /             all_files.append({
130 | |                 "path": file_info["name"],
131 | |                 "lines": file_info["lines"],
132 | |             })
    | |______________^
133 |
134 |       all_files.sort(key=lambda x: x["lines"], reverse=True)
    |
help: Replace for loop with list.extend

ANN001 Missing type annotation for function argument `stats`
   --> scripts/code/analyze_code.py:142:20
    |
140 |     _echo("")
141 |
142 | def export_to_json(stats, output_file) -> None:
    |                    ^^^^^
143 |     """将统计结果导出为 JSON 文件.
    |

ANN001 Missing type annotation for function argument `output_file`
   --> scripts/code/analyze_code.py:142:27
    |
140 |     _echo("")
141 |
142 | def export_to_json(stats, output_file) -> None:
    |                           ^^^^^^^^^^^
143 |     """将统计结果导出为 JSON 文件.
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> scripts/code/analyze_code.py:153:10
    |
152 |     """
153 |     with open(output_file, "w", encoding="utf-8") as f:
    |          ^^^^
154 |         json.dump(stats, f, indent=2, ensure_ascii=False)
155 |     _echo(f"统计结果已导出到: {output_file}")
    |
help: Replace with `Path.open()`

ANN001 Missing type annotation for function argument `stats`
   --> scripts/code/analyze_code.py:157:30
    |
155 |     _echo(f"统计结果已导出到: {output_file}")
156 |
157 | def generate_markdown_report(stats, output_file) -> None:
    |                              ^^^^^
158 |     """生成 Markdown 版本的代码统计报告.
    |

ANN001 Missing type annotation for function argument `output_file`
   --> scripts/code/analyze_code.py:157:37
    |
155 |     _echo(f"统计结果已导出到: {output_file}")
156 |
157 | def generate_markdown_report(stats, output_file) -> None:
    |                                     ^^^^^^^^^^^
158 |     """生成 Markdown 版本的代码统计报告.
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> scripts/code/analyze_code.py:168:10
    |
167 |     """
168 |     with open(output_file, "w", encoding="utf-8") as f:
    |          ^^^^
169 |         f.write("# 代码统计报告\n\n")
170 |         f.write(f"生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    |
help: Replace with `Path.open()`

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> scripts/code/analyze_code.py:170:26
    |
168 |     with open(output_file, "w", encoding="utf-8") as f:
169 |         f.write("# 代码统计报告\n\n")
170 |         f.write(f"生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    |                              ^^^^^^^^^^^^^^
171 |
172 |         f.write("## 总体统计\n\n")
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

E501 Line too long (150 > 120)
   --> scripts/code/analyze_code.py:195:121
    |
193 | …
194 | …
195 | …s']} |\n" for file_info in sorted(files, key=lambda x: x["lines"], reverse=True))
    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
196 | …
    |

INP001 File `scripts/code/safe_update_code_analysis.py` is part of an implicit namespace package. Add an `__init__.py`.
--> scripts/code/safe_update_code_analysis.py:1:1

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> scripts/code/safe_update_code_analysis.py:13:11
   |
12 | # --- CONFIGURATION ---
13 | APP_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../app"))
   |           ^^^^^^^^^^^^^^^
14 | REPORT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../docs/reports/code_analysis_report.md"))
15 | EXCLUDE_DIRS = [os.path.join(APP_DIR, "static/vendor")]
   |
help: Replace with `Path(...).resolve()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> scripts/code/safe_update_code_analysis.py:13:27
   |
12 | # --- CONFIGURATION ---
13 | APP_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../app"))
   |                           ^^^^^^^^^^^^
14 | REPORT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../docs/reports/code_analysis_report.md"))
15 | EXCLUDE_DIRS = [os.path.join(APP_DIR, "static/vendor")]
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> scripts/code/safe_update_code_analysis.py:13:40
   |
12 | # --- CONFIGURATION ---
13 | APP_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../app"))
   |                                        ^^^^^^^^^^^^^^^
14 | REPORT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../docs/reports/code_analysis_report.md"))
15 | EXCLUDE_DIRS = [os.path.join(APP_DIR, "static/vendor")]
   |
help: Replace with `Path(...).parent`

PTH100 `os.path.abspath()` should be replaced by `Path.resolve()`
  --> scripts/code/safe_update_code_analysis.py:14:15
   |
12 | # --- CONFIGURATION ---
13 | APP_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../app"))
14 | REPORT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../docs/reports/code_analysis_report.md"))
   |               ^^^^^^^^^^^^^^^
15 | EXCLUDE_DIRS = [os.path.join(APP_DIR, "static/vendor")]
16 | FILE_EXTENSIONS = (".py", ".js", ".html", ".css", ".yaml", ".yml")
   |
help: Replace with `Path(...).resolve()`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> scripts/code/safe_update_code_analysis.py:14:31
   |
12 | # --- CONFIGURATION ---
13 | APP_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../app"))
14 | REPORT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../docs/reports/code_analysis_report.md"))
   |                               ^^^^^^^^^^^^
15 | EXCLUDE_DIRS = [os.path.join(APP_DIR, "static/vendor")]
16 | FILE_EXTENSIONS = (".py", ".js", ".html", ".css", ".yaml", ".yml")
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> scripts/code/safe_update_code_analysis.py:14:44
   |
12 | # --- CONFIGURATION ---
13 | APP_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../app"))
14 | REPORT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../docs/reports/code_analysis_report.md"))
   |                                            ^^^^^^^^^^^^^^^
15 | EXCLUDE_DIRS = [os.path.join(APP_DIR, "static/vendor")]
16 | FILE_EXTENSIONS = (".py", ".js", ".html", ".css", ".yaml", ".yml")
   |
help: Replace with `Path(...).parent`

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> scripts/code/safe_update_code_analysis.py:15:17
   |
13 | APP_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../app"))
14 | REPORT_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), "../docs/reports/code_analysis_report.md"))
15 | EXCLUDE_DIRS = [os.path.join(APP_DIR, "static/vendor")]
   |                 ^^^^^^^^^^^^
16 | FILE_EXTENSIONS = (".py", ".js", ".html", ".css", ".yaml", ".yml")
   |

ANN201 Missing return type annotation for public function `analyze_directory`
  --> scripts/code/safe_update_code_analysis.py:23:5
   |
21 | # --- ANALYSIS FUNCTIONS ---
22 |
23 | def analyze_directory(path, exclude_dirs, extensions):
   |     ^^^^^^^^^^^^^^^^^
24 |     """扫描目录并应用排除与扩展名过滤规则.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `path`
  --> scripts/code/safe_update_code_analysis.py:23:23
   |
21 | # --- ANALYSIS FUNCTIONS ---
22 |
23 | def analyze_directory(path, exclude_dirs, extensions):
   |                       ^^^^
24 |     """扫描目录并应用排除与扩展名过滤规则.
   |

ANN001 Missing type annotation for function argument `exclude_dirs`
  --> scripts/code/safe_update_code_analysis.py:23:29
   |
21 | # --- ANALYSIS FUNCTIONS ---
22 |
23 | def analyze_directory(path, exclude_dirs, extensions):
   |                             ^^^^^^^^^^^^
24 |     """扫描目录并应用排除与扩展名过滤规则.
   |

ANN001 Missing type annotation for function argument `extensions`
  --> scripts/code/safe_update_code_analysis.py:23:43
   |
21 | # --- ANALYSIS FUNCTIONS ---
22 |
23 | def analyze_directory(path, exclude_dirs, extensions):
   |                                           ^^^^^^^^^^
24 |     """扫描目录并应用排除与扩展名过滤规则.
   |

PTH118 `os.path.join()` should be replaced by `Path` with `/` operator
  --> scripts/code/safe_update_code_analysis.py:48:25
   |
46 |                 continue
47 |
48 |             file_path = os.path.join(root, file)
   |                         ^^^^^^^^^^^^
49 |             try:
50 |                 with open(file_path, encoding="utf-8", errors="ignore") as f:
   |

PTH123 `open()` should be replaced by `Path.open()`
  --> scripts/code/safe_update_code_analysis.py:50:22
   |
48 |             file_path = os.path.join(root, file)
49 |             try:
50 |                 with open(file_path, encoding="utf-8", errors="ignore") as f:
   |                      ^^^^
51 |                     line_count = sum(1 for _ in f)
52 |             except OSError:
   |
help: Replace with `Path.open()`

PTH122 `os.path.splitext()` should be replaced by `Path.suffix`, `Path.stem`, and `Path.parent`
  --> scripts/code/safe_update_code_analysis.py:55:19
   |
53 |                 line_count = 0
54 |
55 |             ext = os.path.splitext(file)[1].upper().replace(".", "")
   |                   ^^^^^^^^^^^^^^^^
56 |             if ext == "YML": ext = "YAML"
   |

E701 Multiple statements on one line (colon)
  --> scripts/code/safe_update_code_analysis.py:56:28
   |
55 |             ext = os.path.splitext(file)[1].upper().replace(".", "")
56 |             if ext == "YML": ext = "YAML"
   |                            ^
57 |
58 |             file_stats[ext]["count"] += 1
   |

ANN201 Missing return type annotation for public function `get_directory_breakdown`
  --> scripts/code/safe_update_code_analysis.py:67:5
   |
65 |     return dict(file_stats), detailed_files
66 |
67 | def get_directory_breakdown(detailed_files):
   |     ^^^^^^^^^^^^^^^^^^^^^^^
68 |     """按子目录聚合文件统计数据.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `detailed_files`
  --> scripts/code/safe_update_code_analysis.py:67:29
   |
65 |     return dict(file_stats), detailed_files
66 |
67 | def get_directory_breakdown(detailed_files):
   |                             ^^^^^^^^^^^^^^
68 |     """按子目录聚合文件统计数据.
   |

PTH120 `os.path.dirname()` should be replaced by `Path.parent`
  --> scripts/code/safe_update_code_analysis.py:81:20
   |
79 |     breakdown = defaultdict(lambda: {"count": 0, "lines": 0, "files": []})
80 |     for file_info in detailed_files:
81 |         dir_name = os.path.dirname(file_info["path"])
   |                    ^^^^^^^^^^^^^^^
82 |         dir_name = "app 根目录" if dir_name == "" else f"app/{dir_name}"
   |
help: Replace with `Path(...).parent`

ANN201 Missing return type annotation for public function `generate_file_type_table`
  --> scripts/code/safe_update_code_analysis.py:96:5
   |
94 | # --- MARKDOWN GENERATION ---
95 |
96 | def generate_file_type_table(stats, total_files, total_lines):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
97 |     """生成文件类型分布的 Markdown 表格.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `stats`
  --> scripts/code/safe_update_code_analysis.py:96:30
   |
94 | # --- MARKDOWN GENERATION ---
95 |
96 | def generate_file_type_table(stats, total_files, total_lines):
   |                              ^^^^^
97 |     """生成文件类型分布的 Markdown 表格.
   |

ANN001 Missing type annotation for function argument `total_files`
  --> scripts/code/safe_update_code_analysis.py:96:37
   |
94 | # --- MARKDOWN GENERATION ---
95 |
96 | def generate_file_type_table(stats, total_files, total_lines):
   |                                     ^^^^^^^^^^^
97 |     """生成文件类型分布的 Markdown 表格.
   |

ANN001 Missing type annotation for function argument `total_lines`
  --> scripts/code/safe_update_code_analysis.py:96:50
   |
94 | # --- MARKDOWN GENERATION ---
95 |
96 | def generate_file_type_table(stats, total_files, total_lines):
   |                                                  ^^^^^^^^^^^
97 |     """生成文件类型分布的 Markdown 表格.
   |

ANN201 Missing return type annotation for public function `generate_directory_detail_table`
   --> scripts/code/safe_update_code_analysis.py:118:5
    |
116 |     return "\n".join(table)
117 |
118 | def generate_directory_detail_table(file_list):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
119 |     """生成单个目录的文件明细表格.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `file_list`
   --> scripts/code/safe_update_code_analysis.py:118:37
    |
116 |     return "\n".join(table)
117 |
118 | def generate_directory_detail_table(file_list):
    |                                     ^^^^^^^^^
119 |     """生成单个目录的文件明细表格.
    |

PERF401 Use `list.extend` to create a transformed list
   --> scripts/code/safe_update_code_analysis.py:132:9
    |
130 |         # In a real scenario, you might have a way to get descriptions.
131 |         # For now, we leave it blank.
132 |         table.append(f"| `app/{file_info['path']}` | {file_info['lines']} |          |")
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
133 |     return "\n".join(table)
    |
help: Replace for loop with list.extend

ANN001 Missing type annotation for function argument `report_path`
   --> scripts/code/safe_update_code_analysis.py:137:19
    |
135 | # --- REPORT UPDATE FUNCTION ---
136 |
137 | def update_report(report_path, content) -> None:
    |                   ^^^^^^^^^^^
138 |     """将生成的报告内容写回磁盘.
    |

ANN001 Missing type annotation for function argument `content`
   --> scripts/code/safe_update_code_analysis.py:137:32
    |
135 | # --- REPORT UPDATE FUNCTION ---
136 |
137 | def update_report(report_path, content) -> None:
    |                                ^^^^^^^
138 |     """将生成的报告内容写回磁盘.
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> scripts/code/safe_update_code_analysis.py:149:14
    |
147 |     """
148 |     try:
149 |         with open(report_path, "w", encoding="utf-8") as f:
    |              ^^^^
150 |             f.write(content)
151 |         LOGGER.info("报告已成功更新: %s", report_path)
    |
help: Replace with `Path.open()`

TRY401 Redundant exception object included in `logging.exception` call
   --> scripts/code/safe_update_code_analysis.py:153:66
    |
151 |         LOGGER.info("报告已成功更新: %s", report_path)
152 |     except OSError as e:
153 |         LOGGER.exception("错误:无法写入报告文件 %s.错误信息: %s", report_path, e)
    |                                                                                ^
154 |
155 | def main() -> None:
    |

PTH123 `open()` should be replaced by `Path.open()`
   --> scripts/code/safe_update_code_analysis.py:170:14
    |
168 |     LOGGER.info("正在读取原始报告...")
169 |     try:
170 |         with open(REPORT_PATH, encoding="utf-8") as f:
    |              ^^^^
171 |             original_content = f.read()
172 |     except FileNotFoundError:
    |
help: Replace with `Path.open()`

E501 Line too long (185 > 120)
   --> scripts/code/safe_update_code_analysis.py:177:100
    |
176 | …
177 | …vendor`)\n- **总代码行数**: {total_lines:,}行(.py/.html/.js/.css/.yaml/.yml)"
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
178 | …al_content, flags=re.DOTALL)
    |

E501 Line too long (124 > 120)
   --> scripts/code/safe_update_code_analysis.py:178:112
    |
176 |     # --- Replace Project Overview ---
177 |     overview_section = f"## 项目概览\n- **总文件数**: {total_files}个文件(仅统计代码文件,不包含 `app/static/vendor`)\n- **总代码行数**                         …
178 |     new_content = re.sub(r"## 项目概览\n- \*\*总文件数\*\*:.*?行(.*?)", overview_section, original_content, flags=re.DOTALL)
    |                                                                                                                         ^^^^
179 |
180 |     # --- Replace File Type Distribution Table ---
    |

E501 Line too long (123 > 120)
   --> scripts/code/safe_update_code_analysis.py:183:115
    |
181 |     file_type_table = generate_file_type_table(file_stats, total_files, total_lines)
182 |     dist_header = "### 文件类型分布"
183 |     new_content = re.sub(f"({dist_header}\n)(\\| 文件类型.*?\\|.*?\\|\n(?:\\|---.*?\\|\n)+)(?:\\| \\*\\*总计\\*\\*.*?\\|)",
    |                                                                                                                         ^^^
184 |                          f"\1{file_type_table}", new_content, flags=re.DOTALL)
    |

E501 Line too long (122 > 120)
   --> scripts/code/safe_update_code_analysis.py:202:118
    |
201 |         # Manually order some key directories first
202 |         order = ["app 根目录", "app/routes", "app/models", "app/services", "app/utils", "app/static/js", "app/static/css"]
    |                                                                                                                         ^^
203 |         sorted_dir_keys = [d for d in order if d in dir_breakdown] + [d for d in sorted(dir_breakdown.keys()) if d not in order]
    |

E501 Line too long (128 > 120)
   --> scripts/code/safe_update_code_analysis.py:203:121
    |
201 |         # Manually order some key directories first
202 |         order = ["app 根目录", "app/routes", "app/models", "app/services", "app/utils", "app/static/js", "app/static/css"]
203 |         sorted_dir_keys = [d for d in order if d in dir_breakdown] + [d for d in sorted(dir_breakdown.keys()) if d not in order]
    |                                                                                                                         ^^^^^^^^
204 |
205 |         for i, dir_name in enumerate(sorted_dir_keys, 1):
    |

DTZ005 `datetime.datetime.now()` called without a `tz` argument
   --> scripts/code/safe_update_code_analysis.py:224:36
    |
223 |         # Add a timestamp before the final appendix
224 |         timestamp = f"\n*报告最后更新于: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*\n"
    |                                           ^^^^^^^^^^^^^^
225 |         final_content = final_content.replace("## 附录", f"{timestamp}\n## 附录")
    |
help: Pass a `datetime.timezone` object to the `tz` parameter

EXE001 Shebang is present but file is not executable
 --> scripts/crud_smoke.py:1:1
  |
1 | #!/usr/bin/env python3
  | ^^^^^^^^^^^^^^^^^^^^^^
2 | """CRUD 场景烟雾测试脚本.
  |

TRY004 Prefer `TypeError` exception for invalid type
  --> scripts/crud_smoke.py:81:9
   |
79 |     if not isinstance(scenarios, list):
80 |         msg = "'scenarios' 必须是列表"
81 |         raise ValueError(msg)
   |         ^^^^^^^^^^^^^^^^^^^^^
82 |     return [s for s in scenarios if isinstance(s, Mapping)]
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
  --> scripts/crud_smoke.py:85:28
   |
85 | def render_template(value: Any, context: Mapping[str, Any]) -> Any:
   |                            ^^^
86 |     """递归替换模板占位符."""
87 |     if isinstance(value, str) and "{{" in value and "}}" in value:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `render_template`
  --> scripts/crud_smoke.py:85:64
   |
85 | def render_template(value: Any, context: Mapping[str, Any]) -> Any:
   |                                                                ^^^
86 |     """递归替换模板占位符."""
87 |     if isinstance(value, str) and "{{" in value and "}}" in value:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `payload`
   --> scripts/crud_smoke.py:107:28
    |
107 | def extract_value(payload: Any, path: str) -> Any:
    |                            ^^^
108 |     """通过简单路径语法从 JSON 结构中提取值."""
109 |     if not path:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `extract_value`
   --> scripts/crud_smoke.py:107:47
    |
107 | def extract_value(payload: Any, path: str) -> Any:
    |                                               ^^^
108 |     """通过简单路径语法从 JSON 结构中提取值."""
109 |     if not path:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `current`
   --> scripts/crud_smoke.py:119:26
    |
119 | def _walk_token(current: Any, token: str) -> Any:
    |                          ^^^
120 |     """处理 `foo[0]` 这类 token."""
121 |     while token:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_walk_token`
   --> scripts/crud_smoke.py:119:46
    |
119 | def _walk_token(current: Any, token: str) -> Any:
    |                                              ^^^
120 |     """处理 `foo[0]` 这类 token."""
121 |     while token:
    |

PLR0913 Too many arguments in function definition (10 > 5)
   --> scripts/crud_smoke.py:140:9
    |
138 |     """根据配置执行 CRUD 场景的执行器."""
139 |
140 |     def __init__(
    |         ^^^^^^^^
141 |         self,
142 |         *,
    |

D107 Missing docstring in `__init__`
   --> scripts/crud_smoke.py:140:9
    |
138 |     """根据配置执行 CRUD 场景的执行器."""
139 |
140 |     def __init__(
    |         ^^^^^^^^
141 |         self,
142 |         *,
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> scripts/crud_smoke.py:295:55
    |
293 |                 ),
294 |             )
295 |             LOGGER.exception("  ❌ %s: %s", step_name, exc)
    |                                                        ^^^
296 |
297 |     # ------------------------------------------------------------------
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> scripts/crud_smoke.py:313:9
    |
311 |         return token
312 |
313 |     def _ensure_success_response(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
314 |         self,
315 |         response: requests.Response,
    |

ARG002 Unused method argument: `step_name`
   --> scripts/crud_smoke.py:318:9
    |
316 |         *,
317 |         expected_status: int,
318 |         step_name: str,
    |         ^^^^^^^^^
319 |         expect_json: Mapping[str, Any] | None = None,
320 |         store: Mapping[str, str] | None = None,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_safe_json`
   --> scripts/crud_smoke.py:349:58
    |
347 |                 context[str(alias)] = extract_value(payload, str(raw_path))
348 |
349 |     def _safe_json(self, response: requests.Response) -> Any:
    |                                                          ^^^
350 |         """解析 JSON,失败时抛出详细异常."""
351 |         try:
    |

PLC0415 `import` should be at the top-level of a file
   --> scripts/crud_smoke.py:359:9
    |
357 |     def _build_base_context(self, scenario: Mapping[str, Any]) -> MutableMapping[str, Any]:
358 |         """构建每个场景的基础上下文."""
359 |         from datetime import datetime
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
360 |         from uuid import uuid4
    |

PLC0415 `import` should be at the top-level of a file
   --> scripts/crud_smoke.py:360:9
    |
358 |         """构建每个场景的基础上下文."""
359 |         from datetime import datetime
360 |         from uuid import uuid4
    |         ^^^^^^^^^^^^^^^^^^^^^^
361 |
362 |         ctx: MutableMapping[str, Any] = {
    |

DTZ003 `datetime.datetime.utcnow()` used
   --> scripts/crud_smoke.py:365:26
    |
363 |             "uuid": uuid4().hex,
364 |             "rand_suffix": uuid4().hex[:8],
365 |             "timestamp": datetime.utcnow().isoformat(),
    |                          ^^^^^^^^^^^^^^^^^
366 |         }
367 |         extra_vars = scenario.get("variables")
    |
help: Use `datetime.datetime.now(tz=...)` instead

TRY401 Redundant exception object included in `logging.exception` call
   --> scripts/crud_smoke.py:428:34
    |
426 |         runner.run()
427 |     except CrudScenarioError as exc:
428 |         LOGGER.exception("❌ %s", exc)
    |                                   ^^^
429 |     except Exception as exc:
430 |         LOGGER.exception("❌ 执行过程中出现异常: %s", exc)
    |

TRY401 Redundant exception object included in `logging.exception` call
   --> scripts/crud_smoke.py:430:45
    |
428 |         LOGGER.exception("❌ %s", exc)
429 |     except Exception as exc:
430 |         LOGGER.exception("❌ 执行过程中出现异常: %s", exc)
    |                                                       ^^^
431 |
432 |     failed = [result for result in runner.results if not result.success]
    |

D205 1 blank line required between summary line and description
 --> scripts/password/reset_admin_password.py:2:1
  |
1 |   #!/usr/bin/env python3
2 | / """重置管理员密码的脚本
3 | | 可以生成新的随机密码或设置指定密码.
4 | | """
  | |___^
5 |
6 |   import argparse
  |
help: Insert single blank line

ANN201 Missing return type annotation for public function `generate_random_password`
  --> scripts/password/reset_admin_password.py:21:5
   |
21 | def generate_random_password(length=12):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^
22 |     """生成满足复杂度要求的随机密码.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `length`
  --> scripts/password/reset_admin_password.py:21:30
   |
21 | def generate_random_password(length=12):
   |                              ^^^^^^
22 |     """生成满足复杂度要求的随机密码.
   |

ANN001 Missing type annotation for function argument `new_password`
  --> scripts/password/reset_admin_password.py:34:26
   |
32 |     return "".join(secrets.choice(alphabet) for _ in range(length))
33 |
34 | def reset_admin_password(new_password=None) -> None:
   |                          ^^^^^^^^^^^^
35 |     """重置管理员账户密码.
   |

EXE001 Shebang is present but file is not executable
 --> scripts/password/show_admin_password.py:1:1
  |
1 | #!/usr/bin/env python3
  | ^^^^^^^^^^^^^^^^^^^^^^
2 | """展示默认管理员凭据的辅助脚本."""
  |

INP001 File `tests/conftest.py` is part of an implicit namespace package. Add an `__init__.py`.
--> tests/conftest.py:1:1

D100 Missing docstring in public module
--> tests/conftest.py:1:1

INP001 File `tests/unit/services/test_aggregation_service_periods.py` is part of an implicit namespace package. Add an `__init__.py`.
--> tests/unit/services/test_aggregation_service_periods.py:1:1

ANN202 Missing return type annotation for private function `aggregate_period`
  --> tests/unit/services/test_aggregation_service_periods.py:20:9
   |
18 |         self.calls: list[tuple[str, date, date]] = []
19 |
20 |     def aggregate_period(self, period_type, start_date, end_date, **_):
   |         ^^^^^^^^^^^^^^^^
21 |         self.calls.append((period_type, start_date, end_date))
22 |         return {
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `period_type`
  --> tests/unit/services/test_aggregation_service_periods.py:20:32
   |
18 |         self.calls: list[tuple[str, date, date]] = []
19 |
20 |     def aggregate_period(self, period_type, start_date, end_date, **_):
   |                                ^^^^^^^^^^^
21 |         self.calls.append((period_type, start_date, end_date))
22 |         return {
   |

ANN001 Missing type annotation for function argument `start_date`
  --> tests/unit/services/test_aggregation_service_periods.py:20:45
   |
18 |         self.calls: list[tuple[str, date, date]] = []
19 |
20 |     def aggregate_period(self, period_type, start_date, end_date, **_):
   |                                             ^^^^^^^^^^
21 |         self.calls.append((period_type, start_date, end_date))
22 |         return {
   |

ANN001 Missing type annotation for function argument `end_date`
  --> tests/unit/services/test_aggregation_service_periods.py:20:57
   |
18 |         self.calls: list[tuple[str, date, date]] = []
19 |
20 |     def aggregate_period(self, period_type, start_date, end_date, **_):
   |                                                         ^^^^^^^^
21 |         self.calls.append((period_type, start_date, end_date))
22 |         return {
   |

ANN003 Missing type annotation for `**_`
  --> tests/unit/services/test_aggregation_service_periods.py:20:67
   |
18 |         self.calls: list[tuple[str, date, date]] = []
19 |
20 |     def aggregate_period(self, period_type, start_date, end_date, **_):
   |                                                                   ^^^
21 |         self.calls.append((period_type, start_date, end_date))
22 |         return {
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_aggregation_service_periods.py:29:57
   |
28 | @pytest.mark.unit
29 | def test_aggregate_database_periods_uses_previous_daily(monkeypatch) -> None:
   |                                                         ^^^^^^^^^^^
30 |     """验证覆盖配置后,日聚合会使用上一日窗口."""
31 |     calc = PeriodCalculator(now_func=lambda: date(2025, 12, 1))
   |

ARG001 Unused function argument: `monkeypatch`
  --> tests/unit/services/test_aggregation_service_periods.py:29:57
   |
28 | @pytest.mark.unit
29 | def test_aggregate_database_periods_uses_previous_daily(monkeypatch) -> None:
   |                                                         ^^^^^^^^^^^
30 |     """验证覆盖配置后,日聚合会使用上一日窗口."""
31 |     calc = PeriodCalculator(now_func=lambda: date(2025, 12, 1))
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_aggregation_service_periods.py:49:47
   |
48 | @pytest.mark.unit
49 | def test_instance_aggregations_daily_override(monkeypatch) -> None:
   |                                               ^^^^^^^^^^^
50 |     """calculate_instance_aggregations 接收覆盖配置后会向下游透传."""
51 |     calc = PeriodCalculator(now_func=lambda: date(2025, 12, 1))
   |

ANN202 Missing return type annotation for private function `get`
  --> tests/unit/services/test_aggregation_service_periods.py:57:13
   |
56 |     class _Query:
57 |         def get(self, _instance_id):
   |             ^^^
58 |             return stub_instance
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `_instance_id`
  --> tests/unit/services/test_aggregation_service_periods.py:57:23
   |
56 |     class _Query:
57 |         def get(self, _instance_id):
   |                       ^^^^^^^^^^^^
58 |             return stub_instance
   |

ANN202 Missing return type annotation for private function `_fake_daily`
  --> tests/unit/services/test_aggregation_service_periods.py:64:9
   |
62 |     captured = {}
63 |
64 |     def _fake_daily(self, instance_id, *, use_current_period=True):
   |         ^^^^^^^^^^^
65 |         captured["instance_id"] = instance_id
66 |         captured["use_current_period"] = use_current_period
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `self`
  --> tests/unit/services/test_aggregation_service_periods.py:64:21
   |
62 |     captured = {}
63 |
64 |     def _fake_daily(self, instance_id, *, use_current_period=True):
   |                     ^^^^
65 |         captured["instance_id"] = instance_id
66 |         captured["use_current_period"] = use_current_period
   |

ARG001 Unused function argument: `self`
  --> tests/unit/services/test_aggregation_service_periods.py:64:21
   |
62 |     captured = {}
63 |
64 |     def _fake_daily(self, instance_id, *, use_current_period=True):
   |                     ^^^^
65 |         captured["instance_id"] = instance_id
66 |         captured["use_current_period"] = use_current_period
   |

ANN001 Missing type annotation for function argument `instance_id`
  --> tests/unit/services/test_aggregation_service_periods.py:64:27
   |
62 |     captured = {}
63 |
64 |     def _fake_daily(self, instance_id, *, use_current_period=True):
   |                           ^^^^^^^^^^^
65 |         captured["instance_id"] = instance_id
66 |         captured["use_current_period"] = use_current_period
   |

ANN001 Missing type annotation for function argument `use_current_period`
  --> tests/unit/services/test_aggregation_service_periods.py:64:43
   |
62 |     captured = {}
63 |
64 |     def _fake_daily(self, instance_id, *, use_current_period=True):
   |                                           ^^^^^^^^^^^^^^^^^^
65 |         captured["instance_id"] = instance_id
66 |         captured["use_current_period"] = use_current_period
   |

INP001 File `tests/unit/services/test_classification_form_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> tests/unit/services/test_classification_form_service.py:1:1

D100 Missing docstring in public module
--> tests/unit/services/test_classification_form_service.py:1:1

D103 Missing docstring in public function
  --> tests/unit/services/test_classification_form_service.py:11:5
   |
10 | @pytest.mark.unit
11 | def test_validate_flags_duplicate_name(monkeypatch) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |     service = ClassificationFormService()
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_classification_form_service.py:11:40
   |
10 | @pytest.mark.unit
11 | def test_validate_flags_duplicate_name(monkeypatch) -> None:
   |                                        ^^^^^^^^^^^
12 |     service = ClassificationFormService()
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_classification_form_service.py:17:16
   |
15 |         ClassificationFormService,
16 |         "_name_exists",
17 |         lambda self, name, resource: True,
   |                ^^^^
18 |         raising=False,
19 |     )
   |

ARG005 Unused lambda argument: `name`
  --> tests/unit/services/test_classification_form_service.py:17:22
   |
15 |         ClassificationFormService,
16 |         "_name_exists",
17 |         lambda self, name, resource: True,
   |                      ^^^^
18 |         raising=False,
19 |     )
   |

ARG005 Unused lambda argument: `resource`
  --> tests/unit/services/test_classification_form_service.py:17:28
   |
15 |         ClassificationFormService,
16 |         "_name_exists",
17 |         lambda self, name, resource: True,
   |                            ^^^^^^^^
18 |         raising=False,
19 |     )
   |

D103 Missing docstring in public function
  --> tests/unit/services/test_classification_form_service.py:38:5
   |
37 | @pytest.mark.unit
38 | def test_validate_sets_is_create_flag(monkeypatch) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
39 |     service = ClassificationFormService()
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_classification_form_service.py:38:39
   |
37 | @pytest.mark.unit
38 | def test_validate_sets_is_create_flag(monkeypatch) -> None:
   |                                       ^^^^^^^^^^^
39 |     service = ClassificationFormService()
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_classification_form_service.py:44:16
   |
42 |         ClassificationFormService,
43 |         "_name_exists",
44 |         lambda self, name, resource: False,
   |                ^^^^
45 |         raising=False,
46 |     )
   |

ARG005 Unused lambda argument: `name`
  --> tests/unit/services/test_classification_form_service.py:44:22
   |
42 |         ClassificationFormService,
43 |         "_name_exists",
44 |         lambda self, name, resource: False,
   |                      ^^^^
45 |         raising=False,
46 |     )
   |

ARG005 Unused lambda argument: `resource`
  --> tests/unit/services/test_classification_form_service.py:44:28
   |
42 |         ClassificationFormService,
43 |         "_name_exists",
44 |         lambda self, name, resource: False,
   |                            ^^^^^^^^
45 |         raising=False,
46 |     )
   |

INP001 File `tests/unit/services/test_classification_rule_form_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> tests/unit/services/test_classification_rule_form_service.py:1:1

D100 Missing docstring in public module
--> tests/unit/services/test_classification_rule_form_service.py:1:1

D103 Missing docstring in public function
  --> tests/unit/services/test_classification_rule_form_service.py:12:5
   |
11 | @pytest.mark.unit
12 | def test_validate_uses_dynamic_db_types(monkeypatch) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |     service = ClassificationRuleFormService()
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_classification_rule_form_service.py:12:41
   |
11 | @pytest.mark.unit
12 | def test_validate_uses_dynamic_db_types(monkeypatch) -> None:
   |                                         ^^^^^^^^^^^
13 |     service = ClassificationRuleFormService()
   |

PLC0415 `import` should be at the top-level of a file
  --> tests/unit/services/test_classification_rule_form_service.py:15:5
   |
13 |     service = ClassificationRuleFormService()
14 |
15 |     from app.services import database_type_service
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
16 |
17 |     monkeypatch.setattr(
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_classification_rule_form_service.py:34:16
   |
32 |         ClassificationRuleFormService,
33 |         "_get_classification_by_id",
34 |         lambda self, _: SimpleNamespace(id=1),
   |                ^^^^
35 |         raising=False,
36 |     )
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_classification_rule_form_service.py:41:16
   |
39 |         ClassificationRuleFormService,
40 |         "_rule_name_exists",
41 |         lambda self, data, resource: False,
   |                ^^^^
42 |         raising=False,
43 |     )
   |

ARG005 Unused lambda argument: `data`
  --> tests/unit/services/test_classification_rule_form_service.py:41:22
   |
39 |         ClassificationRuleFormService,
40 |         "_rule_name_exists",
41 |         lambda self, data, resource: False,
   |                      ^^^^
42 |         raising=False,
43 |     )
   |

ARG005 Unused lambda argument: `resource`
  --> tests/unit/services/test_classification_rule_form_service.py:41:28
   |
39 |         ClassificationRuleFormService,
40 |         "_rule_name_exists",
41 |         lambda self, data, resource: False,
   |                            ^^^^^^^^
42 |         raising=False,
43 |     )
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_classification_rule_form_service.py:47:16
   |
45 |         ClassificationRuleFormService,
46 |         "_expression_exists",
47 |         lambda self, expr, classification_id, resource: False,
   |                ^^^^
48 |         raising=False,
49 |     )
   |

ARG005 Unused lambda argument: `expr`
  --> tests/unit/services/test_classification_rule_form_service.py:47:22
   |
45 |         ClassificationRuleFormService,
46 |         "_expression_exists",
47 |         lambda self, expr, classification_id, resource: False,
   |                      ^^^^
48 |         raising=False,
49 |     )
   |

ARG005 Unused lambda argument: `classification_id`
  --> tests/unit/services/test_classification_rule_form_service.py:47:28
   |
45 |         ClassificationRuleFormService,
46 |         "_expression_exists",
47 |         lambda self, expr, classification_id, resource: False,
   |                            ^^^^^^^^^^^^^^^^^
48 |         raising=False,
49 |     )
   |

ARG005 Unused lambda argument: `resource`
  --> tests/unit/services/test_classification_rule_form_service.py:47:47
   |
45 |         ClassificationRuleFormService,
46 |         "_expression_exists",
47 |         lambda self, expr, classification_id, resource: False,
   |                                               ^^^^^^^^
48 |         raising=False,
49 |     )
   |

D103 Missing docstring in public function
  --> tests/unit/services/test_classification_rule_form_service.py:57:5
   |
56 | @pytest.mark.unit
57 | def test_validate_blocks_duplicate_rules(monkeypatch) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
58 |     service = ClassificationRuleFormService()
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_classification_rule_form_service.py:57:42
   |
56 | @pytest.mark.unit
57 | def test_validate_blocks_duplicate_rules(monkeypatch) -> None:
   |                                          ^^^^^^^^^^^
58 |     service = ClassificationRuleFormService()
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_classification_rule_form_service.py:63:16
   |
61 |         ClassificationRuleFormService,
62 |         "_get_classification_by_id",
63 |         lambda self, _: SimpleNamespace(id=1),
   |                ^^^^
64 |         raising=False,
65 |     )
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_classification_rule_form_service.py:69:16
   |
67 |         ClassificationRuleFormService,
68 |         "_get_db_type_options",
69 |         lambda self: [{"value": "mysql"}],
   |                ^^^^
70 |         raising=False,
71 |     )
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_classification_rule_form_service.py:75:16
   |
73 |         ClassificationRuleFormService,
74 |         "_rule_name_exists",
75 |         lambda self, data, resource: True,
   |                ^^^^
76 |         raising=False,
77 |     )
   |

ARG005 Unused lambda argument: `data`
  --> tests/unit/services/test_classification_rule_form_service.py:75:22
   |
73 |         ClassificationRuleFormService,
74 |         "_rule_name_exists",
75 |         lambda self, data, resource: True,
   |                      ^^^^
76 |         raising=False,
77 |     )
   |

ARG005 Unused lambda argument: `resource`
  --> tests/unit/services/test_classification_rule_form_service.py:75:28
   |
73 |         ClassificationRuleFormService,
74 |         "_rule_name_exists",
75 |         lambda self, data, resource: True,
   |                            ^^^^^^^^
76 |         raising=False,
77 |     )
   |

INP001 File `tests/unit/services/test_database_ledger_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> tests/unit/services/test_database_ledger_service.py:1:1

D100 Missing docstring in public module
--> tests/unit/services/test_database_ledger_service.py:1:1

D103 Missing docstring in public function
  --> tests/unit/services/test_database_ledger_service.py:14:5
   |
13 | @pytest.mark.unit
14 | def test_format_size_handles_megabytes() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
15 |     service = DatabaseLedgerService(session=object())
16 |     assert service._format_size(None) == "未采集"
   |

SLF001 Private member accessed: `_format_size`
  --> tests/unit/services/test_database_ledger_service.py:16:12
   |
14 | def test_format_size_handles_megabytes() -> None:
15 |     service = DatabaseLedgerService(session=object())
16 |     assert service._format_size(None) == "未采集"
   |            ^^^^^^^^^^^^^^^^^^^^
17 |     assert service._format_size(512) == "512 MB"
18 |     assert service._format_size(2048) == "2.00 GB"
   |

SLF001 Private member accessed: `_format_size`
  --> tests/unit/services/test_database_ledger_service.py:17:12
   |
15 |     service = DatabaseLedgerService(session=object())
16 |     assert service._format_size(None) == "未采集"
17 |     assert service._format_size(512) == "512 MB"
   |            ^^^^^^^^^^^^^^^^^^^^
18 |     assert service._format_size(2048) == "2.00 GB"
   |

SLF001 Private member accessed: `_format_size`
  --> tests/unit/services/test_database_ledger_service.py:18:12
   |
16 |     assert service._format_size(None) == "未采集"
17 |     assert service._format_size(512) == "512 MB"
18 |     assert service._format_size(2048) == "2.00 GB"
   |            ^^^^^^^^^^^^^^^^^^^^
   |

D103 Missing docstring in public function
  --> tests/unit/services/test_database_ledger_service.py:22:5
   |
21 | @pytest.mark.unit
22 | def test_resolve_sync_status_recent(monkeypatch) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
23 |     service = DatabaseLedgerService(session=object())
24 |     now = datetime.datetime(2025, 11, 27, 12, 0, tzinfo=datetime.UTC)
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_database_ledger_service.py:22:37
   |
21 | @pytest.mark.unit
22 | def test_resolve_sync_status_recent(monkeypatch) -> None:
   |                                     ^^^^^^^^^^^
23 |     service = DatabaseLedgerService(session=object())
24 |     now = datetime.datetime(2025, 11, 27, 12, 0, tzinfo=datetime.UTC)
   |

SLF001 Private member accessed: `_resolve_sync_status`
  --> tests/unit/services/test_database_ledger_service.py:26:14
   |
24 |     now = datetime.datetime(2025, 11, 27, 12, 0, tzinfo=datetime.UTC)
25 |     monkeypatch.setattr("app.services.ledgers.database_ledger_service.time_utils.now", lambda: now)
26 |     status = service._resolve_sync_status(now - datetime.timedelta(hours=2))
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
27 |     assert status["value"] == SyncStatus.COMPLETED
   |

D103 Missing docstring in public function
  --> tests/unit/services/test_database_ledger_service.py:31:5
   |
30 | @pytest.mark.unit
31 | def test_resolve_sync_status_timeout(monkeypatch) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 |     service = DatabaseLedgerService(session=object())
33 |     now = datetime.datetime(2025, 11, 27, 12, 0, tzinfo=datetime.UTC)
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_database_ledger_service.py:31:38
   |
30 | @pytest.mark.unit
31 | def test_resolve_sync_status_timeout(monkeypatch) -> None:
   |                                      ^^^^^^^^^^^
32 |     service = DatabaseLedgerService(session=object())
33 |     now = datetime.datetime(2025, 11, 27, 12, 0, tzinfo=datetime.UTC)
   |

SLF001 Private member accessed: `_resolve_sync_status`
  --> tests/unit/services/test_database_ledger_service.py:35:14
   |
33 |     now = datetime.datetime(2025, 11, 27, 12, 0, tzinfo=datetime.UTC)
34 |     monkeypatch.setattr("app.services.ledgers.database_ledger_service.time_utils.now", lambda: now)
35 |     status = service._resolve_sync_status(now - datetime.timedelta(days=3))
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 |     assert status["value"] == SyncStatus.FAILED
   |

INP001 File `tests/unit/services/test_user_form_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> tests/unit/services/test_user_form_service.py:1:1

D100 Missing docstring in public module
--> tests/unit/services/test_user_form_service.py:1:1

ANN202 Missing return type annotation for private function `filter`
  --> tests/unit/services/test_user_form_service.py:13:9
   |
12 | class _DummyQuery:
13 |     def filter(self, *args, **kwargs):
   |         ^^^^^^
14 |         return self
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> tests/unit/services/test_user_form_service.py:13:22
   |
12 | class _DummyQuery:
13 |     def filter(self, *args, **kwargs):
   |                      ^^^^^
14 |         return self
   |

ARG002 Unused method argument: `args`
  --> tests/unit/services/test_user_form_service.py:13:23
   |
12 | class _DummyQuery:
13 |     def filter(self, *args, **kwargs):
   |                       ^^^^
14 |         return self
   |

ANN003 Missing type annotation for `**kwargs`
  --> tests/unit/services/test_user_form_service.py:13:29
   |
12 | class _DummyQuery:
13 |     def filter(self, *args, **kwargs):
   |                             ^^^^^^^^
14 |         return self
   |

ARG002 Unused method argument: `kwargs`
  --> tests/unit/services/test_user_form_service.py:13:31
   |
12 | class _DummyQuery:
13 |     def filter(self, *args, **kwargs):
   |                               ^^^^^^
14 |         return self
   |

ANN202 Missing return type annotation for private function `filter_by`
  --> tests/unit/services/test_user_form_service.py:16:9
   |
14 |         return self
15 |
16 |     def filter_by(self, *args, **kwargs):
   |         ^^^^^^^^^
17 |         return self
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> tests/unit/services/test_user_form_service.py:16:25
   |
14 |         return self
15 |
16 |     def filter_by(self, *args, **kwargs):
   |                         ^^^^^
17 |         return self
   |

ARG002 Unused method argument: `args`
  --> tests/unit/services/test_user_form_service.py:16:26
   |
14 |         return self
15 |
16 |     def filter_by(self, *args, **kwargs):
   |                          ^^^^
17 |         return self
   |

ANN003 Missing type annotation for `**kwargs`
  --> tests/unit/services/test_user_form_service.py:16:32
   |
14 |         return self
15 |
16 |     def filter_by(self, *args, **kwargs):
   |                                ^^^^^^^^
17 |         return self
   |

ARG002 Unused method argument: `kwargs`
  --> tests/unit/services/test_user_form_service.py:16:34
   |
14 |         return self
15 |
16 |     def filter_by(self, *args, **kwargs):
   |                                  ^^^^^^
17 |         return self
   |

D103 Missing docstring in public function
  --> tests/unit/services/test_user_form_service.py:24:5
   |
23 | @pytest.mark.unit
24 | def test_validate_prevents_disabling_last_admin(monkeypatch) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |     service = UserFormService()
26 |     admin = User(username="root", role=UserRole.ADMIN)
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_user_form_service.py:24:49
   |
23 | @pytest.mark.unit
24 | def test_validate_prevents_disabling_last_admin(monkeypatch) -> None:
   |                                                 ^^^^^^^^^^^
25 |     service = UserFormService()
26 |     admin = User(username="root", role=UserRole.ADMIN)
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_user_form_service.py:30:64
   |
28 |     admin.is_active = True
29 |
30 |     monkeypatch.setattr(UserFormService, "_user_query", lambda self: _DummyQuery(), raising=False)
   |                                                                ^^^^
31 |     monkeypatch.setattr(
32 |         User,
   |

ARG005 Unused lambda argument: `cls`
  --> tests/unit/services/test_user_form_service.py:34:28
   |
32 |         User,
33 |         "active_admin_count",
34 |         classmethod(lambda cls, *, exclude_user_id=None: 0),
   |                            ^^^
35 |     )
   |

ARG005 Unused lambda argument: `exclude_user_id`
  --> tests/unit/services/test_user_form_service.py:34:36
   |
32 |         User,
33 |         "active_admin_count",
34 |         classmethod(lambda cls, *, exclude_user_id=None: 0),
   |                                    ^^^^^^^^^^^^^^^
35 |     )
   |

D103 Missing docstring in public function
  --> tests/unit/services/test_user_form_service.py:51:5
   |
50 | @pytest.mark.unit
51 | def test_validate_allows_change_when_other_admin_exists(monkeypatch) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
52 |     service = UserFormService()
53 |     admin = User(username="root", role=UserRole.ADMIN)
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/services/test_user_form_service.py:51:57
   |
50 | @pytest.mark.unit
51 | def test_validate_allows_change_when_other_admin_exists(monkeypatch) -> None:
   |                                                         ^^^^^^^^^^^
52 |     service = UserFormService()
53 |     admin = User(username="root", role=UserRole.ADMIN)
   |

ARG005 Unused lambda argument: `self`
  --> tests/unit/services/test_user_form_service.py:57:64
   |
55 |     admin.is_active = True
56 |
57 |     monkeypatch.setattr(UserFormService, "_user_query", lambda self: _DummyQuery(), raising=False)
   |                                                                ^^^^
58 |     monkeypatch.setattr(
59 |         User,
   |

ARG005 Unused lambda argument: `cls`
  --> tests/unit/services/test_user_form_service.py:61:28
   |
59 |         User,
60 |         "active_admin_count",
61 |         classmethod(lambda cls, *, exclude_user_id=None: 1),
   |                            ^^^
62 |     )
   |

ARG005 Unused lambda argument: `exclude_user_id`
  --> tests/unit/services/test_user_form_service.py:61:36
   |
59 |         User,
60 |         "active_admin_count",
61 |         classmethod(lambda cls, *, exclude_user_id=None: 1),
   |                                    ^^^^^^^^^^^^^^^
62 |     )
   |

INP001 File `tests/unit/utils/test_data_validator.py` is part of an implicit namespace package. Add an `__init__.py`.
--> tests/unit/utils/test_data_validator.py:1:1

D100 Missing docstring in public module
--> tests/unit/utils/test_data_validator.py:1:1

D103 Missing docstring in public function
  --> tests/unit/utils/test_data_validator.py:12:5
   |
11 | @pytest.mark.unit
12 | def test_validate_db_type_uses_dynamic_configs(monkeypatch) -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |     from app.services import database_type_service
   |

ANN001 Missing type annotation for function argument `monkeypatch`
  --> tests/unit/utils/test_data_validator.py:12:48
   |
11 | @pytest.mark.unit
12 | def test_validate_db_type_uses_dynamic_configs(monkeypatch) -> None:
   |                                                ^^^^^^^^^^^
13 |     from app.services import database_type_service
   |

PLC0415 `import` should be at the top-level of a file
  --> tests/unit/utils/test_data_validator.py:13:5
   |
11 | @pytest.mark.unit
12 | def test_validate_db_type_uses_dynamic_configs(monkeypatch) -> None:
13 |     from app.services import database_type_service
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
14 |
15 |     monkeypatch.setattr(
   |

D103 Missing docstring in public function
  --> tests/unit/utils/test_data_validator.py:25:5
   |
24 | @pytest.mark.unit
25 | def test_validate_db_type_with_custom_override() -> None:
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 |     DataValidator.set_custom_db_types(["clickhouse"])
27 |     try:
   |

INP001 File `tests/unit/utils/test_sensitive_data.py` is part of an implicit namespace package. Add an `__init__.py`.
--> tests/unit/utils/test_sensitive_data.py:1:1

D202 [*] No blank lines allowed after function docstring (found 1)
  --> tests/unit/utils/test_sensitive_data.py:12:5
   |
10 | @pytest.mark.unit
11 | def test_scrub_sensitive_fields_masks_nested_values() -> None:
12 |     """验证嵌套字段会统一替换为自定义掩码."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
13 |
14 |     payload = {
   |
help: Remove blank line(s) after function docstring

D202 [*] No blank lines allowed after function docstring (found 1)
  --> tests/unit/utils/test_sensitive_data.py:31:5
   |
29 | @pytest.mark.unit
30 | def test_scrub_sensitive_fields_supports_extra_keys() -> None:
31 |     """验证可通过 extra_keys 参数扩展脱敏字段."""
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
32 |
33 |     payload = {"custom": "value", "api_key": "key"}
   |
help: Remove blank line(s) after function docstring

Found 1631 errors.
[*] 6 fixable with the `--fix` option (3 hidden fixes can be enabled with the `--unsafe-fixes` option).
