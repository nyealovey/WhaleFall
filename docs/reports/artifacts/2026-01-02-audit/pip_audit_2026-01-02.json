{"dependencies": [{"name": "alembic", "version": "1.16.5", "vulns": []}, {"name": "aniso8601", "version": "10.0.1", "vulns": []}, {"name": "apscheduler", "version": "3.11.0", "vulns": []}, {"name": "attrs", "version": "25.4.0", "vulns": []}, {"name": "bandit", "version": "1.8.6", "vulns": []}, {"name": "bcrypt", "version": "4.3.0", "vulns": []}, {"name": "black", "version": "25.9.0", "vulns": []}, {"name": "bleach", "version": "6.2.0", "vulns": []}, {"name": "blinker", "version": "1.9.0", "vulns": []}, {"name": "cachelib", "version": "0.13.0", "vulns": []}, {"name": "certifi", "version": "2025.8.3", "vulns": []}, {"name": "cffi", "version": "2.0.0", "vulns": []}, {"name": "cfgv", "version": "3.4.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.3", "vulns": []}, {"name": "click", "version": "8.3.0", "vulns": []}, {"name": "coverage", "version": "7.13.0", "vulns": []}, {"name": "cryptography", "version": "46.0.1", "vulns": []}, {"name": "distlib", "version": "0.4.0", "vulns": []}, {"name": "filelock", "version": "3.19.1", "vulns": [{"id": "CVE-2025-68146", "fix_versions": ["3.20.1"], "aliases": ["GHSA-w853-jp5j-5j7f"], "description": "### Impact  A Time-of-Check-Time-of-Use (TOCTOU) race condition allows local attackers to corrupt or truncate arbitrary user files through symlink attacks. The vulnerability exists in both Unix and Windows lock file creation where filelock checks if a file exists before opening it with O_TRUNC. An attacker can create a symlink pointing to a victim file in the time gap between the check and open, causing os.open() to follow the symlink and truncate the target file.  **Who is impacted:**  All users of filelock on Unix, Linux, macOS, and Windows systems. The vulnerability cascades to dependent libraries:  - **virtualenv users**: Configuration files can be overwritten with virtualenv metadata, leaking sensitive paths - **PyTorch users**: CPU ISA cache or model checkpoints can be corrupted, causing crashes or ML pipeline failures - **poetry/tox users**: through using virtualenv or filelock on their own.  Attack requires local filesystem access and ability to create symlinks (standard user permissions on Unix; Developer Mode on Windows 10+). Exploitation succeeds within 1-3 attempts when lock file paths are predictable.  ### Patches  Fixed in version **3.20.1**.  **Unix/Linux/macOS fix:** Added O_NOFOLLOW flag to os.open() in UnixFileLock.\\_acquire() to prevent symlink following.  **Windows fix:** Added GetFileAttributesW API check to detect reparse points (symlinks/junctions) before opening files in WindowsFileLock.\\_acquire().  **Users should upgrade to filelock 3.20.1 or later immediately.**  ### Workarounds  If immediate upgrade is not possible:  1. Use SoftFileLock instead of UnixFileLock/WindowsFileLock (note: different locking semantics, may not be suitable for all use cases) 2. Ensure lock file directories have restrictive permissions (chmod 0700) to prevent untrusted users from creating symlinks 3. Monitor lock file directories for suspicious symlinks before running trusted applications  **Warning:** These workarounds provide only partial mitigation. The race condition remains exploitable. Upgrading to version 3.20.1 is strongly recommended.  ______________________________________________________________________  ## Technical Details: How the Exploit Works  ### The Vulnerable Code Pattern  **Unix/Linux/macOS** (`src/filelock/_unix.py:39-44`):  ```python def _acquire(self) -> None:     ensure_directory_exists(self.lock_file)     open_flags = os.O_RDWR | os.O_TRUNC  # (1) Prepare to truncate     if not Path(self.lock_file).exists():  # (2) CHECK: Does file exist?         open_flags |= os.O_CREAT     fd = os.open(self.lock_file, open_flags, ...)  # (3) USE: Open and truncate ```  **Windows** (`src/filelock/_windows.py:19-28`):  ```python def _acquire(self) -> None:     raise_on_not_writable_file(self.lock_file)  # (1) Check writability     ensure_directory_exists(self.lock_file)     flags = os.O_RDWR | os.O_CREAT | os.O_TRUNC  # (2) Prepare to truncate     fd = os.open(self.lock_file, flags, ...)  # (3) Open and truncate ```  ### The Race Window  The vulnerability exists in the gap between operations:  **Unix variant:**  ``` Time    Victim Thread                          Attacker Thread ----    -------------                          --------------- T0      Check: lock_file exists? \u2192 False T1                                             \u2193 RACE WINDOW T2                                             Create symlink: lock \u2192 victim_file T3      Open lock_file with O_TRUNC         \u2192 Follows symlink         \u2192 Opens victim_file         \u2192 Truncates victim_file to 0 bytes! \u2620\ufe0f ```  **Windows variant:**  ``` Time    Victim Thread                          Attacker Thread ----    -------------                          --------------- T0      Check: lock_file writable? T1                                             \u2193 RACE WINDOW T2                                             Create symlink: lock \u2192 victim_file T3      Open lock_file with O_TRUNC         \u2192 Follows symlink/junction         \u2192 Opens victim_file         \u2192 Truncates victim_file to 0 bytes! \u2620\ufe0f ```  ### Step-by-Step Attack Flow  **1. Attacker Setup:**  ```python # Attacker identifies target application using filelock lock_path = \"/tmp/myapp.lock\"  # Predictable lock path victim_file = \"/home/victim/.ssh/config\"  # High-value target ```  **2. Attacker Creates Race Condition:**  ```python import os import threading   def attacker_thread():     # Remove any existing lock file     try:         os.unlink(lock_path)     except FileNotFoundError:         pass      # Create symlink pointing to victim file     os.symlink(victim_file, lock_path)     print(f\"[Attacker] Created: {lock_path} \u2192 {victim_file}\")   # Launch attack threading.Thread(target=attacker_thread).start() ```  **3. Victim Application Runs:**  ```python from filelock import UnixFileLock  # Normal application code lock = UnixFileLock(\"/tmp/myapp.lock\") lock.acquire()  # \u2190 VULNERABILITY TRIGGERED HERE # At this point, /home/victim/.ssh/config is now 0 bytes! ```  **4. What Happens Inside os.open():**  On Unix systems, when `os.open()` is called:  ```c // Linux kernel behavior (simplified) int open(const char *pathname, int flags) {     struct file *f = path_lookup(pathname);  // Resolves symlinks by default!      if (flags & O_TRUNC) {         truncate_file(f);  // \u2190 Truncates the TARGET of the symlink     }      return file_descriptor; } ```  Without `O_NOFOLLOW` flag, the kernel follows the symlink and truncates the target file.  ### Why the Attack Succeeds Reliably  **Timing Characteristics:**  - **Check operation** (Path.exists()): ~100-500 nanoseconds - **Symlink creation** (os.symlink()): ~1-10 microseconds - **Race window**: ~1-5 microseconds (very small but exploitable) - **Thread scheduling quantum**: ~1-10 milliseconds  **Success factors:**  1. **Tight loop**: Running attack in a loop hits the race window within 1-3 attempts 2. **CPU scheduling**: Modern OS thread schedulers frequently context-switch during I/O operations 3. **No synchronization**: No atomic file creation prevents the race 4. **Symlink speed**: Creating symlinks is extremely fast (metadata-only operation)  ### Real-World Attack Scenarios  **Scenario 1: virtualenv Exploitation**  ```python # Victim runs: python -m venv /tmp/myenv # Attacker racing to create: os.symlink(\"/home/victim/.bashrc\", \"/tmp/myenv/pyvenv.cfg\")  # Result: /home/victim/.bashrc overwritten with: # home = /usr/bin/python3 # include-system-site-packages = false # version = 3.11.2 # \u2190 Original .bashrc contents LOST + virtualenv metadata LEAKED to attacker ```  **Scenario 2: PyTorch Cache Poisoning**  ```python # Victim runs: import torch # PyTorch checks CPU capabilities, uses filelock on cache # Attacker racing to create: os.symlink(\"/home/victim/.torch/compiled_model.pt\", \"/home/victim/.cache/torch/cpu_isa_check.lock\")  # Result: Trained ML model checkpoint truncated to 0 bytes # Impact: Weeks of training lost, ML pipeline DoS ```  ### Why Standard Defenses Don't Help  **File permissions don't prevent this:**  - Attacker doesn't need write access to victim_file - os.open() with O_TRUNC follows symlinks using the *victim's* permissions - The victim process truncates its own file  **Directory permissions help but aren't always feasible:**  - Lock files often created in shared /tmp directory (mode 1777) - Applications may not control lock file location - Many apps use predictable paths in user-writable directories  **File locking doesn't prevent this:**  - The truncation happens *during* the open() call, before any lock is acquired - fcntl.flock() only prevents concurrent lock acquisition, not symlink attacks  ### Exploitation Proof-of-Concept Results  From empirical testing with the provided PoCs:  **Simple Direct Attack** (`filelock_simple_poc.py`):  - Success rate: 33% per attempt (1 in 3 tries) - Average attempts to success: 2.1 - Target file reduced to 0 bytes in \\<100ms  **virtualenv Attack** (`weaponized_virtualenv.py`):  - Success rate: ~90% on first attempt (deterministic timing) - Information leaked: File paths, Python version, system configuration - Data corruption: Complete loss of original file contents  **PyTorch Attack** (`weaponized_pytorch.py`):  - Success rate: 25-40% per attempt - Impact: Application crashes, model loading failures - Recovery: Requires cache rebuild or model retraining  **Discovered and reported by:** George Tsigourakos (@tsigouris007)"}]}, {"name": "flask", "version": "3.1.2", "vulns": []}, {"name": "flask-bcrypt", "version": "1.0.1", "vulns": []}, {"name": "flask-caching", "version": "2.3.1", "vulns": []}, {"name": "flask-cors", "version": "6.0.1", "vulns": []}, {"name": "flask-jwt-extended", "version": "4.7.1", "vulns": []}, {"name": "flask-login", "version": "0.6.3", "vulns": []}, {"name": "flask-migrate", "version": "4.1.0", "vulns": []}, {"name": "flask-restx", "version": "1.3.2", "vulns": []}, {"name": "flask-sqlalchemy", "version": "3.1.1", "vulns": []}, {"name": "flask-wtf", "version": "1.2.2", "vulns": []}, {"name": "gevent", "version": "25.9.1", "vulns": []}, {"name": "greenlet", "version": "3.2.4", "vulns": []}, {"name": "gunicorn", "version": "23.0.0", "vulns": []}, {"name": "identify", "version": "2.6.14", "vulns": []}, {"name": "idna", "version": "3.10", "vulns": []}, {"name": "importlib-resources", "version": "6.5.2", "vulns": []}, {"name": "iniconfig", "version": "2.3.0", "vulns": []}, {"name": "isort", "version": "6.0.1", "vulns": []}, {"name": "itsdangerous", "version": "2.2.0", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "jsonschema", "version": "4.25.1", "vulns": []}, {"name": "jsonschema-specifications", "version": "2025.9.1", "vulns": []}, {"name": "loguru", "version": "0.7.3", "vulns": []}, {"name": "mako", "version": "1.3.10", "vulns": []}, {"name": "markdown-it-py", "version": "4.0.0", "vulns": []}, {"name": "markupsafe", "version": "3.0.2", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "mypy-extensions", "version": "1.1.0", "vulns": []}, {"name": "nodeenv", "version": "1.9.1", "vulns": []}, {"name": "oracledb", "version": "3.3.0", "vulns": []}, {"name": "packaging", "version": "25.0", "vulns": []}, {"name": "pathspec", "version": "0.12.1", "vulns": []}, {"name": "platformdirs", "version": "4.4.0", "vulns": []}, {"name": "pluggy", "version": "1.6.0", "vulns": []}, {"name": "pre-commit", "version": "4.3.0", "vulns": []}, {"name": "psutil", "version": "7.1.0", "vulns": []}, {"name": "psycopg", "version": "3.2.10", "vulns": []}, {"name": "psycopg-binary", "version": "3.2.10", "vulns": []}, {"name": "psycopg2-binary", "version": "2.9.10", "vulns": []}, {"name": "pycparser", "version": "2.23", "vulns": []}, {"name": "pygments", "version": "2.19.2", "vulns": []}, {"name": "pyjwt", "version": "2.10.1", "vulns": []}, {"name": "pymssql", "version": "2.3.7", "vulns": []}, {"name": "pymysql", "version": "1.1.2", "vulns": []}, {"name": "pyodbc", "version": "5.2.0", "vulns": []}, {"name": "pyright", "version": "1.1.407", "vulns": []}, {"name": "pytest", "version": "9.0.2", "vulns": []}, {"name": "pytest-cov", "version": "7.0.0", "vulns": []}, {"name": "python-dotenv", "version": "1.1.1", "vulns": []}, {"name": "pytokens", "version": "0.1.10", "vulns": []}, {"name": "pytz", "version": "2025.2", "vulns": []}, {"name": "pyyaml", "version": "6.0.2", "vulns": []}, {"name": "redis", "version": "6.4.0", "vulns": []}, {"name": "referencing", "version": "0.37.0", "vulns": []}, {"name": "requests", "version": "2.32.5", "vulns": []}, {"name": "rich", "version": "14.1.0", "vulns": []}, {"name": "rpds-py", "version": "0.30.0", "vulns": []}, {"name": "ruff", "version": "0.14.8", "vulns": []}, {"name": "setuptools", "version": "80.9.0", "vulns": []}, {"name": "sqlalchemy", "version": "2.0.43", "vulns": []}, {"name": "stevedore", "version": "5.5.0", "vulns": []}, {"name": "structlog", "version": "25.4.0", "vulns": []}, {"name": "types-pyyaml", "version": "6.0.12.20250915", "vulns": []}, {"name": "typing-extensions", "version": "4.15.0", "vulns": []}, {"name": "tzdata", "version": "2025.2", "vulns": []}, {"name": "tzlocal", "version": "5.3.1", "vulns": []}, {"name": "urllib3", "version": "2.5.0", "vulns": [{"id": "CVE-2025-66418", "fix_versions": ["2.6.0"], "aliases": ["GHSA-gm62-xv2j-4w53"], "description": "## Impact  urllib3 supports chained HTTP encoding algorithms for response content according to RFC 9110 (e.g., `Content-Encoding: gzip, zstd`).  However, the number of links in the decompression chain was unbounded allowing a malicious server to insert a virtually unlimited number of compression steps leading to high CPU usage and massive memory allocation for the decompressed data.   ## Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier for HTTP requests to untrusted sources unless they disable content decoding explicitly.   ## Remediation  Upgrade to at least urllib3 v2.6.0 in which the library limits the number of links to 5.  If upgrading is not immediately possible, use [`preload_content=False`](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) and ensure that `resp.headers[\"content-encoding\"]` contains a safe number of encodings before reading the response content."}, {"id": "CVE-2025-66471", "fix_versions": ["2.6.0"], "aliases": ["GHSA-2xpw-w6gg-jr37"], "description": "### Impact  urllib3's [streaming API](https://urllib3.readthedocs.io/en/2.5.0/advanced-usage.html#streaming-and-i-o) is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once.  When streaming a compressed response, urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). The library must read compressed data from the network and decompress it until the requested chunk size is met. Any resulting decompressed data that exceeds the requested amount is held in an internal buffer for the next read operation.  The decompression logic could cause urllib3 to fully decode a small amount of highly compressed data in a single operation. This can result in excessive resource consumption (high CPU usage and massive memory allocation for the decompressed data; CWE-409) on the client side, even if the application only requested a small chunk of data.   ### Affected usages  Applications and libraries using urllib3 version 2.5.0 and earlier to stream large compressed responses or content from untrusted sources.  `stream()`, `read(amt=256)`, `read1(amt=256)`, `read_chunked(amt=256)`, `readinto(b)` are examples of `urllib3.HTTPResponse` method calls using the affected logic unless decoding is disabled explicitly.   ### Remediation  Upgrade to at least urllib3 v2.6.0 in which the library avoids decompressing data that exceeds the requested amount.  If your environment contains a package facilitating the Brotli encoding, upgrade to at least Brotli 1.2.0 or brotlicffi 1.2.0.0 too. These versions are enforced by the `urllib3[brotli]` extra in the patched versions of urllib3.   ### Credits  The issue was reported by @Cycloctane. Supplemental information was provided by @stamparm during a security audit performed by [7ASecurity](https://7asecurity.com/) and facilitated by [OSTIF](https://ostif.org/)."}]}, {"name": "virtualenv", "version": "20.34.0", "vulns": []}, {"name": "webencodings", "version": "0.5.1", "vulns": []}, {"name": "werkzeug", "version": "3.1.3", "vulns": [{"id": "CVE-2025-66221", "fix_versions": ["3.1.4"], "aliases": ["GHSA-hgf8-39gv-g3f2"], "description": "Werkzeug's `safe_join` function allows path segments with Windows device names. On Windows, there are special device names such as `CON`, `AUX`, etc that are implicitly present and readable in every directory. `send_from_directory` uses `safe_join` to safely serve files at user-specified paths under a directory. If the application is running on Windows, and the requested path ends with a special device name, the file will be opened successfully, but reading will hang indefinitely."}]}, {"name": "whalefalling", "skip_reason": "Dependency not found on PyPI and could not be audited: whalefalling (1.3.6)"}, {"name": "wtforms", "version": "3.2.1", "vulns": []}, {"name": "zope-event", "version": "6.0", "vulns": []}, {"name": "zope-interface", "version": "8.0", "vulns": []}], "fixes": []}
