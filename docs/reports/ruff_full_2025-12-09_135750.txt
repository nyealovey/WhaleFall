ANN202 Missing return type annotation for private function `handle_global_exception`
   --> app/__init__.py:123:9
    |
121 |     # 注册全局错误处理器
122 |     @app.errorhandler(Exception)
123 |     def handle_global_exception(error: Exception):
    |         ^^^^^^^^^^^^^^^^^^^^^^^
124 |         """全局错误处理."""
125 |         payload, status_code = unified_error_response(error, context=ErrorContext(error, request))
    |
help: Add return type annotation

C901 `configure_app` is too complex (11 > 10)
   --> app/__init__.py:144:5
    |
144 | def configure_app(app: Flask, config_name: str | None = None) -> None:  # noqa: ARG001, PLR0915
    |     ^^^^^^^^^^^^^
145 |     """配置 Flask 应用的核心参数.
    |

E501 Line too long (154 > 120)
   --> app/__init__.py:236:121
    |
234 | …
235 | …
236 | …" or request.is_secure or request.headers.get(HttpHeaders.X_FORWARDED_SSL) == "on":
    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
237 | …
238 | …
    |

ERA001 Found commented-out code
   --> app/__init__.py:361:5
    |
359 |     csrf.init_app(app)
360 |
361 |     # 初始化速率限制器(使用Flask-Caching)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
362 |     init_rate_limiter(cache)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/__init__.py:508:1
    |
508 | # 导入模型(确保模型被注册)
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^
509 | from app.models import (  # noqa: F401, E402
510 |     credential,
    |
help: Remove commented-out code

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/config.py:57:33
   |
55 |           raise ValueError(msg)
56 |       SQLALCHEMY_TRACK_MODIFICATIONS = False
57 |       SQLALCHEMY_ENGINE_OPTIONS = {
   |  _________________________________^
58 | |         "pool_pre_ping": True,
59 | |         "pool_recycle": 300,
60 | |         "pool_timeout": CONNECTION_TIMEOUT,
61 | |         "max_overflow": 10,
62 | |         "pool_size": MAX_CONNECTIONS,
63 | |         "echo": DEBUG,  # 开发环境显示SQL,生产环境不显示
64 | |     }
   | |_____^
65 |
66 |       # Redis缓存配置
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/database_types.py:21:11
   |
20 |     # 所有支持的类型
21 |     ALL = [MYSQL, POSTGRESQL, SQLSERVER, ORACLE, SQLITE]
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 |     # 主流关系型数据库
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/database_types.py:24:18
   |
23 |     # 主流关系型数据库
24 |     RELATIONAL = [MYSQL, POSTGRESQL, SQLSERVER, ORACLE]
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |
26 |     # 显示名称映射
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/database_types.py:27:21
   |
26 |       # 显示名称映射
27 |       DISPLAY_NAMES = {
   |  _____________________^
28 | |         MYSQL: "MySQL",
29 | |         POSTGRESQL: "PostgreSQL",
30 | |         SQLSERVER: "SQL Server",
31 | |         ORACLE: "Oracle Database",
32 | |         SQLITE: "SQLite",
33 | |     }
   | |_____^
34 |
35 |       # 默认端口映射
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/database_types.py:36:21
   |
35 |       # 默认端口映射
36 |       DEFAULT_PORTS = {
   |  _____________________^
37 | |         MYSQL: 3306,
38 | |         POSTGRESQL: 5432,
39 | |         SQLSERVER: 1433,
40 | |         ORACLE: 1521,
41 | |         SQLITE: None,  # SQLite不需要端口
42 | |     }
   | |_____^
43 |
44 |       # 辅助方法
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/flash_categories.py:24:11
   |
23 |     # 所有类别
24 |     ALL = [SUCCESS, ERROR, WARNING, INFO, DANGER, PRIMARY, SECONDARY]
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |
26 |     # Bootstrap对应的CSS类
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/flash_categories.py:27:25
   |
26 |       # Bootstrap对应的CSS类
27 |       BOOTSTRAP_CLASSES = {
   |  _________________________^
28 | |         SUCCESS: "alert-success",
29 | |         ERROR: "alert-danger",
30 | |         WARNING: "alert-warning",
31 | |         INFO: "alert-info",
32 | |         DANGER: "alert-danger",
33 | |         PRIMARY: "alert-primary",
34 | |         SECONDARY: "alert-secondary",
35 | |     }
   | |_____^
36 |
37 |       # 类别对应的图标
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/flash_categories.py:38:13
   |
37 |       # 类别对应的图标
38 |       ICONS = {
   |  _____________^
39 | |         SUCCESS: "check-circle",
40 | |         ERROR: "exclamation-circle",
41 | |         WARNING: "exclamation-triangle",
42 | |         INFO: "info-circle",
43 | |         DANGER: "times-circle",
44 | |         PRIMARY: "star",
45 | |         SECONDARY: "circle",
46 | |     }
   | |_____^
47 |
48 |       # 辅助方法
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:24:11
   |
22 |     CONNECT = "CONNECT"   # 建立隧道连接
23 |
24 |     ALL = [GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS, TRACE, CONNECT]
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
25 |
26 |     SAFE_METHODS = [GET, HEAD, OPTIONS]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:26:20
   |
24 |     ALL = [GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS, TRACE, CONNECT]
25 |
26 |     SAFE_METHODS = [GET, HEAD, OPTIONS]
   |                    ^^^^^^^^^^^^^^^^^^^^
27 |
28 |     IDEMPOTENT_METHODS = [GET, PUT, DELETE, HEAD, OPTIONS]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:28:26
   |
26 |     SAFE_METHODS = [GET, HEAD, OPTIONS]
27 |
28 |     IDEMPOTENT_METHODS = [GET, PUT, DELETE, HEAD, OPTIONS]
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
29 |
30 |     WRITE_METHODS = [POST, PUT, PATCH, DELETE]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:30:21
   |
28 |     IDEMPOTENT_METHODS = [GET, PUT, DELETE, HEAD, OPTIONS]
29 |
30 |     WRITE_METHODS = [POST, PUT, PATCH, DELETE]
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
31 |
32 |     READ_METHODS = [GET, HEAD, OPTIONS]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/http_methods.py:32:20
   |
30 |     WRITE_METHODS = [POST, PUT, PATCH, DELETE]
31 |
32 |     READ_METHODS = [GET, HEAD, OPTIONS]
   |                    ^^^^^^^^^^^^^^^^^^^^
33 |
34 |     # 辅助方法
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:21:11
   |
19 |     PAUSED = "paused"           # 已暂停
20 |
21 |     ALL = [PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, PAUSED]
   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
22 |
23 |     ACTIVE = [PENDING, RUNNING, PAUSED]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:23:14
   |
21 |     ALL = [PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, PAUSED]
22 |
23 |     ACTIVE = [PENDING, RUNNING, PAUSED]
   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^
24 |
25 |     TERMINAL = [COMPLETED, FAILED, CANCELLED]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:25:16
   |
23 |     ACTIVE = [PENDING, RUNNING, PAUSED]
24 |
25 |     TERMINAL = [COMPLETED, FAILED, CANCELLED]
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
26 |
27 |     # 成功状态
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:28:15
   |
27 |     # 成功状态
28 |     SUCCESS = [COMPLETED]
   |               ^^^^^^^^^^^
29 |
30 |     # 失败状态
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/status_types.py:31:13
   |
30 |     # 失败状态
31 |     ERROR = [FAILED, CANCELLED]
   |             ^^^^^^^^^^^^^^^^^^^
32 |
33 |     # 辅助方法
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:103:11
    |
102 |     # 所有状态
103 |     ALL = [SUCCESS, ERROR, WARNING, INFO, PENDING, RUNNING]
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
104 |
105 |     # 完成状态
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:106:17
    |
105 |     # 完成状态
106 |     COMPLETED = [SUCCESS, ERROR, WARNING]
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^
107 |
108 |     # 进行中状态
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:109:19
    |
108 |     # 进行中状态
109 |     IN_PROGRESS = [PENDING, RUNNING]
    |                   ^^^^^^^^^^^^^^^^^^
110 |
111 |     # 辅助方法
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:153:11
    |
152 |     # 所有状态
153 |     ALL = [ACTIVE, INACTIVE, MAINTENANCE, ERROR]
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
154 |
155 |     # 辅助方法
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
   --> app/constants/status_types.py:184:11
    |
183 |     # 所有状态
184 |     ALL = [SCHEDULED, RUNNING, PAUSED, STOPPED]
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |

D205 1 blank line required between summary line and description
 --> app/constants/sync_constants.py:1:1
  |
1 | / """鲸落 - 同步相关常量定义
2 | | 统一管理同步操作方式和同步分类的常量.
3 | | """
  | |___^
4 |
5 |   from enum import Enum
  |
help: Insert single blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:31:30
   |
30 |       # 操作方式显示名称映射
31 |       OPERATION_TYPE_DISPLAY = {
   |  ______________________________^
32 | |         SyncOperationType.MANUAL_SINGLE: "手动单台",
33 | |         SyncOperationType.MANUAL_BATCH: "手动批量",
34 | |         SyncOperationType.MANUAL_TASK: "手动任务",
35 | |         SyncOperationType.SCHEDULED_TASK: "定时任务",
36 | |     }
   | |_____^
37 |
38 |       # 同步分类显示名称映射
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:39:24
   |
38 |       # 同步分类显示名称映射
39 |       CATEGORY_DISPLAY = {
   |  ________________________^
40 | |         SyncCategory.ACCOUNT: "账户同步",
41 | |         SyncCategory.CAPACITY: "容量同步",
42 | |         SyncCategory.CONFIG: "配置同步",
43 | |         SyncCategory.AGGREGATION: "聚合统计",
44 | |         SyncCategory.OTHER: "其他",
45 | |     }
   | |_____^
46 |
47 |       # 操作方式英文描述
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:48:35
   |
47 |       # 操作方式英文描述
48 |       OPERATION_TYPE_DESCRIPTIONS = {
   |  ___________________________________^
49 | |         SyncOperationType.MANUAL_SINGLE: "Manual Single Instance Operation",
50 | |         SyncOperationType.MANUAL_BATCH: "Manual Batch Operation",
51 | |         SyncOperationType.MANUAL_TASK: "Manual Task Operation",
52 | |         SyncOperationType.SCHEDULED_TASK: "Scheduled Task Operation",
53 | |     }
   | |_____^
54 |
55 |       # 同步分类英文描述
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:56:29
   |
55 |       # 同步分类英文描述
56 |       CATEGORY_DESCRIPTIONS = {
   |  _____________________________^
57 | |         SyncCategory.ACCOUNT: "Account Synchronization",
58 | |         SyncCategory.CAPACITY: "Capacity Synchronization",
59 | |         SyncCategory.CONFIG: "Configuration Synchronization",
60 | |         SyncCategory.AGGREGATION: "Aggregation Statistics",
61 | |         SyncCategory.OTHER: "Other Operations",
62 | |     }
   | |_____^
63 |
64 |       # 数据库约束值列表
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:65:29
   |
64 |     # 数据库约束值列表
65 |     OPERATION_TYPE_VALUES = [t.value for t in SyncOperationType]
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
66 |     CATEGORY_VALUES = [c.value for c in SyncCategory]
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/sync_constants.py:66:23
   |
64 |     # 数据库约束值列表
65 |     OPERATION_TYPE_VALUES = [t.value for t in SyncOperationType]
66 |     CATEGORY_VALUES = [c.value for c in SyncCategory]
   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
67 |
68 |     @staticmethod
   |

D205 1 blank line required between summary line and description
 --> app/constants/system_constants.py:1:1
  |
1 | / """鲸落 - 常量定义模块
2 | | 统一管理所有魔法数字、硬编码值和配置常量.
3 | | """
  | |___^
4 |
5 |   # 移除循环导入
  |
help: Insert single blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/user_roles.py:19:11
   |
18 |     # 所有角色
19 |     ALL = [ADMIN, USER, VIEWER]
   |           ^^^^^^^^^^^^^^^^^^^^^
20 |
21 |     # 权限定义
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/user_roles.py:32:19
   |
31 |       # 角色权限映射
32 |       PERMISSIONS = {
   |  ___________________^
33 | |         ADMIN: [PERM_READ, PERM_CREATE, PERM_UPDATE, PERM_DELETE, PERM_ADMIN, PERM_EXECUTE],
34 | |         USER: [PERM_READ, PERM_CREATE, PERM_UPDATE, PERM_DELETE, PERM_EXECUTE],
35 | |         VIEWER: [PERM_READ],
36 | |     }
   | |_____^
37 |
38 |       # 角色显示名称
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/user_roles.py:39:21
   |
38 |       # 角色显示名称
39 |       DISPLAY_NAMES = {
   |  _____________________^
40 | |         ADMIN: "管理员",
41 | |         USER: "用户",
42 | |         VIEWER: "查看者",
43 | |     }
   | |_____^
44 |
45 |       # 角色描述
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/constants/user_roles.py:46:20
   |
45 |       # 角色描述
46 |       DESCRIPTIONS = {
   |  ____________________^
47 | |         ADMIN: "拥有系统所有权限,可以管理用户和系统配置",
48 | |         USER: "可以创建、修改、删除数据,执行同步任务",
49 | |         VIEWER: "只能查看数据,不能进行任何修改操作",
50 | |     }
   | |_____^
51 |
52 |       # 辅助方法
   |

D205 1 blank line required between summary line and description
 --> app/errors/__init__.py:1:1
  |
1 | / """鲸落 - 统一异常定义
2 | | 集中维护业务异常类型、严重度与 HTTP 状态码映射.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

PLR0913 Too many arguments in function definition (6 > 5)
  --> app/errors/__init__.py:69:9
   |
67 |     )
68 |
69 |     def __init__(
   |         ^^^^^^^^
70 |         self,
71 |         message: str | None = None,
   |

D107 Missing docstring in `__init__`
  --> app/errors/__init__.py:69:9
   |
67 |     )
68 |
69 |     def __init__(
   |         ^^^^^^^^
70 |         self,
71 |         message: str | None = None,
   |

E501 Line too long (122 > 120)
   --> app/errors/__init__.py:211:121
    |
209 |         category=ErrorCategory.SECURITY,
210 |         severity=ErrorSeverity.MEDIUM,
211 |         default_message_key="RATE_LIMIT_EXCEEDED" if hasattr(ErrorMessages, "RATE_LIMIT_EXCEEDED") else "INVALID_REQUEST",
    |                                                                                                                         ^^
212 |     )
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `resource`
  --> app/forms/definitions/base.py:64:37
   |
62 |     """
63 |
64 |     def __call__(self, *, resource: Any | None) -> Mapping[str, Any]:
   |                                     ^^^^^^^^^^
65 |         """构造模板渲染所需的上下文字典.
   |

ANN202 Missing return type annotation for private function `__getattr__`
  --> app/models/__init__.py:38:5
   |
38 | def __getattr__(name: str):
   |     ^^^^^^^^^^^
39 |     """延迟加载模型, 避免初始化周期引发的循环导入."""
40 |     if name not in __all__:
   |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
  --> app/models/__init__.py:44:5
   |
42 |         raise AttributeError(msg)
43 |
44 |     from importlib import import_module
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
45 |
46 |     module_map = {
   |

ANN201 Missing return type annotation for public function `color_value`
  --> app/models/account_classification.py:75:9
   |
74 |     @property
75 |     def color_value(self):
   |         ^^^^^^^^^^^
76 |         """获取实际颜色值.
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `color_name`
  --> app/models/account_classification.py:85:9
   |
84 |     @property
85 |     def color_name(self):
   |         ^^^^^^^^^^
86 |         """获取颜色名称.
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `css_class`
  --> app/models/account_classification.py:95:9
   |
94 |     @property
95 |     def css_class(self):
   |         ^^^^^^^^^
96 |         """获取 CSS 类名.
   |
help: Add return type annotation

ERA001 Found commented-out code
   --> app/models/account_classification.py:222:5
    |
220 |     updated_at = db.Column(db.DateTime(timezone=True), default=time_utils.now, onupdate=time_utils.now)
221 |
222 |     # 唯一约束:一个账户在同一个批次中只能有一个分类分配
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
223 |     __table_args__ = (
224 |         db.UniqueConstraint(
    |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/models/account_permission.py:67:5
   |
65 |     database_permissions = db.Column(db.JSON, nullable=True)  # SQL Server数据库权限
66 |
67 |     # Oracle权限字段(移除表空间配额)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |     oracle_roles = db.Column(db.JSON, nullable=True)  # Oracle角色
69 |     system_privileges = db.Column(db.JSON, nullable=True)  # Oracle系统权限
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/models/account_permission.py:80:5
   |
78 |     last_change_time = db.Column(db.DateTime(timezone=True), default=time_utils.now, index=True)
79 |
80 |     # 删除标记(不支持恢复)
   |     ^^^^^^^^^^^^^^^^^^^^^^
81 |     # 关联实例与账户
82 |     instance = db.relationship("Instance", backref="account_permissions")
   |
help: Remove commented-out code

PLR0913 Too many arguments in function definition (8 > 5)
  --> app/models/credential.py:46:9
   |
44 |     deleted_at = db.Column(db.DateTime(timezone=True), nullable=True)
45 |
46 |     def __init__(
   |         ^^^^^^^^
47 |         self,
48 |         name: str,
   |

ERA001 Found commented-out code
   --> app/models/credential.py:106:9
    |
105 |         """
106 |         # 如果是bcrypt哈希(旧格式),使用bcrypt验证
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
107 |         if self.password.startswith("$2b$"):
108 |             return bcrypt.check_password_hash(self.password, password)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/models/credential.py:115:9
    |
113 |             return decrypted_password == password
114 |
115 |         # 如果是明文密码(不安全),直接比较
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
116 |         return self.password == password
    |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   --> app/models/credential.py:125:33
    |
124 |         """
125 |         if len(self.password) > 8:
    |                                 ^
126 |             return "*" * (len(self.password) - 4) + self.password[-4:]
127 |         return "*" * len(self.password)
    |

PLC0415 `import` should be at the top-level of a file
   --> app/models/credential.py:142:13
    |
140 |         if self.password.startswith("$2b$"):
141 |             # 对于旧格式,从环境变量获取密码,避免硬编码
142 |             import os
    |             ^^^^^^^^^
143 |             default_password = os.getenv(f"DEFAULT_{self.db_type.upper()}_PASSWORD")
144 |             if default_password:
    |

PLC0415 `import` should be at the top-level of a file
   --> app/models/credential.py:147:13
    |
145 |                 return default_password
146 |             # 如果没有设置环境变量,返回空字符串并记录警告
147 |             from app.utils.structlog_config import get_system_logger
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
148 |             system_logger = get_system_logger()
149 |             system_logger.warning(
    |

G004 Logging statement uses f-string
   --> app/models/credential.py:150:17
    |
148 |             system_logger = get_system_logger()
149 |             system_logger.warning(
150 |                 f"未设置环境变量 DEFAULT_{self.db_type.upper()}_PASSWORD,无法获取密码",
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
151 |                 module="credential_model",
152 |                 db_type=self.db_type,
    |
help: Convert to lazy `%` formatting

ERA001 Found commented-out code
   --> app/models/credential.py:160:9
    |
158 |             return get_password_manager().decrypt_password(self.password)
159 |
160 |         # 如果都不是,可能是明文密码(不安全)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
161 |         return self.password
    |
help: Remove commented-out code

D205 1 blank line required between summary line and description
 --> app/models/database_size_aggregation.py:1:1
  |
1 | / """数据库大小聚合统计模型
2 | | 存储每周、每月、每季度的统计信息.
3 | | """
  | |___^
4 |
5 |   from sqlalchemy import (
  |
help: Insert single blank line

ERA001 Found commented-out code
  --> app/models/database_size_aggregation.py:69:5
   |
67 |     data_count = Column(Integer, nullable=False, comment="统计的数据点数量")
68 |
69 |     # 数据大小统计(如果可获取)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
70 |     avg_data_size_mb = Column(BigInteger, nullable=True, comment="平均数据大小(MB)")
71 |     max_data_size_mb = Column(BigInteger, nullable=True, comment="最大数据大小(MB)")
   |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/models/database_size_aggregation.py:111:9
    |
109 |             "period_start",
110 |         ),
111 |         # 唯一约束(在分区表中,唯一约束会自动包含分区键)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |         UniqueConstraint(
113 |             "instance_id",
    |
help: Remove commented-out code

D205 1 blank line required between summary line and description
 --> app/models/database_size_stat.py:1:1
  |
1 | / """数据库大小统计模型
2 | | 存储每个数据库在特定时间点的大小统计信息
3 | | 支持 PostgreSQL 分区表,按日期分区.
4 | | """
  | |___^
5 |
6 |   from sqlalchemy import (
  |
help: Insert single blank line

E501 Line too long (121 > 120)
  --> app/models/database_size_stat.py:64:115
   |
62 |     )
63 |     updated_at = Column(
64 |         DateTime(timezone=True), nullable=False, default=time_utils.now, onupdate=time_utils.now, comment="记录更新时间",
   |                                                                                                                         ^
65 |     )
   |

D205 1 blank line required between summary line and description
 --> app/models/database_type_config.py:1:1
  |
1 | / """鲸落 - 数据库类型配置模型
2 | | 管理数据库类型的配置信息.
3 | | """
  | |___^
4 |
5 |   import json
  |
help: Insert single blank line

PLR0913 Too many arguments in function definition (9 > 5)
  --> app/models/instance.py:95:9
   |
93 |     # sync_data关系已移除,因为SyncData表已删除
94 |
95 |     def __init__(
   |         ^^^^^^^^
96 |         self,
97 |         name: str,
   |

ARG002 Unused method argument: `tags`
   --> app/models/instance.py:104:9
    |
102 |         credential_id: int | None = None,
103 |         description: str | None = None,
104 |         tags: list | None = None,
    |         ^^^^
105 |         *,
106 |         is_active: bool = True,
    |

D205 1 blank line required between summary line and description
 --> app/models/instance_account.py:1:1
  |
1 | / """鲸落 - 实例账户关系模型
2 | | 用于维护实例包含哪些账户,以及账户的存在状态.
3 | | """
  | |___^
4 |
5 |   from app import db
  |
help: Insert single blank line

E501 Line too long (121 > 120)
  --> app/models/instance_account.py:37:115
   |
35 |     db_type = db.Column(db.String(50), nullable=False, comment="数据库类型")
36 |     is_active = db.Column(db.Boolean, default=True, nullable=False, comment="账户是否活跃")
37 |     first_seen_at = db.Column(db.DateTime(timezone=True), nullable=False, default=time_utils.now, comment="首次发现时间")
   |                                                                                                                         ^
38 |     last_seen_at = db.Column(db.DateTime(timezone=True), nullable=False, default=time_utils.now, comment="最后发现时间")
39 |     deleted_at = db.Column(db.DateTime(timezone=True), nullable=True, comment="删除时间")
   |

D205 1 blank line required between summary line and description
 --> app/models/instance_database.py:1:1
  |
1 | / """鲸落 - 实例数据库关系模型
2 | | 用于维护实例包含哪些数据库,以及数据库的状态变化.
3 | | """
  | |___^
4 |
5 |   from datetime import date
  |
help: Insert single blank line

D205 1 blank line required between summary line and description
 --> app/models/instance_size_aggregation.py:1:1
  |
1 | / """实例大小聚合统计模型
2 | | 存储实例级别的每周、每月、每季度的统计信息.
3 | | """
  | |___^
4 |
5 |   from sqlalchemy import (
  |
help: Insert single blank line

ERA001 Found commented-out code
   --> app/models/instance_size_aggregation.py:106:9
    |
104 |             "period_start",
105 |         ),
106 |         # 唯一约束(在分区表中,唯一约束会自动包含分区键)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
107 |         UniqueConstraint(
108 |             "instance_id",
    |
help: Remove commented-out code

ANN202 Missing return type annotation for private function `_to_float`
   --> app/models/instance_size_aggregation.py:134:13
    |
133 |         """
134 |         def _to_float(value):
    |             ^^^^^^^^^
135 |             return float(value) if value is not None else None
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `value`
   --> app/models/instance_size_aggregation.py:134:23
    |
133 |         """
134 |         def _to_float(value):
    |                       ^^^^^
135 |             return float(value) if value is not None else None
    |

D205 1 blank line required between summary line and description
 --> app/models/instance_size_stat.py:1:1
  |
1 | / """鲸落 - 实例大小统计模型
2 | | 存储数据库实例的总大小统计数据.
3 | | """
  | |___^
4 |
5 |   from app import db
  |
help: Insert single blank line

E501 Line too long (123 > 120)
  --> app/models/instance_size_stat.py:41:118
   |
39 |     deleted_at = db.Column(db.DateTime(timezone=True), nullable=True, comment="删除时间")
40 |     created_at = db.Column(db.DateTime(timezone=True), default=time_utils.now, comment="创建时间")
41 |     updated_at = db.Column(db.DateTime(timezone=True), default=time_utils.now, onupdate=time_utils.now, comment="更新时间")
   |                                                                                                                          ^^
42 |
43 |     # 关系
   |

ARG002 Unused method argument: `created_by`
  --> app/models/sync_session.py:67:72
   |
65 |     )
66 |
67 |     def __init__(self, sync_type: str, sync_category: str = "account", created_by: int | None = None) -> None:
   |                                                                        ^^^^^^^^^^
68 |         """初始化同步会话.
   |

ANN201 Missing return type annotation for public function `color_value`
  --> app/models/tag.py:65:9
   |
64 |     @property
65 |     def color_value(self):
   |         ^^^^^^^^^^^
66 |         """获取实际颜色值.
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `color_name`
  --> app/models/tag.py:75:9
   |
74 |     @property
75 |     def color_name(self):
   |         ^^^^^^^^^^
76 |         """获取颜色名称.
   |
help: Add return type annotation

ANN201 Missing return type annotation for public function `css_class`
  --> app/models/tag.py:85:9
   |
84 |     @property
85 |     def css_class(self):
   |         ^^^^^^^^^
86 |         """获取 CSS 类名.
   |
help: Add return type annotation

D205 1 blank line required between summary line and description
 --> app/models/unified_log.py:1:1
  |
1 | / """鲸落 - 统一日志系统数据模型
2 | | 基于structlog的统一日志存储模型.
3 | | """
  | |___^
4 |
5 |   from datetime import datetime, timedelta
  |
help: Insert single blank line

ERA001 Found commented-out code
  --> app/models/unified_log.py:38:5
   |
36 |     id = Column(Integer, primary_key=True, autoincrement=True)
37 |
38 |     # 日志时间戳 (UTC)
   |     ^^^^^^^^^^^^^^^^^^
39 |     timestamp = Column(DateTime(timezone=True), nullable=False, index=True)
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/models/unified_log.py:50:5
   |
48 |     message = Column(Text, nullable=False)
49 |
50 |     # 错误堆栈追踪 (仅ERROR/CRITICAL)
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
51 |     traceback = Column(Text, nullable=True)
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> app/models/unified_log.py:53:5
   |
51 |     traceback = Column(Text, nullable=True)
52 |
53 |     # 附加上下文 (JSON格式)
   |     ^^^^^^^^^^^^^^^^^^^^^^^
54 |     context = Column(JSON, nullable=True)
   |
help: Remove commented-out code

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/models/unified_log.py:98:9
    |
 97 |     @classmethod
 98 |     def create_log_entry(
    |         ^^^^^^^^^^^^^^^^
 99 |         cls,
100 |         level: LogLevel,
    |

PLC0415 `import` should be at the top-level of a file
   --> app/models/unified_log.py:126:13
    |
124 |         elif timestamp.tzinfo is None:
125 |             # 如果没有时区信息,假设为UTC时间
126 |             from app.utils.time_utils import UTC_TZ
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 |
128 |             timestamp = timestamp.replace(tzinfo=UTC_TZ)
    |

PLC0415 `import` should be at the top-level of a file
   --> app/models/unified_log.py:150:9
    |
149 |         """
150 |         from sqlalchemy import func
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
151 |
152 |         start_time = time_utils.now() - timedelta(hours=hours)
    |

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
  --> app/models/user.py:69:28
   |
67 |         """
68 |         # 增加密码强度验证
69 |         if len(password) < 8:
   |                            ^
70 |             error_msg = "密码长度至少8位"
71 |             raise ValueError(error_msg)
   |

INP001 File `app/routes/accounts/classifications.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/accounts/classifications.py:1:1

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/accounts/classifications.py:376:9
    |
374 |       result = []
375 |       for rule in rules:
376 | /         result.append(
377 | |             {
378 | |                 "id": rule.id,
379 | |                 "rule_name": rule.rule_name,
380 | |                 "classification_id": rule.classification_id,
381 | |                 "classification_name": rule.classification.name if rule.classification else None,
382 | |                 "db_type": rule.db_type,
383 | |                 "rule_expression": rule.rule_expression,
384 | |                 "is_active": rule.is_active,
385 | |                 "matched_accounts_count": 0,
386 | |                 "created_at": rule.created_at.isoformat() if rule.created_at else None,
387 | |                 "updated_at": rule.updated_at.isoformat() if rule.updated_at else None,
388 | |             },
389 | |         )
    | |_________^
390 |
391 |       rules_by_db_type: dict[str, list[dict[str, object]]] = {}
    |
help: Replace for loop with list comprehension

PLC0415 `import` should be at the top-level of a file
   --> app/routes/accounts/classifications.py:770:5
    |
769 |     """
770 |     from app.models.permission_config import PermissionConfig
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
771 |
772 |     # 从数据库获取权限配置
    |

INP001 File `app/routes/accounts/ledgers.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/accounts/ledgers.py:1:1

C901 `list_accounts` is too complex (18 > 10)
  --> app/routes/accounts/ledgers.py:32:5
   |
30 | @login_required
31 | @view_required
32 | def list_accounts(db_type: str | None = None) -> str | tuple[Response, int]:
   |     ^^^^^^^^^^^^^
33 |     """账户列表页面.
   |

PLR0912 Too many branches (17 > 12)
  --> app/routes/accounts/ledgers.py:32:5
   |
30 | @login_required
31 | @view_required
32 | def list_accounts(db_type: str | None = None) -> str | tuple[Response, int]:
   |     ^^^^^^^^^^^^^
33 |     """账户列表页面.
   |

PLR0915 Too many statements (65 > 50)
  --> app/routes/accounts/ledgers.py:32:5
   |
30 | @login_required
31 | @view_required
32 | def list_accounts(db_type: str | None = None) -> str | tuple[Response, int]:
   |     ^^^^^^^^^^^^^
33 |     """账户列表页面.
   |

PLC0415 `import` should be at the top-level of a file
  --> app/routes/accounts/ledgers.py:76:9
   |
74 |     # 搜索过滤 - 支持用户名、实例名称、IP地址搜索
75 |     if search:
76 |         from app import db
   |         ^^^^^^^^^^^^^^^^^^
77 |         # 通过JOIN实例表来搜索实例名称和IP地址
78 |         query = query.join(Instance, AccountPermission.instance_id == Instance.id)
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/accounts/ledgers.py:104:16
    |
102 |             query = query.join(Instance).join(Instance.tags).filter(Tag.name.in_(tags))
103 |             # 应用标签过滤
104 |         except Exception as e:
    |                ^^^^^^^^^
105 |             log_error(
106 |                 "标签过滤失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/accounts/ledgers.py:114:9
    |
113 |     if classification_filter:
114 |         from app.models.account_classification import AccountClassification, AccountClassificationAssignment
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
115 |
116 |         try:
    |

E501 Line too long (123 > 120)
   --> app/routes/accounts/ledgers.py:124:121
    |
122 |                 query.join(AccountClassificationAssignment)
123 |                 .join(AccountClassification)
124 |                 .filter(AccountClassification.id == classification_id, AccountClassificationAssignment.is_active.is_(True))
    |                                                                                                                         ^^^
125 |             )
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/accounts/ledgers.py:167:5
    |
166 |     # 获取账户分类信息
167 |     from app.models.account_classification import AccountClassificationAssignment
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
168 |
169 |     classifications = {}
    |

C901 `list_accounts_data` is too complex (18 > 10)
   --> app/routes/accounts/ledgers.py:311:5
    |
309 | @login_required
310 | @view_required
311 | def list_accounts_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^
312 |     """Grid.js 账户列表 API.
    |

PLR0912 Too many branches (17 > 12)
   --> app/routes/accounts/ledgers.py:311:5
    |
309 | @login_required
310 | @view_required
311 | def list_accounts_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^
312 |     """Grid.js 账户列表 API.
    |

PLR0915 Too many statements (62 > 50)
   --> app/routes/accounts/ledgers.py:311:5
    |
309 | @login_required
310 | @view_required
311 | def list_accounts_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^
312 |     """Grid.js 账户列表 API.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/accounts/ledgers.py:367:16
    |
365 |         try:
366 |             query = query.join(Instance).join(Instance.tags).filter(Tag.name.in_(tags))
367 |         except Exception as exc:
    |                ^^^^^^^^^
368 |             log_error(
369 |                 "标签过滤失败",
    |

INP001 File `app/routes/accounts/statistics.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/accounts/statistics.py:1:1

PLC0415 `import` should be at the top-level of a file
  --> app/routes/accounts/statistics.py:39:5
   |
37 |         flash("获取账户统计信息失败,请稍后重试", FlashCategory.ERROR)
38 |
39 |     from app.models.sync_session import SyncSession
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
40 |
41 |     recent_syncs = SyncSession.query.order_by(SyncSession.created_at.desc()).limit(10).all()
   |

INP001 File `app/routes/accounts/sync.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/accounts/sync.py:1:1

TRY301 Abstract `raise` to an inner function
   --> app/routes/accounts/sync.py:102:13
    |
100 |             )
101 |             msg = "没有找到活跃的数据库实例"
102 |             raise AppValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
103 |
104 |         created_by = getattr(current_user, "id", None)
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/accounts/sync.py:107:13
    |
106 |         def _run_sync_task(captured_created_by: int | None) -> None:
107 |             from app.tasks.accounts_sync_tasks import sync_accounts
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
108 |
109 |             try:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/accounts/sync.py:111:20
    |
109 |             try:
110 |                 sync_accounts(manual_run=True, created_by=captured_created_by)
111 |             except Exception as exc:  # pragma: no cover - 后台线程日志
    |                    ^^^^^^^^^
112 |                 log_error(
113 |                     "后台批量账户同步失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/auth.py:310:5
    |
309 |     """
310 |     from flask_wtf.csrf import generate_csrf
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
311 |     return jsonify_unified_success(
312 |         data={"csrf_token": generate_csrf()},
    |

D205 1 blank line required between summary line and description
 --> app/routes/cache.py:2:1
  |
2 | / """鲸落 - 缓存管理路由
3 | | 提供缓存管理相关的API接口.
4 | | """
  | |___^
5 |
6 |   from flask import Blueprint, Response, request
  |
help: Insert single blank line

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/cache.py:165:16
    |
163 |             if cache_manager.invalidate_instance_cache(instance.id):
164 |                 cleared_count += 1
165 |         except Exception as exc:
    |                ^^^^^^^^^
166 |             log_error(f"清除实例 {instance.id} 缓存失败: {exc}", module="cache")
    |

E501 Line too long (121 > 120)
   --> app/routes/cache.py:174:112
    |
172 |         operator_id=getattr(current_user, "id", None),
173 |     )
174 |     return jsonify_unified_success(message=f"已清除 {cleared_count} 个实例的缓存", data={"cleared_count": cleared_count})
    |                                                                                                                         ^
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/cache.py:281:16
    |
279 |                 "rules_count": len(rules_cache) if rules_cache else 0,
280 |             }
281 |         except Exception as exc:
    |                ^^^^^^^^^
282 |             log_error(f"获取数据库类型 {db_type} 缓存统计失败: {exc}", module="cache")
283 |             db_type_stats[db_type] = {
    |

C901 `aggregate_current` is too complex (28 > 10)
  --> app/routes/capacity/aggregations.py:58:5
   |
56 | @view_required
57 | @require_csrf
58 | def aggregate_current() -> Response:  # noqa: PLR0912, PLR0915
   |     ^^^^^^^^^^^^^^^^^
59 |     """手动触发当前周期数据聚合.
   |

D205 1 blank line required between summary line and description
 --> app/routes/capacity/databases.py:1:1
  |
1 | / """数据库统计 API 路由
2 | | 提供数据库大小监控、历史数据、统计聚合等接口
3 | | 专注于数据库层面的统计功能.
4 | | """
  | |___^
5 |
6 |   import contextlib
  |
help: Insert single blank line

ANN201 Missing return type annotation for public function `list_databases`
  --> app/routes/capacity/databases.py:33:5
   |
31 | @login_required
32 | @view_required
33 | def list_databases():
   |     ^^^^^^^^^^^^^^
34 |     """数据库统计聚合页面(数据库统计层面).
   |
help: Add return type annotation

TRY301 Abstract `raise` to an inner function
   --> app/routes/capacity/databases.py:205:13
    |
203 |         if parsed_dt is None:
204 |             msg = "无法解析日期"
205 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^
206 |         return parsed_dt.date()
207 |     except Exception as exc:
    |

UP017 [*] Use `datetime.UTC` alias
  --> app/routes/capacity/instances.py:60:70
   |
58 |     """
59 |     try:
60 |         parsed = datetime.strptime(value, "%Y-%m-%d").replace(tzinfo=timezone.utc)
   |                                                                      ^^^^^^^^^^^^
61 |         return parsed.date()
62 |     except ValueError as exc:
   |
help: Convert to `datetime.UTC` alias

ANN201 Missing return type annotation for public function `list_instances`
  --> app/routes/capacity/instances.py:71:5
   |
69 | @login_required
70 | @view_required
71 | def list_instances():
   |     ^^^^^^^^^^^^^^
72 |     """实例统计聚合页面.
   |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
  --> app/routes/capacity/instances.py:85:5
   |
83 |     end_date = request.args.get("end_date", "")
84 |
85 |     from app.services.database_type_service import DatabaseTypeService
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
86 |     database_type_configs = DatabaseTypeService.get_active_types()
87 |     if database_type_configs:
   |

C901 `fetch_instance_metrics` is too complex (11 > 10)
   --> app/routes/capacity/instances.py:123:5
    |
121 | @login_required
122 | @view_required
123 | def fetch_instance_metrics():
    |     ^^^^^^^^^^^^^^^^^^^^^^
124 |     """获取实例聚合数据(实例统计层面).
    |

PLR0915 Too many statements (56 > 50)
   --> app/routes/capacity/instances.py:123:5
    |
121 | @login_required
122 | @view_required
123 | def fetch_instance_metrics():
    |     ^^^^^^^^^^^^^^^^^^^^^^
124 |     """获取实例聚合数据(实例统计层面).
    |

ANN201 Missing return type annotation for public function `fetch_instance_metrics`
   --> app/routes/capacity/instances.py:123:5
    |
121 | @login_required
122 | @view_required
123 | def fetch_instance_metrics():
    |     ^^^^^^^^^^^^^^^^^^^^^^
124 |     """获取实例聚合数据(实例统计层面).
    |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
   --> app/routes/capacity/instances.py:167:9
    |
166 |         # 构建查询 - 查询实例统计聚合表
167 |         from app.models.instance_size_aggregation import InstanceSizeAggregation
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
168 |         query = (
169 |             InstanceSizeAggregation.query.join(Instance)
    |

C901 `fetch_instance_summary` is too complex (13 > 10)
   --> app/routes/capacity/instances.py:252:5
    |
250 | @login_required
251 | @view_required
252 | def fetch_instance_summary():
    |     ^^^^^^^^^^^^^^^^^^^^^^
253 |     """获取实例聚合汇总信息(实例统计层面).
    |

ANN201 Missing return type annotation for public function `fetch_instance_summary`
   --> app/routes/capacity/instances.py:252:5
    |
250 | @login_required
251 | @view_required
252 | def fetch_instance_summary():
    |     ^^^^^^^^^^^^^^^^^^^^^^
253 |     """获取实例聚合汇总信息(实例统计层面).
    |
help: Add return type annotation

D205 1 blank line required between summary line and description
 --> app/routes/common.py:1:1
  |
1 | / """通用 API 路由
2 | | 提供跨模块使用的通用接口.
3 | | """
  | |___^
4 |
5 |   from flask import Blueprint, Response, request
  |
help: Insert single blank line

E501 Line too long (251 > 120)
  --> app/routes/connections.py:72:113
   |
70 | …
71 | …
72 | …ersion=result.get("database_version"), main_version=result.get("main_version"), detailed_version=result.get("detailed_version"))
   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
73 | …
74 | …
   |

PLR2004 Magic value used in comparison, consider replacing `65535` with a constant variable
   --> app/routes/connections.py:108:28
    |
106 |         msg = "端口号必须是有效的数字"
107 |         raise ValidationError(msg) from exc
108 |     if port <= 0 or port > 65535:
    |                            ^^^^^
109 |         msg = "端口号必须在1-65535之间"
110 |         raise ValidationError(msg)
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/connections.py:111:5
    |
109 |         msg = "端口号必须在1-65535之间"
110 |         raise ValidationError(msg)
111 |     from app.models import Credential
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |     credential = Credential.query.get(connection_params.get("credential_id"))
113 |     if not credential:
    |

E501 Line too long (223 > 120)
   --> app/routes/connections.py:116:121
    |
114 | …
115 | …
116 | …tion_params.get("host"), port=port, credential_id=connection_params.get("credential_id"), description="临时测试连接")
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
117 | …
118 | …
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/connections.py:150:13
    |
148 |         if not ConnectionFactory.is_type_supported(db_type):
149 |             msg = f"不支持的数据库类型: {db_type}"
150 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
151 |         try:
152 |             port = int(data.get("port", 0))
    |

PLR2004 Magic value used in comparison, consider replacing `65535` with a constant variable
   --> app/routes/connections.py:156:32
    |
154 |             msg = "端口号必须是有效的数字"
155 |             raise ValidationError(msg) from exc
156 |         if port <= 0 or port > 65535:
    |                                ^^^^^
157 |             msg = "端口号必须在1-65535之间"
158 |             raise ValidationError(msg)
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/connections.py:158:13
    |
156 |         if port <= 0 or port > 65535:
157 |             msg = "端口号必须在1-65535之间"
158 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
159 |         if data.get("credential_id"):
160 |             from app.models import Credential
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/connections.py:160:13
    |
158 |             raise ValidationError(msg)
159 |         if data.get("credential_id"):
160 |             from app.models import Credential
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
161 |             credential = Credential.query.get(data.get("credential_id"))
162 |             if not credential:
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/connections.py:164:17
    |
162 |             if not credential:
163 |                 msg = "凭据不存在"
164 |                 raise NotFoundError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^
165 |         log_info("连接参数验证通过", module="connections", db_type=db_type)
166 |         return jsonify_unified_success(message="连接参数验证通过")
    |

PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   --> app/routes/connections.py:196:28
    |
194 |         msg = "实例ID列表不能为空"
195 |         raise ValidationError(msg)
196 |     if len(instance_ids) > 50:
    |                            ^^
197 |         msg = "批量测试数量不能超过50个"
198 |         raise ValidationError(msg)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/connections.py:219:20
    |
217 |                     fail_count += 1
218 |                 results.append(result)
219 |             except Exception as e:
    |                    ^^^^^^^^^
220 |                 results.append({"instance_id": instance_id, "success": False, "error": f"测试失败: {e!s}"})
221 |                 fail_count += 1
    |

E501 Line too long (125 > 120)
   --> app/routes/connections.py:223:113
    |
221 |                 fail_count += 1
222 |                 log_error("批量连接测试单实例失败", module="connections", instance_id=instance_id, error=str(e))
223 |         log_info("批量连接测试完成", module="connections", total=len(instance_ids), success=success_count, failed=fail_count)
    |                                                                                                                         ^^^^^
224 |         return jsonify_unified_success(data={"results": results, "summary": {"total": len(instance_ids), "success": success_count, "f…
225 |     except Exception as exc:
    |

E501 Line too long (182 > 120)
   --> app/routes/connections.py:224:121
    |
222 | …d, error=str(e))
223 | …uccess_count, failed=fail_count)
224 | … len(instance_ids), "success": success_count, "failed": fail_count}}, message="批量连接测试完成")
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
225 | …
226 | …
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/connections.py:257:13
    |
255 |         status = "unknown"
256 |         if instance.last_connected:
257 |             from datetime import datetime, timedelta
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
258 |             last_connected_time = instance.last_connected
259 |             if isinstance(last_connected_time, str):
    |

E501 Line too long (293 > 120)
   --> app/routes/connections.py:268:121
    |
266 | …
267 | …
268 | … instance.db_type, "host": instance.host, "port": instance.port, "last_connected": last_connected, "status": status, "is_active": instance.is_active}, message="获取连接状态成功")
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
269 | …
270 | …
    |

C901 `index` is too complex (12 > 10)
   --> app/routes/credentials.py:151:5
    |
149 | @login_required
150 | @view_required
151 | def index() -> str:
    |     ^^^^^
152 |     """凭据管理首页.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/credentials.py:212:9
    |
210 |     # 标签筛选
211 |     if tags:
212 |         from app.models.tag import Tag
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
213 |         query = query.join(Credential.tags).filter(Tag.name.in_(tags))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/credentials.py:379:16
    |
377 |             db.session.delete(credential)
378 |             db.session.commit()
379 |         except Exception as exc:
    |                ^^^^^^^^^
380 |             _handle_db_exception("删除凭据", exc)
381 |     except DatabaseError as exc:
    |

C901 `list_credentials` is too complex (11 > 10)
   --> app/routes/credentials.py:410:5
    |
408 | @login_required
409 | @view_required
410 | def list_credentials() -> "Response":
    |     ^^^^^^^^^^^^^^^^
411 |     """获取凭据列表 API.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/credentials.py:470:9
    |
469 |     if tag_params:
470 |         from app.models.tag import Tag
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
471 |         query = query.join(Credential.tags).filter(Tag.name.in_(tag_params))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:219:12
    |
217 |             },
218 |         }
219 |     except Exception as exc:
    |            ^^^^^^^^^
220 |         db.session.rollback()
221 |         log_error("获取系统概览失败", module="dashboard", error=str(exc))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:262:12
    |
260 |             charts["sync_trend"] = get_sync_trend_data()
261 |
262 |     except Exception as exc:
    |            ^^^^^^^^^
263 |         log_error("获取图表数据失败", module="dashboard", error=str(exc))
264 |         charts = {}
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:312:12
    |
311 |         return [{"status": status, "count": count} for status, count in status_count.items()]
312 |     except Exception as exc:
    |            ^^^^^^^^^
313 |         log_error("获取任务状态分布失败", module="dashboard", error=str(exc))
314 |         return []
    |

SIM118 Use `key in dict` instead of `key in dict.keys()`
   --> app/routes/dashboard.py:384:61
    |
382 |         result_mapping: dict[str, Any] = {}
383 |         if result is not None:
384 |             result_mapping = {key: getattr(result, key) for key in result.keys()}
    |                                                             ^^^^^^^^^^^^^^^^^^^^
385 |
386 |         for start_dt, label in labels:
    |
help: Remove `.keys()`

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:393:12
    |
391 |                 },
392 |             )
393 |     except Exception as exc:
    |            ^^^^^^^^^
394 |         log_error("获取同步趋势数据失败", module="dashboard", error=str(exc))
395 |         trend_data = []
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/dashboard.py:444:12
    |
442 |             "uptime": get_system_uptime(),
443 |         }
444 |     except Exception as exc:
    |            ^^^^^^^^^
445 |         log_error("获取系统状态失败", module="dashboard", error=str(exc))
446 |         return {
    |

D205 1 blank line required between summary line and description
 --> app/routes/databases/capacity_sync.py:1:1
  |
1 | / """数据库域:容量同步 API 路由
2 | | 专注于数据同步功能,不包含统计功能.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

BLE001 Do not catch blind exception: `Exception`
  --> app/routes/databases/capacity_sync.py:74:16
   |
72 |         try:
73 |             inventory_result = collector.synchronize_database_inventory()
74 |         except Exception as inventory_error:
   |                ^^^^^^^^^
75 |             log_error(
76 |                 "同步数据库列表失败",
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/databases/capacity_sync.py:115:16
    |
113 |         try:
114 |             saved_count = collector.save_collected_data(databases_data)
115 |         except Exception as exc:
    |                ^^^^^^^^^
116 |             log_error(
117 |                 "保存数据库容量数据失败",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/databases/capacity_sync.py:136:16
    |
134 |             aggregation_service.calculate_daily_database_aggregations_for_instance(instance.id)
135 |             aggregation_service.calculate_daily_aggregations_for_instance(instance.id)
136 |         except Exception as exc:
    |                ^^^^^^^^^
137 |             log_warning(
138 |                 "容量聚合刷新失败",
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/databases/capacity_sync.py:218:9
    |
216 |         )
217 |         error_message = result.get("message") or result.get("error") or "实例容量同步失败"
218 |         raise SystemError(error_message)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
219 |
220 |     except NotFoundError:
    |

D205 1 blank line required between summary line and description
 --> app/routes/files.py:1:1
  |
1 | / """文件导入导出路由
2 | | 统一处理全局的导出/上传相关接口.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

C901 `export_accounts` is too complex (17 > 10)
  --> app/routes/files.py:39:5
   |
37 | @login_required
38 | @view_required
39 | def export_accounts() -> Response:
   |     ^^^^^^^^^^^^^^^
40 |     """导出账户数据为 CSV.
   |

PLR0912 Too many branches (18 > 12)
  --> app/routes/files.py:39:5
   |
37 | @login_required
38 | @view_required
39 | def export_accounts() -> Response:
   |     ^^^^^^^^^^^^^^^
40 |     """导出账户数据为 CSV.
   |

PLR0915 Too many statements (64 > 50)
  --> app/routes/files.py:39:5
   |
37 | @login_required
38 | @view_required
39 | def export_accounts() -> Response:
   |     ^^^^^^^^^^^^^^^
40 |     """导出账户数据为 CSV.
   |

PLC0415 `import` should be at the top-level of a file
  --> app/routes/files.py:67:9
   |
65 |         tags = [tag for tag in request.args.getlist("tags") if tag.strip()]
66 |
67 |         from app.models.instance_account import InstanceAccount
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
68 |
69 |         # 构建查询
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/files.py:101:20
    |
 99 |             try:
100 |                 query = query.join(Instance).join(Instance.tags).filter(Tag.name.in_(tags))
101 |             except Exception as exc:
    |                    ^^^^^^^^^
102 |                 log_error(
103 |                     "导出账户时标签过滤失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/files.py:111:9
    |
109 |         accounts = query.all()
110 |
111 |         from app.models.account_classification import AccountClassificationAssignment
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |
113 |         classifications: dict[int, list[str]] = {}
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/files.py:283:5
    |
281 | def export_database_ledger() -> Response:
282 |     """导出数据库台账列表为 CSV."""
283 |     from app.services.ledgers.database_ledger_service import DatabaseLedgerService
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
284 |
285 |     try:
    |

E501 Line too long (121 > 120)
   --> app/routes/files.py:299:89
    |
297 |         output = io.StringIO()
298 |         writer = csv.writer(output)
299 |         writer.writerow(["数据库名称", "实例名称", "主机", "数据库类型", "标签", "最新容量", "最后采集时间", "同步状态"])
    |                                                                                                                         ^
300 |
301 |         for row in rows:
    |

C901 `export_logs` is too complex (16 > 10)
   --> app/routes/files.py:342:5
    |
340 | @files_bp.route("/api/log-export", methods=["GET"])
341 | @login_required
342 | def export_logs() -> Response:
    |     ^^^^^^^^^^^
343 |     """导出日志 API.
    |

PLR0912 Too many branches (15 > 12)
   --> app/routes/files.py:342:5
    |
340 | @files_bp.route("/api/log-export", methods=["GET"])
341 | @login_required
342 | def export_logs() -> Response:
    |     ^^^^^^^^^^^
343 |     """导出日志 API.
    |

PLR0915 Too many statements (61 > 50)
   --> app/routes/files.py:342:5
    |
340 | @files_bp.route("/api/log-export", methods=["GET"])
341 | @login_required
342 | def export_logs() -> Response:
    |     ^^^^^^^^^^^
343 |     """导出日志 API.
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/files.py:406:17
    |
404 |               logs_data: list[dict[str, Any]] = []
405 |               for log in logs:
406 | /                 logs_data.append(
407 | |                     {
408 | |                         "id": log.id,
409 | |                         "timestamp": log.timestamp.isoformat() if log.timestamp else None,
410 | |                         "level": log.level.value if log.level else None,
411 | |                         "module": log.module,
412 | |                         "message": log.message,
413 | |                         "traceback": log.traceback,
414 | |                         "context": log.context,
415 | |                         "created_at": log.created_at.isoformat() if log.created_at else None,
416 | |                     },
417 | |                 )
    | |_________________^
418 |
419 |               payload = {"logs": logs_data, "exported_at": time_utils.now().isoformat()}
    |
help: Replace for loop with list comprehension

TRY301 Abstract `raise` to an inner function
   --> app/routes/files.py:474:9
    |
473 |         msg = "不支持的导出格式"
474 |         raise ValidationError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
475 |
476 |     except Exception as exc:
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/health.py:125:9
    |
123 |     db_status = "connected"
124 |     try:
125 |         from sqlalchemy import text
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
126 |
127 |         db.session.execute(text("SELECT 1"))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:128:12
    |
127 |         db.session.execute(text("SELECT 1"))
128 |     except Exception:
    |            ^^^^^^^^^
129 |         db_status = "error"
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:135:12
    |
133 |     try:
134 |         redis_status = "connected" if cache_manager and cache_manager.health_check() else "error"
135 |     except Exception:
    |            ^^^^^^^^^
136 |         redis_status = "error"
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/health.py:198:9
    |
196 |     try:
197 |         start_time = time.time()
198 |         from sqlalchemy import text
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
199 |         db.session.execute(text("SELECT 1"))
200 |         response_time = (time.time() - start_time) * 1000  # 毫秒
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:207:12
    |
205 |             "status": "connected",
206 |         }
207 |     except Exception as exc:
    |            ^^^^^^^^^
208 |         log_error("数据库健康检查失败", module="health", error=str(exc))
209 |         return {"healthy": False, "error": str(exc), "status": "disconnected"}
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:234:12
    |
232 |             "status": "connected" if result == "ok" else "error",
233 |         }
234 |     except Exception as exc:
    |            ^^^^^^^^^
235 |         log_error("缓存健康检查失败", module="health", error=str(exc))
236 |         return {"healthy": False, "error": str(exc), "status": "disconnected"}
    |

PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
   --> app/routes/health.py:269:31
    |
267 |         healthy = all(
268 |             [
269 |                 cpu_percent < 90,  # CPU使用率低于90%
    |                               ^^
270 |                 memory_percent < 90,  # 内存使用率低于90%
271 |                 disk_percent < 90,  # 磁盘使用率低于90%
    |

PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
   --> app/routes/health.py:270:34
    |
268 |             [
269 |                 cpu_percent < 90,  # CPU使用率低于90%
270 |                 memory_percent < 90,  # 内存使用率低于90%
    |                                  ^^
271 |                 disk_percent < 90,  # 磁盘使用率低于90%
272 |             ],
    |

PLR2004 Magic value used in comparison, consider replacing `90` with a constant variable
   --> app/routes/health.py:271:32
    |
269 |                 cpu_percent < 90,  # CPU使用率低于90%
270 |                 memory_percent < 90,  # 内存使用率低于90%
271 |                 disk_percent < 90,  # 磁盘使用率低于90%
    |                                ^^
272 |             ],
273 |         )
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:282:12
    |
280 |             "status": "healthy" if healthy else "warning",
281 |         }
282 |     except Exception as exc:
    |            ^^^^^^^^^
283 |         log_error("系统健康检查失败", module="health", error=str(exc))
284 |         return {"healthy": False, "error": str(exc), "status": "error"}
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/health.py:296:9
    |
294 |     """
295 |     try:
296 |         from app import app_start_time
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
297 |
298 |         current_time = time_utils.now_china()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/routes/health.py:305:9
    |
303 |         minutes, _ = divmod(remainder, 60)
304 |
305 |         return f"{days}天 {hours}小时 {minutes}分钟"
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
306 |     except Exception:
307 |         return "未知"
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/health.py:306:12
    |
305 |         return f"{days}天 {hours}小时 {minutes}分钟"
306 |     except Exception:
    |            ^^^^^^^^^
307 |         return "未知"
    |

D205 1 blank line required between summary line and description
 --> app/routes/history/logs.py:2:1
  |
2 | / """鲸落 - 统一日志系统API路由
3 | | 提供日志查询、展示和管理的RESTful API.
4 | | """
  | |___^
5 |
6 |   from datetime import datetime, timedelta
  |
help: Insert single blank line

C901 `search_logs` is too complex (17 > 10)
   --> app/routes/history/logs.py:102:5
    |
100 | @logs_bp.route("/api/search", methods=["GET"])
101 | @login_required
102 | def search_logs() -> Response:
    |     ^^^^^^^^^^^
103 |     """搜索日志 API.
    |

PLR0912 Too many branches (17 > 12)
   --> app/routes/history/logs.py:102:5
    |
100 | @logs_bp.route("/api/search", methods=["GET"])
101 | @login_required
102 | def search_logs() -> Response:
    |     ^^^^^^^^^^^
103 |     """搜索日志 API.
    |

PLR0915 Too many statements (67 > 50)
   --> app/routes/history/logs.py:102:5
    |
100 | @logs_bp.route("/api/search", methods=["GET"])
101 | @login_required
102 | def search_logs() -> Response:
    |     ^^^^^^^^^^^
103 |     """搜索日志 API.
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/history/logs.py:211:13
    |
209 |         logs = []
210 |         for log_entry in pagination.items:
211 |             logs.append(log_entry.to_dict())
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
212 |
213 |         response_data = {
    |
help: Replace for loop with list comprehension

C901 `list_logs` is too complex (11 > 10)
   --> app/routes/history/logs.py:238:5
    |
236 | @logs_bp.route("/api/list", methods=["GET"])
237 | @login_required
238 | def list_logs() -> Response:
    |     ^^^^^^^^^
239 |     """Grid.js 日志列表 API.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/history/logs.py:395:9
    |
393 |     """
394 |     try:
395 |         from sqlalchemy import distinct
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
396 |
397 |         # 获取所有模块
    |

C901 `get_log_stats` is too complex (11 > 10)
   --> app/routes/history/logs.py:413:5
    |
411 | @logs_bp.route("/api/stats", methods=["GET"])
412 | @login_required
413 | def get_log_stats() -> tuple[dict, int]:
    |     ^^^^^^^^^^^^^
414 |     """获取日志统计 API(兼容旧前端).
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/history/logs.py:472:9
    |
471 |         # 活跃模块数
472 |         from sqlalchemy import distinct
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
473 |         modules_query = db.session.query(distinct(UnifiedLog.module))
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/history/sessions.py:149:13
    |
147 |         if not session:
148 |             msg = "会话不存在"
149 |             raise NotFoundError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
150 |
151 |         # 获取实例记录
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/history/sessions.py:208:9
    |
206 |             return jsonify_unified_success(message="会话已取消")
207 |         msg = "取消会话失败,会话不存在或已结束"
208 |         raise NotFoundError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
209 |
210 |     except Exception as e:
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/history/sessions.py:245:13
    |
243 |         if not session:
244 |             msg = "会话不存在"
245 |             raise NotFoundError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
246 |
247 |         # 获取所有实例记录
    |

INP001 File `app/routes/instances/batch.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/instances/batch.py:1:1

TRY301 Abstract `raise` to an inner function
   --> app/routes/instances/batch.py:127:13
    |
125 |         if not uploaded_file or not uploaded_file.filename.endswith(".csv"):
126 |             msg = "请上传CSV格式文件"
127 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
128 |
129 |         return _process_csv_file(uploaded_file)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `file_obj`
   --> app/routes/instances/batch.py:145:33
    |
145 | def _process_csv_file(file_obj: Any) -> Response:
    |                                 ^^^
146 |     """解析 CSV 文件并触发批量创建.
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/instances/batch.py:171:13
    |
169 |         if not instances_data:
170 |             msg = "CSV文件为空或未包含有效数据"
171 |             raise ValidationError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^
172 |
173 |         return _create_instances(instances_data)
    |

INP001 File `app/routes/instances/detail.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/instances/detail.py:1:1

PLR0911 Too many return statements (7 > 6)
  --> app/routes/instances/detail.py:34:5
   |
34 | def _parse_is_active_value(data: Any, *, default: bool = False) -> bool:
   |     ^^^^^^^^^^^^^^^^^^^^^^
35 |     """从请求数据中解析 is_active,兼容表单/JSON/checkbox.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `data`
  --> app/routes/instances/detail.py:34:34
   |
34 | def _parse_is_active_value(data: Any, *, default: bool = False) -> bool:
   |                                  ^^^
35 |     """从请求数据中解析 is_active,兼容表单/JSON/checkbox.
   |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/instances/detail.py:181:5
    |
179 |     instance = Instance.query.get_or_404(instance_id)
180 |
181 |     from app.models.account_permission import AccountPermission
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
182 |
183 |     account = AccountPermission.query.filter_by(id=account_id, instance_id=instance_id).first_or_404()
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/instances/detail.py:186:9
    |
185 |     try:
186 |         from app.models.account_change_log import AccountChangeLog
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
187 |
188 |         change_logs = (
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/instances/detail.py:201:13
    |
199 |           history = []
200 |           for log in change_logs:
201 | /             history.append(
202 | |                 {
203 | |                     "id": log.id,
204 | |                     "change_type": log.change_type,
205 | |                     "change_time": (time_utils.format_china_time(log.change_time) if log.change_time else "未知"),
206 | |                     "status": log.status,
207 | |                     "message": log.message,
208 | |                     "privilege_diff": log.privilege_diff,
209 | |                     "other_diff": log.other_diff,
210 | |                     "session_id": log.session_id,
211 | |                 },
212 | |             )
    | |_____________^
213 |
214 |           return jsonify_unified_success(
    |
help: Replace for loop with list comprehension

ANN202 Missing return type annotation for private function `_build_capacity_query`
   --> app/routes/instances/detail.py:489:5
    |
487 |         message="获取账户权限详情成功",
488 |     )
489 | def _build_capacity_query(
    |     ^^^^^^^^^^^^^^^^^^^^^
490 |     instance_id: int,
491 |     database_name: str | None,
    |
help: Add return type annotation

FBT001 Boolean-typed positional argument in function definition
   --> app/routes/instances/detail.py:534:28
    |
534 | def _normalize_active_flag(flag: bool | None) -> bool:
    |                            ^^^^
535 |     """将可能为空的激活标记标准化为 bool.
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/routes/instances/detail.py:551:5
    |
549 | def _serialize_capacity_entry(
550 |     stat: DatabaseSizeStat,
551 |     is_active: bool,
    |     ^^^^^^^^^
552 |     deleted_at: datetime | None,
553 |     last_seen_date: date | None,
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> app/routes/instances/detail.py:581:5
    |
581 | def _fetch_latest_database_sizes(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
582 |     instance_id: int,
583 |     database_name: str | None,
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/routes/instances/detail.py:586:5
    |
584 |     start_date: date | None,
585 |     end_date: date | None,
586 |     include_inactive: bool,
    |     ^^^^^^^^^^^^^^^^
587 |     limit: int,
588 |     offset: int,
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> app/routes/instances/detail.py:676:5
    |
676 | def _fetch_historical_database_sizes(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
677 |     instance_id: int,
678 |     database_name: str | None,
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/routes/instances/detail.py:681:5
    |
679 |     start_date: date | None,
680 |     end_date: date | None,
681 |     include_inactive: bool,
    |     ^^^^^^^^^^^^^^^^
682 |     limit: int,
683 |     offset: int,
    |

INP001 File `app/routes/instances/manage.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/instances/manage.py:1:1

PLC0415 `import` should be at the top-level of a file
  --> app/routes/instances/manage.py:66:5
   |
65 |     # 获取数据库类型配置
66 |     from app.services.database_type_service import DatabaseTypeService
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
67 |
68 |     database_type_configs = DatabaseTypeService.get_active_types()
   |

C901 `list_instances_data` is too complex (13 > 10)
   --> app/routes/instances/manage.py:253:5
    |
251 | @login_required
252 | @view_required
253 | def list_instances_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^^
254 |     """Grid.js 实例列表 API.
    |

PLR0915 Too many statements (53 > 50)
   --> app/routes/instances/manage.py:253:5
    |
251 | @login_required
252 | @view_required
253 | def list_instances_data() -> Response:
    |     ^^^^^^^^^^^^^^^^^^^
254 |     """Grid.js 实例列表 API.
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/routes/instances/manage.py:402:13
    |
400 |           items = []
401 |           for instance in pagination.items:
402 | /             items.append(
403 | |                 {
404 | |                     "id": instance.id,
405 | |                     "name": instance.name,
406 | |                     "db_type": instance.db_type,
407 | |                     "host": instance.host,
408 | |                     "port": instance.port,
409 | |                     "description": instance.description or "",
410 | |                     "is_active": instance.is_active,
411 | |                     "main_version": instance.main_version,
412 | |                     "active_db_count": active_database_counts.get(instance.id, 0),
413 | |                     "active_account_count": active_account_counts.get(instance.id, 0),
414 | |                     "last_sync_time": (
415 | |                         last_sync_times.get(instance.id).isoformat()
416 | |                         if last_sync_times.get(instance.id)
417 | |                         else None
418 | |                     ),
419 | |                     "tags": tags_map.get(instance.id, []),
420 | |                 },
421 | |             )
    | |_____________^
422 |
423 |           return jsonify_unified_success(
    |
help: Replace for loop with list comprehension

PLC0415 `import` should be at the top-level of a file
   --> app/routes/instances/manage.py:614:5
    |
612 |   def _load_related_blueprints() -> None:
613 |       """确保实例管理相关蓝图被导入注册."""
614 | /     from . import (  # noqa: F401
615 | |         detail,
616 | |         statistics,
617 | |     )
    | |_____^
    |

INP001 File `app/routes/instances/statistics.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/routes/instances/statistics.py:1:1

I001 [*] Import block is un-sorted or un-formatted
  --> app/routes/main.py:4:1
   |
 2 |   """鲸落 - 主要路由."""
 3 |
 4 | / from pathlib import Path
 5 | | from http import HTTPStatus
 6 | |
 7 | | from flask import Blueprint, Response, current_app, redirect, render_template, request, send_from_directory, url_for
 8 | |
 9 | | from app.utils.response_utils import jsonify_unified_success
   | |____________________________________________________________^
10 |
11 |   # 创建蓝图
   |
help: Organize imports

ANN201 Missing return type annotation for public function `partitions_page`
  --> app/routes/partition.py:28:5
   |
26 | @login_required
27 | @view_required
28 | def partitions_page():
   |     ^^^^^^^^^^^^^^^
29 |     """分区管理页面.
   |
help: Add return type annotation

C901 `get_core_aggregation_metrics` is too complex (40 > 10)
   --> app/routes/partition.py:378:5
    |
376 | @login_required
377 | @view_required
378 | def get_core_aggregation_metrics() -> Response:  # noqa: PLR0912, PLR0915
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
379 |     """获取核心聚合指标数据.
    |

E501 Line too long (129 > 120)
   --> app/routes/partition.py:539:121
    |
537 |             for period_key, metrics in period_metrics.items():
538 |                 if metrics["days_in_period"] > 0:
539 |                     daily_metrics[period_key]["instance_count"] = round(metrics["instance_count"] / metrics["days_in_period"], 1)
    |                                                                                                                         ^^^^^^^^^
540 |                     daily_metrics[period_key]["database_count"] = round(metrics["database_count"] / metrics["days_in_period"], 1)
541 |                     daily_metrics[period_key]["instance_aggregation_count"] = metrics["instance_aggregation_count"]
    |

E501 Line too long (129 > 120)
   --> app/routes/partition.py:540:121
    |
538 |                 if metrics["days_in_period"] > 0:
539 |                     daily_metrics[period_key]["instance_count"] = round(metrics["instance_count"] / metrics["days_in_period"], 1)
540 |                     daily_metrics[period_key]["database_count"] = round(metrics["database_count"] / metrics["days_in_period"], 1)
    |                                                                                                                         ^^^^^^^^^
541 |                     daily_metrics[period_key]["instance_aggregation_count"] = metrics["instance_aggregation_count"]
542 |                     daily_metrics[period_key]["database_aggregation_count"] = metrics["database_aggregation_count"]
    |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:8:55
   |
 7 | from flask import Blueprint, Response, render_template
 8 | from flask_login import current_user, login_required  # type: ignore
   |                                                       ^^^^^^^^^^^^^^
 9 |
10 | from app.constants.scheduler_jobs import BUILTIN_TASK_IDS
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:45:95
   |
44 | _scheduler_forms = SchedulerJobFormView.as_view("scheduler_forms")
45 | _scheduler_forms = login_required(scheduler_manage_required(require_csrf(_scheduler_forms)))  # type: ignore
   |                                                                                               ^^^^^^^^^^^^^^
46 | scheduler_bp.add_url_rule(
47 |     "/api/jobs/<job_id>",
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:54:18
   |
53 | @scheduler_bp.route("/")
54 | @login_required  # type: ignore
   |                  ^^^^^^^^^^^^^^
55 | @scheduler_view_required  # type: ignore
56 | def index() -> str:
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:55:27
   |
53 | @scheduler_bp.route("/")
54 | @login_required  # type: ignore
55 | @scheduler_view_required  # type: ignore
   |                           ^^^^^^^^^^^^^^
56 | def index() -> str:
57 |     """定时任务管理页面.
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:69:18
   |
68 | @scheduler_bp.route("/api/jobs")
69 | @login_required  # type: ignore
   |                  ^^^^^^^^^^^^^^
70 | @scheduler_view_required  # type: ignore
71 | def get_jobs() -> Response:
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:70:27
   |
68 | @scheduler_bp.route("/api/jobs")
69 | @login_required  # type: ignore
70 | @scheduler_view_required  # type: ignore
   |                           ^^^^^^^^^^^^^^
71 | def get_jobs() -> Response:
72 |     """获取所有定时任务.
   |

C901 `get_jobs` is too complex (31 > 10)
  --> app/routes/scheduler.py:71:5
   |
69 | @login_required  # type: ignore
70 | @scheduler_view_required  # type: ignore
71 | def get_jobs() -> Response:
   |     ^^^^^^^^
72 |     """获取所有定时任务.
   |

PLR0912 Too many branches (33 > 12)
  --> app/routes/scheduler.py:71:5
   |
69 | @login_required  # type: ignore
70 | @scheduler_view_required  # type: ignore
71 | def get_jobs() -> Response:
   |     ^^^^^^^^
72 |     """获取所有定时任务.
   |

PLR0915 Too many statements (117 > 50)
  --> app/routes/scheduler.py:71:5
   |
69 | @login_required  # type: ignore
70 | @scheduler_view_required  # type: ignore
71 | def get_jobs() -> Response:
   |     ^^^^^^^^
72 |     """获取所有定时任务.
   |

PGH003 Use specific rule codes when ignoring type issues
  --> app/routes/scheduler.py:84:38
   |
82 |     """
83 |     try:
84 |         scheduler = get_scheduler()  # type: ignore
   |                                      ^^^^^^^^^^^^^^
85 |         if not scheduler.running:
86 |             log_warning("调度器未启动", module="scheduler")
   |

TRY301 Abstract `raise` to an inner function
  --> app/routes/scheduler.py:88:13
   |
86 |             log_warning("调度器未启动", module="scheduler")
87 |             msg = "调度器未启动"
88 |             raise SystemError(msg)
   |             ^^^^^^^^^^^^^^^^^^^^^^
89 |         jobs = scheduler.get_jobs()
90 |         jobs_data: list[dict[str, Any]] = []
   |

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   --> app/routes/scheduler.py:126:43
    |
124 |                         # 如果是列表,直接使用字段值
125 |                         # 按时间顺序生成trigger_args:秒、分、时、日、月、周、年
126 |                         if len(fields) >= 8:
    |                                           ^
127 |                             trigger_args["second"] = str(fields[7]) if fields[7] is not None else "0"
128 |                             trigger_args["minute"] = str(fields[6]) if fields[6] is not None else "0"
    |

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   --> app/routes/scheduler.py:177:43
    |
175 |                     elif isinstance(fields, list):
176 |                         # 如果是列表,直接使用字段值,按时间顺序排序:秒、分、时、日、月、周、年
177 |                         if len(fields) >= 8:
    |                                           ^
178 |                             # 按时间顺序添加非默认值
179 |                             if str(fields[7]) != "0":  # second
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:196:20
    |
194 |                     # 对于其他类型的触发器,使用原始字符串
195 |                     trigger_args = {"description": str(job.trigger)}
196 |             except Exception as job_error:
    |                    ^^^^^^^^^
197 |                 log_error(
198 |                     "处理任务触发器信息失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:214:17
    |
212 |             last_run_time = None
213 |             try:
214 |                 from datetime import timedelta
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
215 |
216 |                 from app.models.unified_log import UnifiedLog
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:216:17
    |
214 |                 from datetime import timedelta
215 |
216 |                 from app.models.unified_log import UnifiedLog
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
217 |                 from app.utils.time_utils import time_utils
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:217:17
    |
216 |                 from app.models.unified_log import UnifiedLog
217 |                 from app.utils.time_utils import time_utils
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
218 |
219 |                 # 查找最近24小时内该任务的执行日志
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:228:20
    |
226 |                 if recent_logs:
227 |                     last_run_time = recent_logs.timestamp.isoformat()
228 |             except Exception as lookup_error:
    |                    ^^^^^^^^^
229 |                 log_warning(
230 |                     "获取任务上次运行时间失败",
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:271:18
    |
270 | @scheduler_bp.route("/api/jobs/<job_id>")
271 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
272 | @scheduler_view_required  # type: ignore
273 | def get_job(job_id: str) -> Response:
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:272:27
    |
270 | @scheduler_bp.route("/api/jobs/<job_id>")
271 | @login_required  # type: ignore
272 | @scheduler_view_required  # type: ignore
    |                           ^^^^^^^^^^^^^^
273 | def get_job(job_id: str) -> Response:
274 |     """获取指定任务详情.
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:284:48
    |
282 |     """
283 |     try:
284 |         job = get_scheduler().get_job(job_id)  # type: ignore
    |                                                ^^^^^^^^^^^^^^
285 |         if not job:
286 |             msg = "任务不存在"
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/scheduler.py:287:13
    |
285 |         if not job:
286 |             msg = "任务不存在"
287 |             raise NotFoundError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
288 |
289 |         job_info = {
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:318:18
    |
317 | @scheduler_bp.route("/api/jobs/<job_id>/pause", methods=["POST"])
318 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
319 | @scheduler_manage_required  # type: ignore
320 | @require_csrf
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:319:29
    |
317 | @scheduler_bp.route("/api/jobs/<job_id>/pause", methods=["POST"])
318 | @login_required  # type: ignore
319 | @scheduler_manage_required  # type: ignore
    |                             ^^^^^^^^^^^^^^
320 | @require_csrf
321 | def pause_job(job_id: str) -> Response:
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:332:44
    |
330 |     """
331 |     try:
332 |         get_scheduler().pause_job(job_id)  # type: ignore
    |                                            ^^^^^^^^^^^^^^
333 |         log_info("任务暂停成功", module="scheduler", job_id=job_id)
334 |         return jsonify_unified_success(message="任务暂停成功")
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:343:18
    |
342 | @scheduler_bp.route("/api/jobs/<job_id>/resume", methods=["POST"])
343 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
344 | @scheduler_manage_required  # type: ignore
345 | @require_csrf
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:344:29
    |
342 | @scheduler_bp.route("/api/jobs/<job_id>/resume", methods=["POST"])
343 | @login_required  # type: ignore
344 | @scheduler_manage_required  # type: ignore
    |                             ^^^^^^^^^^^^^^
345 | @require_csrf
346 | def resume_job(job_id: str) -> Response:
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:357:45
    |
355 |     """
356 |     try:
357 |         get_scheduler().resume_job(job_id)  # type: ignore
    |                                             ^^^^^^^^^^^^^^
358 |         log_info("任务恢复成功", module="scheduler", job_id=job_id)
359 |         return jsonify_unified_success(message="任务恢复成功")
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:368:18
    |
367 | @scheduler_bp.route("/api/jobs/<job_id>/run", methods=["POST"])
368 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
369 | @scheduler_manage_required  # type: ignore
370 | @require_csrf
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:369:29
    |
367 | @scheduler_bp.route("/api/jobs/<job_id>/run", methods=["POST"])
368 | @login_required  # type: ignore
369 | @scheduler_manage_required  # type: ignore
    |                             ^^^^^^^^^^^^^^
370 | @require_csrf
371 | def run_job(job_id: str) -> Response:
    |

C901 `run_job` is too complex (12 > 10)
   --> app/routes/scheduler.py:371:5
    |
369 | @scheduler_manage_required  # type: ignore
370 | @require_csrf
371 | def run_job(job_id: str) -> Response:
    |     ^^^^^^^
372 |     """立即执行任务.
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:385:38
    |
383 |     """
384 |     try:
385 |         scheduler = get_scheduler()  # type: ignore
    |                                      ^^^^^^^^^^^^^^
386 |         if not scheduler.running:
387 |             log_warning("调度器未启动", module="scheduler")
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/scheduler.py:389:13
    |
387 |             log_warning("调度器未启动", module="scheduler")
388 |             msg = "调度器未启动"
389 |             raise SystemError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^
390 |
391 |         job = scheduler.get_job(job_id)
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/scheduler.py:394:13
    |
392 |         if not job:
393 |             msg = "任务不存在"
394 |             raise NotFoundError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^^^
395 |
396 |         log_info("开始立即执行任务", module="scheduler", job_id=job_id, job_name=job.name)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:403:16
    |
401 |         try:
402 |             user_is_authenticated = current_user.is_authenticated  # type: ignore[attr-defined]
403 |         except Exception:  # pragma: no cover - 防御性捕获
    |                ^^^^^^^^^
404 |             user_is_authenticated = False
405 |         if user_is_authenticated:
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:418:25
    |
416 |                         job.func(*job.args, **manual_kwargs)
417 |                     else:
418 |                         from app import create_app
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^
419 |
420 |                         app = create_app(init_scheduler_on_start=False)  # type: ignore
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:420:74
    |
418 |                         from app import create_app
419 |
420 |                         app = create_app(init_scheduler_on_start=False)  # type: ignore
    |                                                                          ^^^^^^^^^^^^^^
421 |                         with app.app_context():
422 |                             job.func(*job.args, **(job.kwargs or {}))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:430:24
    |
428 |                         job_name=job.name,
429 |                     )
430 |                 except Exception as func_error:  # pragma: no cover - 防御性日志
    |                        ^^^^^^^^^
431 |                     log_error(
432 |                         "任务函数执行失败",
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:471:18
    |
470 | @scheduler_bp.route("/api/jobs/reload", methods=["POST"])
471 | @login_required  # type: ignore
    |                  ^^^^^^^^^^^^^^
472 | @scheduler_manage_required  # type: ignore
473 | @require_csrf
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:472:29
    |
470 | @scheduler_bp.route("/api/jobs/reload", methods=["POST"])
471 | @login_required  # type: ignore
472 | @scheduler_manage_required  # type: ignore
    |                             ^^^^^^^^^^^^^^
473 | @require_csrf
474 | def reload_jobs() -> Response:
    |

PGH003 Use specific rule codes when ignoring type issues
   --> app/routes/scheduler.py:484:38
    |
482 |     """
483 |     try:
484 |         scheduler = get_scheduler()  # type: ignore
    |                                      ^^^^^^^^^^^^^^
485 |         if not scheduler.running:
486 |             log_warning("调度器未启动", module="scheduler")
    |

TRY301 Abstract `raise` to an inner function
   --> app/routes/scheduler.py:488:13
    |
486 |             log_warning("调度器未启动", module="scheduler")
487 |             msg = "调度器未启动"
488 |             raise SystemError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^^
489 |
490 |         # 获取现有任务列表
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/scheduler.py:501:20
    |
499 |                 deleted_count += 1
500 |                 log_info("重新加载-删除任务", module="scheduler", job_id=job_id)
501 |             except Exception as del_err:
    |                    ^^^^^^^^^
502 |                 log_error(
503 |                     "重新加载-删除任务失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/routes/scheduler.py:510:9
    |
509 |         # 重新加载任务配置
510 |         from app.scheduler import _reload_all_jobs
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
511 |         _reload_all_jobs()
    |

D104 Missing docstring in public package
--> app/routes/tags/__init__.py:1:1

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/tags/manage.py:201:12
    |
199 |         return redirect(url_for("tags.index"))
200 |
201 |     except Exception as e:
    |            ^^^^^^^^^
202 |         db.session.rollback()
203 |         log_error(
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/routes/tags/manage.py:264:16
    |
262 |             _delete_tag_record(tag, operator_id=operator_id)
263 |             results.append({"tag_id": tag_id, "status": "deleted"})
264 |         except Exception as exc:
    |                ^^^^^^^^^
265 |             db.session.rollback()
266 |             has_failure = True
    |

BLE001 Do not catch blind exception: `Exception`
  --> app/routes/users.py:60:12
   |
58 |         )
59 |
60 |     except Exception as e:
   |            ^^^^^^^^^
61 |         log_error(
62 |             "加载用户管理页面失败",
   |

D205 1 blank line required between summary line and description
 --> app/scheduler.py:1:1
  |
1 | / """鲸落定时任务调度器
2 | | 使用APScheduler实现轻量级定时任务.
3 | | """
  | |___^
4 |
5 |   import atexit
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/scheduler.py:40:9
   |
38 |     """定时任务调度器."""
39 |
40 |     def __init__(self, app: Any = None) -> None:
   |         ^^^^^^^^
41 |         self.app = app
42 |         self.scheduler = None
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `app`
  --> app/scheduler.py:40:29
   |
38 |     """定时任务调度器."""
39 |
40 |     def __init__(self, app: Any = None) -> None:
   |                             ^^^
41 |         self.app = app
42 |         self.scheduler = None
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `event`
  --> app/scheduler.py:89:36
   |
87 |         self.scheduler.add_listener(self._job_error, EVENT_JOB_ERROR)
88 |
89 |     def _job_executed(self, event: Any) -> None:
   |                                    ^^^
90 |         """处理任务成功事件.
   |

G004 Logging statement uses f-string
   --> app/scheduler.py:99:21
    |
 98 |         """
 99 |         logger.info(f"任务执行成功: {event.job_id} - {event.retval}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
100 |
101 |     def _job_error(self, event: Any) -> None:
    |
help: Convert to lazy `%` formatting

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `event`
   --> app/scheduler.py:101:33
    |
 99 |         logger.info(f"任务执行成功: {event.job_id} - {event.retval}")
100 |
101 |     def _job_error(self, event: Any) -> None:
    |                                 ^^^
102 |         """处理任务失败事件.
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:112:22
    |
110 |         """
111 |         exception_str = str(event.exception) if event.exception else "未知错误"
112 |         logger.error(f"任务执行失败: {event.job_id} - {exception_str}")
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
113 |
114 |     def start(self) -> None:
    |
help: Convert to lazy `%` formatting

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/scheduler.py:138:29
    |
136 |             logger.info("定时任务调度器已停止")
137 |
138 |     def add_job(self, func: Any, trigger: Any, **kwargs: Any) -> Any:
    |                             ^^^
139 |         """向调度器注册任务.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `trigger`
   --> app/scheduler.py:138:43
    |
136 |             logger.info("定时任务调度器已停止")
137 |
138 |     def add_job(self, func: Any, trigger: Any, **kwargs: Any) -> Any:
    |                                           ^^^
139 |         """向调度器注册任务.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/scheduler.py:138:58
    |
136 |             logger.info("定时任务调度器已停止")
137 |
138 |     def add_job(self, func: Any, trigger: Any, **kwargs: Any) -> Any:
    |                                                          ^^^
139 |         """向调度器注册任务.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `add_job`
   --> app/scheduler.py:138:66
    |
136 |             logger.info("定时任务调度器已停止")
137 |
138 |     def add_job(self, func: Any, trigger: Any, **kwargs: Any) -> Any:
    |                                                                  ^^^
139 |         """向调度器注册任务.
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:164:25
    |
162 |         try:
163 |             self.scheduler.remove_job(job_id)
164 |             logger.info(f"任务已删除: {job_id}")
    |                         ^^^^^^^^^^^^^^^^^^^^^^^
165 |         except Exception as exc:
166 |             logger.exception(
    |
help: Convert to lazy `%` formatting

F841 [*] Local variable `exc` is assigned to but never used
   --> app/scheduler.py:165:29
    |
163 |             self.scheduler.remove_job(job_id)
164 |             logger.info(f"任务已删除: {job_id}")
165 |         except Exception as exc:
    |                             ^^^
166 |             logger.exception(
167 |                 "删除任务失败",
    |
help: Remove assignment to unused variable `exc`

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get_job`
   --> app/scheduler.py:180:39
    |
178 |         return self.scheduler.get_jobs()
179 |
180 |     def get_job(self, job_id: str) -> Any:
    |                                       ^^^
181 |         """获取指定任务.
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:203:21
    |
201 |         """
202 |         self.scheduler.pause_job(job_id)
203 |         logger.info(f"任务已暂停: {job_id}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^
204 |
205 |     def resume_job(self, job_id: str) -> None:
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:216:21
    |
214 |         """
215 |         self.scheduler.resume_job(job_id)
216 |         logger.info(f"任务已恢复: {job_id}")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^
    |
help: Convert to lazy `%` formatting

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get_scheduler`
   --> app/scheduler.py:224:24
    |
223 | # 确保scheduler实例可以被正确访问
224 | def get_scheduler() -> Any:
    |                        ^^^
225 |     """获取底层 APScheduler 实例.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/scheduler.py:253:16
    |
251 |         try:  # pragma: no cover - 防御性释放
252 |             _LOCK_STATE.handle.close()
253 |         except Exception as close_error:
    |                ^^^^^^^^^
254 |             logger.warning("继承的调度器锁句柄关闭失败", error=str(close_error))
255 |         _LOCK_STATE.handle = None
    |

TRY300 Consider moving this statement to an `else` block
   --> app/scheduler.py:271:9
    |
269 |         _LOCK_STATE.pid = current_pid
270 |         logger.info("调度器锁已获取,当前进程负责运行定时任务", pid=os.getpid())
271 |         return True
    |         ^^^^^^^^^^^
272 |     except BlockingIOError:
273 |         handle.close()
    |

F841 [*] Local variable `exc` is assigned to but never used
   --> app/scheduler.py:276:25
    |
274 |         logger.info("检测到其他进程正在运行调度器,跳过当前进程的调度器初始化")
275 |         return False
276 |     except Exception as exc:  # pragma: no cover - 极端情况
    |                         ^^^
277 |         handle.close()
278 |         logger.exception("获取调度器锁失败")
    |
help: Remove assignment to unused variable `exc`

BLE001 Do not catch blind exception: `Exception`
   --> app/scheduler.py:293:12
    |
291 |     try:  # pragma: no cover
292 |         fcntl.flock(_LOCK_STATE.handle, fcntl.LOCK_UN)
293 |     except Exception as unlock_error:
    |            ^^^^^^^^^
294 |         logger.warning("释放调度器文件锁失败", error=str(unlock_error))
295 |     try:  # pragma: no cover
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/scheduler.py:297:12
    |
295 |     try:  # pragma: no cover
296 |         _LOCK_STATE.handle.close()
297 |     except Exception as close_error:
    |            ^^^^^^^^^
298 |         logger.warning("关闭调度器锁文件失败", error=str(close_error))
299 |     finally:
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:316:21
    |
314 |     enable_flag = os.environ.get("ENABLE_SCHEDULER", "true").strip().lower()
315 |     if enable_flag not in ("true", "1", "yes"):
316 |         logger.info(f"检测到 ENABLE_SCHEDULER={enable_flag},跳过调度器初始化")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
317 |         return False
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:322:21
    |
320 |     if server_software.startswith("gunicorn"):
321 |         parent_pid = os.getppid()
322 |         logger.info(f"检测到 gunicorn 环境,ppid={parent_pid},将通过文件锁保证单实例")
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
323 |
324 |     # Flask reloader: 只有子进程 (WERKZEUG_RUN_MAIN=true) 才运行调度器
    |
help: Convert to lazy `%` formatting

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `app`
   --> app/scheduler.py:334:25
    |
334 | def init_scheduler(app: Any) -> None:
    |                         ^^^
335 |     """初始化调度器(仅在允许的进程中启动).
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:368:9
    |
367 |         # 等待调度器完全启动
368 |         import time
    |         ^^^^^^^^^^^
369 |         time.sleep(2)
    |

TRY300 Consider moving this statement to an `else` block
   --> app/scheduler.py:378:9
    |
377 |         logger.info("调度器初始化完成")
378 |         return scheduler
    |         ^^^^^^^^^^^^^^^^
379 |     except Exception as exc:
380 |         logger.exception("调度器初始化失败")
    |

F841 [*] Local variable `exc` is assigned to but never used
   --> app/scheduler.py:379:25
    |
377 |         logger.info("调度器初始化完成")
378 |         return scheduler
379 |     except Exception as exc:
    |                         ^^^
380 |         logger.exception("调度器初始化失败")
381 |         # 不抛出异常,让应用继续启动
    |
help: Remove assignment to unused variable `exc`

G004 Logging statement uses f-string
   --> app/scheduler.py:413:29
    |
411 |             existing_jobs = scheduler.get_jobs()
412 |             if existing_jobs:
413 |                 logger.info(f"从SQLite数据库加载了 {len(existing_jobs)} 个现有任务")
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
414 |                 for job in existing_jobs:
415 |                     logger.info(f"加载任务: {job.name} ({job.id})")
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:415:33
    |
413 |                 logger.info(f"从SQLite数据库加载了 {len(existing_jobs)} 个现有任务")
414 |                 for job in existing_jobs:
415 |                     logger.info(f"加载任务: {job.name} ({job.id})")
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
416 |             else:
417 |                 logger.info("SQLite数据库中没有找到任务")
    |
help: Convert to lazy `%` formatting

F841 [*] Local variable `exc` is assigned to but never used
   --> app/scheduler.py:421:29
    |
419 |             logger.warning("加载任务时被中断,跳过加载现有任务")
420 |             return
421 |         except Exception as exc:
    |                             ^^^
422 |             logger.exception("获取任务列表失败")
423 |             return
    |
help: Remove assignment to unused variable `exc`

F841 [*] Local variable `exc` is assigned to but never used
   --> app/scheduler.py:424:25
    |
422 |             logger.exception("获取任务列表失败")
423 |             return
424 |     except Exception as exc:
    |                         ^^^
425 |         logger.exception("加载现有任务失败")
426 |         # 不抛出异常,让应用继续启动
    |
help: Remove assignment to unused variable `exc`

C901 `_load_tasks_from_config` is too complex (22 > 10)
   --> app/scheduler.py:449:5
    |
449 | def _load_tasks_from_config(*, force: bool = False) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^
450 |     """从配置文件加载默认任务并注册.
    |

PLR0912 Too many branches (23 > 12)
   --> app/scheduler.py:449:5
    |
449 | def _load_tasks_from_config(*, force: bool = False) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^
450 |     """从配置文件加载默认任务并注册.
    |

PLR0915 Too many statements (75 > 50)
   --> app/scheduler.py:449:5
    |
449 | def _load_tasks_from_config(*, force: bool = False) -> None:
    |     ^^^^^^^^^^^^^^^^^^^^^^^
450 |     """从配置文件加载默认任务并注册.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:459:5
    |
458 |     """
459 |     import yaml
    |     ^^^^^^^^^^^
460 |
461 |     from app.tasks.accounts_sync_tasks import sync_accounts
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:461:5
    |
459 |     import yaml
460 |
461 |     from app.tasks.accounts_sync_tasks import sync_accounts
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
462 |     from app.tasks.capacity_aggregation_tasks import calculate_database_size_aggregations
463 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:462:5
    |
461 |     from app.tasks.accounts_sync_tasks import sync_accounts
462 |     from app.tasks.capacity_aggregation_tasks import calculate_database_size_aggregations
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
463 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
464 |     from app.tasks.log_cleanup_tasks import cleanup_old_logs
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:463:5
    |
461 |     from app.tasks.accounts_sync_tasks import sync_accounts
462 |     from app.tasks.capacity_aggregation_tasks import calculate_database_size_aggregations
463 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
464 |     from app.tasks.log_cleanup_tasks import cleanup_old_logs
465 |     from app.tasks.partition_management_tasks import monitor_partition_health
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:464:5
    |
462 |     from app.tasks.capacity_aggregation_tasks import calculate_database_size_aggregations
463 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
464 |     from app.tasks.log_cleanup_tasks import cleanup_old_logs
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
465 |     from app.tasks.partition_management_tasks import monitor_partition_health
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:465:5
    |
463 |     from app.tasks.capacity_collection_tasks import collect_database_sizes
464 |     from app.tasks.log_cleanup_tasks import cleanup_old_logs
465 |     from app.tasks.partition_management_tasks import monitor_partition_health
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
466 |
467 |     # 如果不是强制模式,检查是否已有任务
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:472:29
    |
470 |             existing_jobs = scheduler.get_jobs()
471 |             if existing_jobs:
472 |                 logger.info(f"发现 {len(existing_jobs)} 个现有任务,跳过创建默认任务")
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
473 |                 return
474 |         except KeyboardInterrupt:
    |
help: Convert to lazy `%` formatting

F841 [*] Local variable `exc` is assigned to but never used
   --> app/scheduler.py:477:29
    |
475 |             logger.warning("检查现有任务时被中断,跳过创建默认任务")
476 |             return
477 |         except Exception as exc:
    |                             ^^^
478 |             logger.exception("检查现有任务失败")
479 |             return
    |
help: Remove assignment to unused variable `exc`

G004 Logging statement uses f-string
   --> app/scheduler.py:511:32
    |
509 |             func = task_func_map.get(function_name)
510 |             if not func:
511 |                 logger.warning(f"未知的任务函数: {function_name}")
    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
512 |                 continue
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:520:37
    |
518 |                     try:
519 |                         scheduler.remove_job(task_id)
520 |                         logger.info(f"强制模式-删除现有任务: {task_name} ({task_id})")
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
521 |                     except Exception as remove_error:
522 |                         logger.warning(
    |
help: Convert to lazy `%` formatting

BLE001 Do not catch blind exception: `Exception`
   --> app/scheduler.py:521:28
    |
519 |                         scheduler.remove_job(task_id)
520 |                         logger.info(f"强制模式-删除现有任务: {task_name} ({task_id})")
521 |                     except Exception as remove_error:
    |                            ^^^^^^^^^
522 |                         logger.warning(
523 |                             "强制模式-删除现有任务失败",
    |

PLC0415 `import` should be at the top-level of a file
   --> app/scheduler.py:531:21
    |
529 |                 # 对于cron触发器,确保使用正确的时区
530 |                 if trigger_type == "cron":
531 |                     from apscheduler.triggers.cron import CronTrigger
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
532 |                     # 只传递实际配置的字段,避免APScheduler自动填充默认值
533 |                     cron_kwargs = {}
    |

G004 Logging statement uses f-string
   --> app/scheduler.py:565:29
    |
563 |                         **trigger_params,
564 |                     )
565 |                 logger.info(f"添加任务: {task_name} ({task_id})")
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
566 |             except Exception as exc:
567 |                 if force:
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/scheduler.py:574:36
    |
572 |                     )
573 |                 else:
574 |                     logger.warning(f"任务已存在,跳过创建: {task_name} ({task_id}) - {exc}")
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
575 |
576 |     except FileNotFoundError:
    |
help: Convert to lazy `%` formatting

F841 [*] Local variable `exc` is assigned to but never used
   --> app/scheduler.py:579:25
    |
577 |         logger.exception("配置文件不存在,无法加载默认任务", config_file=str(config_file))
578 |         return
579 |     except Exception as exc:
    |                         ^^^
580 |         logger.exception("读取配置文件失败")
581 |         return
    |
help: Remove assignment to unused variable `exc`

D107 Missing docstring in `__init__`
  --> app/services/account_classification/auto_classify_service.py:68:9
   |
66 |     """
67 |
68 |     def __init__(self, classification_service: AccountClassificationService | None = None) -> None:
   |         ^^^^^^^^
69 |         self.classification_service = classification_service or AccountClassificationService()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance_id`
  --> app/services/account_classification/auto_classify_service.py:74:22
   |
72 |         self,
73 |         *,
74 |         instance_id: Any,
   |                      ^^^
75 |         created_by: int | None,
76 |         use_optimized: Any = True,
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `use_optimized`
  --> app/services/account_classification/auto_classify_service.py:76:24
   |
74 |         instance_id: Any,
75 |         created_by: int | None,
76 |         use_optimized: Any = True,
   |                        ^^^
77 |     ) -> AutoClassifyResult:
78 |         """执行账户自动分类.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/account_classification/auto_classify_service.py:186:24
    |
185 |     @staticmethod
186 |     def _as_int(value: Any) -> int:
    |                        ^^^
187 |         """安全地将输入转换为整数.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `raw_value`
   --> app/services/account_classification/auto_classify_service.py:201:49
    |
199 |             return 0
200 |
201 |     def _normalize_instance_id(self, raw_value: Any) -> int | None:
    |                                                 ^^^
202 |         """规范化实例 ID.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/account_classification/auto_classify_service.py:225:35
    |
223 |             raise AutoClassifyError(msg) from exc
224 |
225 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
226 |         """将输入值转换为布尔型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `errors`
   --> app/services/account_classification/auto_classify_service.py:257:35
    |
256 |     @staticmethod
257 |     def _normalize_errors(errors: Any) -> list[str]:
    |                                   ^^^
258 |         """规范化错误结构为字符串列表.
    |

D107 Missing docstring in `__init__`
  --> app/services/account_classification/cache.py:17:9
   |
15 |     """针对分类业务封装的缓存访问器."""
16 |
17 |     def __init__(self, manager: Any | None = None) -> None:
   |         ^^^^^^^^
18 |         self.manager = manager or cache_manager
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `manager`
  --> app/services/account_classification/cache.py:17:33
   |
15 |     """针对分类业务封装的缓存访问器."""
16 |
17 |     def __init__(self, manager: Any | None = None) -> None:
   |                                 ^^^^^^^^^^
18 |         self.manager = manager or cache_manager
   |

C901 `evaluate` is too complex (41 > 10)
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:9
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

PLR0911 Too many return statements (10 > 6)
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:9
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

PLR0912 Too many branches (43 > 12)
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:9
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

PLR0915 Too many statements (85 > 50)
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:9
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

ANN001 Missing type annotation for function argument `account`
  --> app/services/account_classification/classifiers/mysql_classifier.py:38:24
   |
36 |     db_type = "mysql"
37 |
38 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |                        ^^^^^^^
39 |         """评估账户是否满足 MySQL 规则表达式.
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/account_classification/classifiers/mysql_classifier.py:170:13
    |
168 |                     return False
169 |
170 |             return True
    |             ^^^^^^^^^^^
171 |         except Exception as exc:
172 |             log_error("评估MySQL规则失败", module="account_classification", error=str(exc))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/classifiers/mysql_classifier.py:171:16
    |
170 |             return True
171 |         except Exception as exc:
    |                ^^^^^^^^^
172 |             log_error("评估MySQL规则失败", module="account_classification", error=str(exc))
173 |             return False
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `perms`
   --> app/services/account_classification/classifiers/mysql_classifier.py:176:36
    |
175 |     @staticmethod
176 |     def _extract_perm_names(perms: Any) -> set[str]:
    |                                    ^^^
177 |         """从权限数据中提取权限名称集合.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `requirement`
   --> app/services/account_classification/classifiers/mysql_classifier.py:200:48
    |
199 |     @staticmethod
200 |     def _normalize_db_requirement(requirement: Any) -> dict[str, Any] | None:
    |                                                ^^^
201 |         """规范化数据库权限要求.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `requirement`
   --> app/services/account_classification/classifiers/mysql_classifier.py:217:51
    |
216 |     @staticmethod
217 |     def _normalize_table_requirement(requirement: Any) -> dict[str, Any] | None:
    |                                                   ^^^
218 |         """规范化表权限要求.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/account_classification/classifiers/mysql_classifier.py:234:29
    |
233 |     @staticmethod
234 |     def _ensure_list(value: Any) -> list[str]:
    |                             ^^^
235 |         """确保值为列表格式.
    |

C901 `evaluate` is too complex (15 > 10)
  --> app/services/account_classification/classifiers/oracle_classifier.py:36:9
   |
34 |     db_type = "oracle"
35 |
36 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
37 |         """评估账户是否满足 Oracle 规则表达式.
   |

PLR0912 Too many branches (14 > 12)
  --> app/services/account_classification/classifiers/oracle_classifier.py:36:9
   |
34 |     db_type = "oracle"
35 |
36 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
37 |         """评估账户是否满足 Oracle 规则表达式.
   |

ANN001 Missing type annotation for function argument `account`
  --> app/services/account_classification/classifiers/oracle_classifier.py:36:24
   |
34 |     db_type = "oracle"
35 |
36 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |                        ^^^^^^^
37 |         """评估账户是否满足 Oracle 规则表达式.
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/classifiers/oracle_classifier.py:138:16
    |
137 |             return self._combine_results(match_results, operator)
138 |         except Exception as exc:
    |                ^^^^^^^^^
139 |             log_error("评估Oracle规则失败", module="account_classification", error=str(exc))
140 |             return False
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `source`
   --> app/services/account_classification/classifiers/oracle_classifier.py:161:50
    |
160 |     @staticmethod
161 |     def _normalize_tablespace_privileges(source: Any) -> list[dict[str, Any]]:
    |                                                  ^^^
162 |         """支持 dict/list 两种结构的表空间权限.
    |

PERF401 Use `list.extend` to create a transformed list
   --> app/services/account_classification/classifiers/oracle_classifier.py:176:21
    |
174 |                   perms = privileges if isinstance(privileges, list) else [privileges]
175 |                   for privilege in perms:
176 | /                     normalized.append(
177 | |                         {
178 | |                             "tablespace_name": tablespace_name,
179 | |                             "privilege": privilege,
180 | |                         },
181 | |                     )
    | |_____________________^
182 |           elif isinstance(source, list):
183 |               normalized = [item for item in source if isinstance(item, dict)]
    |
help: Replace for loop with list.extend

C901 `evaluate` is too complex (11 > 10)
  --> app/services/account_classification/classifiers/postgresql_classifier.py:37:9
   |
35 |     db_type = "postgresql"
36 |
37 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
38 |         """评估账户是否满足 PostgreSQL 规则表达式.
   |

ANN001 Missing type annotation for function argument `account`
  --> app/services/account_classification/classifiers/postgresql_classifier.py:37:24
   |
35 |     db_type = "postgresql"
36 |
37 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |                        ^^^^^^^
38 |         """评估账户是否满足 PostgreSQL 规则表达式.
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/classifiers/postgresql_classifier.py:105:16
    |
104 |             return self._combine_results(match_results, operator)
105 |         except Exception as exc:
    |                ^^^^^^^^^
106 |             log_error("评估PostgreSQL规则失败", module="account_classification", error=str(exc))
107 |             return False
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `perms`
   --> app/services/account_classification/classifiers/postgresql_classifier.py:110:36
    |
109 |     @staticmethod
110 |     def _extract_priv_names(perms: Any) -> set[str]:
    |                                    ^^^
111 |         """提取权限名称集合.
    |

C901 `evaluate` is too complex (11 > 10)
  --> app/services/account_classification/classifiers/sqlserver_classifier.py:37:9
   |
35 |     db_type = "sqlserver"
36 |
37 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |         ^^^^^^^^
38 |         """评估账户是否满足 SQL Server 规则表达式.
   |

ANN001 Missing type annotation for function argument `account`
  --> app/services/account_classification/classifiers/sqlserver_classifier.py:37:24
   |
35 |     db_type = "sqlserver"
36 |
37 |     def evaluate(self, account, rule_expression: dict[str, Any]) -> bool:
   |                        ^^^^^^^
38 |         """评估账户是否满足 SQL Server 规则表达式.
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/classifiers/sqlserver_classifier.py:115:16
    |
114 |             return self._combine_results(match_results, operator)
115 |         except Exception as exc:
    |                ^^^^^^^^^
116 |             log_error("评估SQL Server规则失败", module="account_classification", error=str(exc))
117 |             return False
    |

D107 Missing docstring in `__init__`
  --> app/services/account_classification/orchestrator.py:32:9
   |
30 |     """
31 |
32 |     def __init__(
   |         ^^^^^^^^
33 |         self,
34 |         repository: ClassificationRepository | None = None,
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/account_classification/orchestrator.py:87:13
   |
85 |             )
86 |
87 |             return {"success": True, "message": "自动分类完成", **result}
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
88 |         except Exception as exc:
89 |             log_error("优化后的自动分类失败", module="account_classification", error=str(exc))
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/account_classification/orchestrator.py:88:16
   |
87 |             return {"success": True, "message": "自动分类完成", **result}
88 |         except Exception as exc:
   |                ^^^^^^^^^
89 |             log_error("优化后的自动分类失败", module="account_classification", error=str(exc))
90 |             return {"success": False, "error": f"自动分类失败: {exc}"}
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/orchestrator.py:101:16
    |
 99 |         try:
100 |             return self.cache.invalidate_all()
101 |         except Exception as exc:
    |                ^^^^^^^^^
102 |             log_error("清除分类缓存失败", module="account_classification", error=str(exc))
103 |             return False
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/orchestrator.py:117:16
    |
115 |         try:
116 |             return self.cache.invalidate_db_type(db_type)
117 |         except Exception as exc:
    |                ^^^^^^^^^
118 |             log_error("清除数据库类型缓存失败", module="account_classification", db_type=db_type, error=str(exc))
119 |             return False
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/orchestrator.py:251:20
    |
249 |                 all_errors.extend(result["errors"])
250 |                 db_type_results[db_type] = result
251 |             except Exception as exc:
    |                    ^^^^^^^^^
252 |                 error_msg = f"数据库类型 {db_type} 分类失败: {exc}"
253 |                 log_error(error_msg, module="account_classification")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/orchestrator.py:316:20
    |
314 |                     matched_accounts=len(matched_accounts),
315 |                 )
316 |             except Exception as exc:
    |                    ^^^^^^^^^
317 |                 error_msg = f"规则 {rule.rule_name} 处理失败: {exc}"
318 |                 log_error(error_msg, module="account_classification", rule_id=rule.id, db_type=db_type)
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/services/account_classification/orchestrator.py:355:17
    |
353 |         for account in filtered_accounts:
354 |             if self._evaluate_rule(account, rule):
355 |                 matched_accounts.append(account)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
356 |         return matched_accounts
    |
help: Replace for loop with list comprehension

TRY300 Consider moving this statement to an `else` block
  --> app/services/account_classification/repositories.py:89:13
   |
87 |                 )
88 |             db.session.commit()
89 |             return deleted
   |             ^^^^^^^^^^^^^^
90 |         except Exception as exc:
91 |             db.session.rollback()
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/repositories.py:160:16
    |
159 |             return len(new_assignments)
160 |         except Exception as exc:
    |                ^^^^^^^^^
161 |             log_error(
162 |                 "批量写入分类分配失败",
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/services/account_classification/repositories.py:184:13
    |
182 |           payload: list[dict] = []
183 |           for rule in rules:
184 | /             payload.append(
185 | |                 {
186 | |                     "id": rule.id,
187 | |                     "classification_id": rule.classification_id,
188 | |                     "db_type": rule.db_type,
189 | |                     "rule_name": rule.rule_name,
190 | |                     "rule_expression": rule.rule_expression,
191 | |                     "is_active": rule.is_active,
192 | |                     "created_at": rule.created_at.isoformat() if rule.created_at else None,
193 | |                     "updated_at": rule.updated_at.isoformat() if rule.updated_at else None,
194 | |                 },
195 | |             )
    | |_____________^
196 |           return payload
    |
help: Replace for loop with list comprehension

BLE001 Do not catch blind exception: `Exception`
   --> app/services/account_classification/repositories.py:220:20
    |
218 |                 rule.is_active = data.get("is_active", True)
219 |                 hydrated.append(rule)
220 |             except Exception as exc:
    |                    ^^^^^^^^^
221 |                 log_error("反序列化规则缓存失败", module="account_classification", error=str(exc))
222 |         return hydrated
    |

D205 1 blank line required between summary line and description
 --> app/services/accounts_sync/accounts_sync_filters.py:1:1
  |
1 | / """鲸落 - 数据库过滤规则管理器
2 | | 专门用于数据库账户同步时的过滤规则管理.
3 | | """
  | |___^
4 |
5 |   import re
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/accounts_sync_filters.py:22:9
   |
20 |     """数据库过滤规则管理器."""
21 |
22 |     def __init__(self, config_path: str | Path | None = None) -> None:
   |         ^^^^^^^^
23 |         path_obj = Path(config_path) if config_path else _DEFAULT_CONFIG_PATH
24 |         self.config_file = path_obj
   |

G004 Logging statement uses f-string
  --> app/services/accounts_sync/accounts_sync_filters.py:40:26
   |
38 |         """
39 |         if not self.config_file.exists():
40 |             logger.error(f"账户过滤规则配置文件不存在: {self.config_path_str}")
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
41 |             msg = f"账户过滤规则配置文件不存在: {self.config_path_str}"
42 |             raise FileNotFoundError(msg)
   |
help: Convert to lazy `%` formatting

TRY301 Abstract `raise` to an inner function
  --> app/services/accounts_sync/accounts_sync_filters.py:51:17
   |
49 |                 logger.error("配置文件格式错误,缺少 account_filters 节点")
50 |                 msg = "配置文件格式错误,缺少 account_filters 节点"
51 |                 raise ValueError(msg)
   |                 ^^^^^^^^^^^^^^^^^^^^^
52 |
53 |             filter_rules = config["account_filters"] or {}
   |

G004 Logging statement uses f-string
  --> app/services/accounts_sync/accounts_sync_filters.py:54:25
   |
53 |             filter_rules = config["account_filters"] or {}
54 |             logger.info(f"成功加载账户过滤规则配置文件: {self.config_path_str}")
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
55 |             logger.info(f"加载的数据库类型: {list(filter_rules.keys())}")
   |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
  --> app/services/accounts_sync/accounts_sync_filters.py:55:25
   |
53 |             filter_rules = config["account_filters"] or {}
54 |             logger.info(f"成功加载账户过滤规则配置文件: {self.config_path_str}")
55 |             logger.info(f"加载的数据库类型: {list(filter_rules.keys())}")
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
56 |
57 |             return filter_rules
   |
help: Convert to lazy `%` formatting

TRY300 Consider moving this statement to an `else` block
  --> app/services/accounts_sync/accounts_sync_filters.py:57:13
   |
55 |             logger.info(f"加载的数据库类型: {list(filter_rules.keys())}")
56 |
57 |             return filter_rules
   |             ^^^^^^^^^^^^^^^^^^^
58 |
59 |         except yaml.YAMLError as exc:
   |

F841 [*] Local variable `exc` is assigned to but never used
  --> app/services/accounts_sync/accounts_sync_filters.py:63:29
   |
61 |             msg = f"解析配置文件失败: {exc}"
62 |             raise ValueError(msg) from exc
63 |         except Exception as exc:
   |                             ^^^
64 |             logger.exception("加载过滤规则配置文件失败")
65 |             raise
   |
help: Remove assignment to unused variable `exc`

F841 [*] Local variable `exc` is assigned to but never used
   --> app/services/accounts_sync/accounts_sync_filters.py:98:28
    |
 96 |             regex_pattern = f"^{regex_pattern}$"
 97 |             return bool(re.match(regex_pattern, text, re.IGNORECASE))
 98 |         except re.error as exc:
    |                            ^^^
 99 |             logger.exception(
100 |                 "模式匹配失败",
    |
help: Remove assignment to unused variable `exc`

E501 Line too long (144 > 120)
  --> app/services/accounts_sync/accounts_sync_service.py:95:121
   |
93 | …
94 | …
95 | … SyncOperationType.MANUAL_TASK.value, SyncOperationType.SCHEDULED_TASK.value]:
   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^
96 | …
97 | …
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/accounts_sync_service.py:167:13
    |
165 |                 result=result,
166 |             )
167 |             return result
    |             ^^^^^^^^^^^^^
168 |         except Exception as exc:
169 |             self.sync_logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/accounts_sync_service.py:169:30
    |
167 |             return result
168 |         except Exception as exc:
169 |             self.sync_logger.error(
    |                              ^^^^^
170 |                 "单实例同步失败",
171 |                 module="accounts_sync",
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/accounts_sync_service.py:247:13
    |
245 |                 )
246 |
247 |             return result
    |             ^^^^^^^^^^^^^
248 |
249 |         except Exception as e:
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/accounts_sync_service.py:305:13
    |
303 |                 result=result,
304 |             )
305 |             return result
    |             ^^^^^^^^^^^^^
306 |         except Exception as exc:
307 |             db.session.rollback()
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/accounts_sync_service.py:308:30
    |
306 |         except Exception as exc:
307 |             db.session.rollback()
308 |             self.sync_logger.error(
    |                              ^^^^^
309 |                 "现有会话同步失败",
310 |                 module="accounts_sync",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/base_adapter.py:17:69
   |
15 |     """账户同步适配器基类,负责抽象远端账户数据抓取."""
16 |
17 |     def fetch_remote_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                     ^^^
18 |         """拉取远端账户信息.
   |

PERF401 Use a list comprehension to create a transformed list
  --> app/services/accounts_sync/adapters/base_adapter.py:37:13
   |
35 |         normalized: list[dict[str, Any]] = []
36 |         for account in raw_accounts:
37 |             normalized.append(self._normalize_account(instance, account))
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |         return normalized
   |
help: Replace for loop with list comprehension

ARG002 Unused method argument: `instance`
  --> app/services/accounts_sync/adapters/base_adapter.py:42:9
   |
40 |     def enrich_permissions(
41 |         self,
42 |         instance: Instance,
   |         ^^^^^^^^
43 |         connection: Any,
44 |         accounts: list[dict[str, Any]],
   |

ARG002 Unused method argument: `connection`
  --> app/services/accounts_sync/adapters/base_adapter.py:43:9
   |
41 |         self,
42 |         instance: Instance,
43 |         connection: Any,
   |         ^^^^^^^^^^
44 |         accounts: list[dict[str, Any]],
45 |         *,
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/base_adapter.py:43:21
   |
41 |         self,
42 |         instance: Instance,
43 |         connection: Any,
   |                     ^^^
44 |         accounts: list[dict[str, Any]],
45 |         *,
   |

ARG002 Unused method argument: `usernames`
  --> app/services/accounts_sync/adapters/base_adapter.py:46:9
   |
44 |         accounts: list[dict[str, Any]],
45 |         *,
46 |         usernames: Sequence[str] | None = None,
   |         ^^^^^^^^^
47 |     ) -> list[dict[str, Any]]:
48 |         """为账号列表补全权限信息.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/base_adapter.py:67:67
   |
66 |     @abstractmethod
67 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
68 |         """具体数据库实现负责查询账户列表.
   |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/adapters/mysql_adapter.py:37:9
   |
35 |     """
36 |
37 |     def __init__(self) -> None:
   |         ^^^^^^^^
38 |         self.logger = get_sync_logger()
39 |         self.filter_manager = DatabaseFilterManager()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/mysql_adapter.py:44:67
   |
42 |     # BaseAccountAdapter 实现
43 |     # ------------------------------------------------------------------
44 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
45 |         """拉取 MySQL 原始账户信息.
   |

S608 Possible SQL injection vector through string-based query construction
  --> app/services/accounts_sync/adapters/mysql_adapter.py:78:17
   |
76 |               where_clause, params = self._build_filter_conditions()
77 |               user_sql = (
78 | /                 "SELECT "
79 | |                 "    User as username, "
80 | |                 "    Host as host, "
81 | |                 "    Super_priv as is_superuser, "
82 | |                 "    account_locked as is_locked, "
83 | |                 "    Grant_priv as can_grant, "
84 | |                 "    plugin as plugin, "
85 | |                 "    password_last_changed as password_last_changed "
86 | |                 "FROM mysql.user "
87 | |                 f"WHERE User != '' AND {where_clause} "
88 | |                 "ORDER BY User, Host"
   | |_____________________________________^
89 |               )
90 |               users = connection.execute_query(user_sql, params)
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/adapters/mysql_adapter.py:124:13
    |
122 |                 account_count=len(accounts),
123 |             )
124 |             return accounts
    |             ^^^^^^^^^^^^^^^
125 |         except Exception as exc:
126 |             self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:126:25
    |
124 |             return accounts
125 |         except Exception as exc:
126 |             self.logger.error(
    |                         ^^^^^
127 |                 "fetch_mysql_accounts_failed",
128 |                 module="mysql_account_adapter",
    |

ARG002 Unused method argument: `instance`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:135:34
    |
133 |             return []
134 |
135 |     def _normalize_account(self, instance: Instance, account: dict[str, Any]) -> dict[str, Any]:
    |                                  ^^^^^^^^
136 |         """规范化 MySQL 账户信息.
    |

E501 Line too long (136 > 120)
   --> app/services/accounts_sync/adapters/mysql_adapter.py:189:121
    |
187 | …ysql")
188 | …
189 | …_rules.get("exclude_users", []), filter_rules.get("exclude_patterns", []))
    |                                                            ^^^^^^^^^^^^^^^^
190 | …
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:192:49
    |
190 |         return builder.build_where_clause()
191 |
192 |     def _get_user_permissions(self, connection: Any, username: str, host: str) -> dict[str, Any]:
    |                                                 ^^^
193 |         """获取 MySQL 用户权限详情.
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/adapters/mysql_adapter.py:244:13
    |
242 |                       },
243 |                   )
244 | /             return {
245 | |                 "global_privileges": global_privileges,
246 | |                 "database_privileges": database_privileges,
247 | |                 "type_specific": type_specific,
248 | |             }
    | |_____________^
249 |           except Exception as exc:
250 |               self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:250:25
    |
248 |             }
249 |         except Exception as exc:
250 |             self.logger.error(
    |                         ^^^^^
251 |                 "fetch_mysql_permissions_failed",
252 |                 module="mysql_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:267:21
    |
265 |         self,
266 |         instance: Instance,
267 |         connection: Any,
    |                     ^^^
268 |         accounts: list[dict[str, Any]],
269 |         *,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:323:29
    |
321 |                 )
322 |             except Exception as exc:
323 |                 self.logger.error(
    |                             ^^^^^
324 |                     "fetch_mysql_permissions_failed",
325 |                     module="mysql_account_adapter",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/mysql_adapter.py:395:16
    |
393 |                     existing.append("GRANT OPTION")
394 |                 return
395 |         except Exception as exc:
    |                ^^^^^^^^^
396 |             self.logger.warning(
397 |                 "mysql_parse_grant_failed",
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/accounts_sync/adapters/mysql_adapter.py:420:38
    |
418 |         return [priv.strip().upper() for priv in privileges_part.split(",") if priv.strip()]
419 |
420 |     def _expand_all_privileges(self, is_global: bool) -> list[str]:
    |                                      ^^^^^^^^^
421 |         """返回 ALL PRIVILEGES 展开的权限列表.
    |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/adapters/oracle_adapter.py:35:9
   |
33 |     """
34 |
35 |     def __init__(self) -> None:
   |         ^^^^^^^^
36 |         self.logger = get_sync_logger()
37 |         self.filter_manager = DatabaseFilterManager()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/oracle_adapter.py:39:67
   |
37 |         self.filter_manager = DatabaseFilterManager()
38 |
39 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
40 |         """拉取 Oracle 原始账户信息.
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/accounts_sync/adapters/oracle_adapter.py:78:13
   |
76 |                 account_count=len(accounts),
77 |             )
78 |             return accounts
   |             ^^^^^^^^^^^^^^^
79 |         except Exception as exc:
80 |             self.logger.error(
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
  --> app/services/accounts_sync/adapters/oracle_adapter.py:80:25
   |
78 |             return accounts
79 |         except Exception as exc:
80 |             self.logger.error(
   |                         ^^^^^
81 |                 "fetch_oracle_accounts_failed",
82 |                 module="oracle_account_adapter",
   |

ARG002 Unused method argument: `instance`
  --> app/services/accounts_sync/adapters/oracle_adapter.py:89:34
   |
87 |             return []
88 |
89 |     def _normalize_account(self, instance: Instance, account: dict[str, Any]) -> dict[str, Any]:
   |                                  ^^^^^^^^
90 |         """规范化 Oracle 账户信息.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:124:40
    |
123 |     # ------------------------------------------------------------------
124 |     def _fetch_users(self, connection: Any) -> list[dict[str, Any]]:
    |                                        ^^^
125 |         """读取 Oracle 用户列表.
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/oracle_adapter.py:139:13
    |
138 |           sql = (
139 | /             "SELECT username, account_status, default_tablespace "
140 | |             "FROM dba_users "
141 | |             f"WHERE username NOT IN ({placeholders})"
    | |_____________________________________________________^
142 |           )
143 |           params = {f":{i+1}": user for i, user in enumerate(exclude_users)}
    |

PERF401 Use a list comprehension to create a transformed list
   --> app/services/accounts_sync/adapters/oracle_adapter.py:147:13
    |
145 |           results: list[dict[str, Any]] = []
146 |           for row in rows:
147 | /             results.append(
148 | |                 {
149 | |                     "username": row[0],
150 | |                     "account_status": row[1],
151 | |                     "default_tablespace": row[2],
152 | |                     "is_dba": row[0] == "SYS",
153 | |                 },
154 | |             )
    | |_____________^
155 |           return results
    |
help: Replace for loop with list comprehension

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:157:49
    |
155 |         return results
156 |
157 |     def _get_user_permissions(self, connection: Any, username: str) -> dict[str, Any]:
    |                                                 ^^^
158 |         """查询单个用户的权限快照.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:178:21
    |
176 |         self,
177 |         instance: Instance,
178 |         connection: Any,
    |                     ^^^
179 |         accounts: list[dict[str, Any]],
180 |         *,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:215:29
    |
213 |                     account["is_locked"] = account_status.upper() != "OPEN"
214 |             except Exception as exc:
215 |                 self.logger.error(
    |                             ^^^^^
216 |                     "fetch_oracle_permissions_failed",
217 |                     module="oracle_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:233:38
    |
231 |         return accounts
232 |
233 |     def _get_roles(self, connection: Any, username: str) -> list[str]:
    |                                      ^^^
234 |         """查询用户拥有的角色.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:248:50
    |
246 |         return [row[0] for row in rows if row and row[0]]
247 |
248 |     def _get_system_privileges(self, connection: Any, username: str) -> list[str]:
    |                                                  ^^^
249 |         """查询用户拥有的系统权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/oracle_adapter.py:263:54
    |
261 |         return [row[0] for row in rows if row and row[0]]
262 |
263 |     def _get_tablespace_privileges(self, connection: Any, username: str) -> dict[str, dict[str, Any]]:
    |                                                      ^^^
264 |         """查询用户的表空间配额信息.
    |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/adapters/postgresql_adapter.py:36:9
   |
34 |     """
35 |
36 |     def __init__(self) -> None:
   |         ^^^^^^^^
37 |         self.logger = get_sync_logger()
38 |         self.filter_manager = DatabaseFilterManager()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/postgresql_adapter.py:40:67
   |
38 |         self.filter_manager = DatabaseFilterManager()
39 |
40 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
41 |         """拉取 PostgreSQL 原始账户信息.
   |

S608 Possible SQL injection vector through string-based query construction
  --> app/services/accounts_sync/adapters/postgresql_adapter.py:56:17
   |
54 |               where_clause, params = self._build_filter_conditions()
55 |               roles_sql = (
56 | /                 "SELECT "
57 | |                 "    rolname as username, "
58 | |                 "    rolsuper as is_superuser, "
59 | |                 "    rolcreaterole as can_create_role, "
60 | |                 "    rolcreatedb as can_create_db, "
61 | |                 "    rolreplication as can_replicate, "
62 | |                 "    rolbypassrls as can_bypass_rls, "
63 | |                 "    rolcanlogin as can_login, "
64 | |                 "    rolinherit as can_inherit, "
65 | |                 "    CASE "
66 | |                 "        WHEN rolvaliduntil = 'infinity'::timestamp THEN NULL "
67 | |                 "        WHEN rolvaliduntil = '-infinity'::timestamp THEN NULL "
68 | |                 "        ELSE rolvaliduntil "
69 | |                 "    END as valid_until "
70 | |                 "FROM pg_roles "
71 | |                 f"WHERE {where_clause} "
72 | |                 "ORDER BY rolname"
   | |__________________________________^
73 |               )
74 |               rows = connection.execute_query(roles_sql, params)
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:124:13
    |
122 |                 account_count=len(accounts),
123 |             )
124 |             return accounts
    |             ^^^^^^^^^^^^^^^
125 |         except Exception as exc:
126 |             self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:126:25
    |
124 |             return accounts
125 |         except Exception as exc:
126 |             self.logger.error(
    |                         ^^^^^
127 |                 "fetch_postgresql_accounts_failed",
128 |                 module="postgresql_account_adapter",
    |

ARG002 Unused method argument: `instance`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:135:34
    |
133 |             return []
134 |
135 |     def _normalize_account(self, instance: Instance, account: dict[str, Any]) -> dict[str, Any]:
    |                                  ^^^^^^^^
136 |         """规范化 PostgreSQL 账户信息.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:192:21
    |
190 |     def _get_role_permissions(
191 |         self,
192 |         connection: Any,
    |                     ^^^
193 |         username: str,
194 |         *,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:218:16
    |
216 |         try:
217 |             permissions["role_attributes"] = self._get_role_attributes(connection, username)
218 |         except Exception as exc:
    |                ^^^^^^^^^
219 |             self.logger.warning(
220 |                 "fetch_pg_role_attributes_failed",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:227:16
    |
225 |         try:
226 |             permissions["predefined_roles"] = self._get_predefined_roles(connection, username)
227 |         except Exception as exc:
    |                ^^^^^^^^^
228 |             self.logger.warning(
229 |                 "fetch_pg_predefined_roles_failed",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:236:16
    |
234 |         try:
235 |             permissions["database_privileges_pg"] = self._get_database_privileges(connection, username)
236 |         except Exception as exc:
    |                ^^^^^^^^^
237 |             self.logger.warning(
238 |                 "fetch_pg_database_privileges_failed",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:245:16
    |
243 |         try:
244 |             permissions["tablespace_privileges"] = self._get_tablespace_privileges(connection, username)
245 |         except Exception as exc:
    |                ^^^^^^^^^
246 |             self.logger.warning(
247 |                 "fetch_pg_tablespace_privileges_failed",
    |

C901 `enrich_permissions` is too complex (13 > 10)
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:256:9
    |
254 |         return permissions
255 |
256 |     def enrich_permissions(
    |         ^^^^^^^^^^^^^^^^^^
257 |         self,
258 |         instance: Instance,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:259:21
    |
257 |         self,
258 |         instance: Instance,
259 |         connection: Any,
    |                     ^^^
260 |         accounts: list[dict[str, Any]],
261 |         *,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:326:29
    |
324 |                 account["is_locked"] = not can_login
325 |             except Exception as exc:
326 |                 self.logger.error(
    |                             ^^^^^
327 |                     "fetch_pg_permissions_failed",
328 |                     module="postgresql_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:345:48
    |
344 |     # 以下辅助查询函数沿用旧实现
345 |     def _get_role_attributes(self, connection: Any, username: str) -> dict[str, Any]:
    |                                                ^^^
346 |         """查询角色属性.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:374:49
    |
372 |         }
373 |
374 |     def _get_predefined_roles(self, connection: Any, username: str) -> list[str]:
    |                                                 ^^^
375 |         """查询用户所属的预定义角色.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:394:52
    |
392 |         return [row[0] for row in rows if row and row[0]]
393 |
394 |     def _get_database_privileges(self, connection: Any, username: str) -> dict[str, list[str]]:
    |                                                    ^^^
395 |         """查询用户在各数据库上的权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/postgresql_adapter.py:432:54
    |
430 |         return privileges
431 |
432 |     def _get_tablespace_privileges(self, connection: Any, username: str) -> dict[str, list[str]]:
    |                                                      ^^^
433 |         """查询用户在各表空间上的权限.
    |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:39:9
   |
37 |     """
38 |
39 |     def __init__(self) -> None:
   |         ^^^^^^^^
40 |         self.logger = get_sync_logger()
41 |         self.filter_manager = DatabaseFilterManager()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:43:67
   |
41 |         self.filter_manager = DatabaseFilterManager()
42 |
43 |     def _fetch_raw_accounts(self, instance: Instance, connection: Any) -> list[dict[str, Any]]:
   |                                                                   ^^^
44 |         """拉取 SQL Server 原始账户信息.
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:81:13
   |
79 |                 account_count=len(accounts),
80 |             )
81 |             return accounts
   |             ^^^^^^^^^^^^^^^
82 |         except Exception as exc:
83 |             self.logger.error(
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:83:25
   |
81 |             return accounts
82 |         except Exception as exc:
83 |             self.logger.error(
   |                         ^^^^^
84 |                 "fetch_sqlserver_accounts_failed",
85 |                 module="sqlserver_account_adapter",
   |

ARG002 Unused method argument: `instance`
  --> app/services/accounts_sync/adapters/sqlserver_adapter.py:92:34
   |
90 |             return []
91 |
92 |     def _normalize_account(self, instance: Instance, account: dict[str, Any]) -> dict[str, Any]:
   |                                  ^^^^^^^^
93 |         """规范化 SQL Server 账户信息.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:131:21
    |
129 |         self,
130 |         instance: Instance,
131 |         connection: Any,
    |                     ^^^
132 |         accounts: list[dict[str, Any]],
133 |         *,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:192:29
    |
190 |                 account["is_locked"] = bool(type_specific.get("is_disabled", False))
191 |             except Exception as exc:
192 |                 self.logger.error(
    |                             ^^^^^
193 |                     "fetch_sqlserver_permissions_failed",
194 |                     module="sqlserver_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:213:41
    |
211 |     # 查询逻辑来源于旧实现
212 |     # ------------------------------------------------------------------
213 |     def _fetch_logins(self, connection: Any) -> list[dict[str, Any]]:
    |                                         ^^^
214 |         """查询服务器登录账户.
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:287:9
    |
285 |         return compiled
286 |
287 |     def _get_login_permissions(
    |         ^^^^^^^^^^^^^^^^^^^^^^
288 |         self,
289 |         connection: Any,
    |

ARG002 Unused method argument: `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:289:9
    |
287 |     def _get_login_permissions(
288 |         self,
289 |         connection: Any,
    |         ^^^^^^^^^^
290 |         login_name: str,
291 |         *,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:289:21
    |
287 |     def _get_login_permissions(
288 |         self,
289 |         connection: Any,
    |                     ^^^
290 |         login_name: str,
291 |         *,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:403:50
    |
401 |         return copied
402 |
403 |     def _get_server_roles_bulk(self, connection: Any, usernames: Sequence[str]) -> dict[str, list[str]]:
    |                                                  ^^^
404 |         """批量查询服务器角色.
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:419:15
    |
418 |           placeholders = ", ".join(["%s"] * len(normalized))
419 |           sql = f"""
    |  _______________^
420 | |             SELECT member.name AS login_name, role.name AS role_name
421 | |             FROM sys.server_role_members rm
422 | |             JOIN sys.server_principals role ON rm.role_principal_id = role.principal_id
423 | |             JOIN sys.server_principals member ON rm.member_principal_id = member.principal_id
424 | |             WHERE member.name IN ({placeholders})
425 | |         """
    | |___________^
426 |           rows = connection.execute_query(sql, tuple(normalized))
427 |           result: dict[str, list[str]] = {}
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:436:56
    |
434 |         return result
435 |
436 |     def _get_server_permissions_bulk(self, connection: Any, usernames: Sequence[str]) -> dict[str, list[str]]:
    |                                                        ^^^
437 |         """批量查询服务器权限.
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:452:15
    |
451 |           placeholders = ", ".join(["%s"] * len(normalized))
452 |           sql = f"""
    |  _______________^
453 | |             SELECT sp.name AS login_name, perm.permission_name
454 | |             FROM sys.server_permissions perm
455 | |             JOIN sys.server_principals sp ON perm.grantee_principal_id = sp.principal_id
456 | |             WHERE sp.name IN ({placeholders})
457 | |         """
    | |___________^
458 |           rows = connection.execute_query(sql, tuple(normalized))
459 |           result: dict[str, list[str]] = {}
    |

C901 `_get_all_users_database_permissions_batch` is too complex (32 > 10)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:468:9
    |
466 |         return result
467 |
468 |     def _get_all_users_database_permissions_batch(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
469 |         self,
470 |         connection: Any,
    |

PLR0912 Too many branches (31 > 12)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:468:9
    |
466 |         return result
467 |
468 |     def _get_all_users_database_permissions_batch(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
469 |         self,
470 |         connection: Any,
    |

PLR0915 Too many statements (88 > 50)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:468:9
    |
466 |         return result
467 |
468 |     def _get_all_users_database_permissions_batch(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
469 |         self,
470 |         connection: Any,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `connection`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:470:21
    |
468 |     def _get_all_users_database_permissions_batch(
469 |         self,
470 |         connection: Any,
    |                     ^^^
471 |         usernames: Sequence[str],
472 |     ) -> dict[str, dict[str, Any]]:
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:512:30
    |
510 |               unique_usernames = list(dict.fromkeys(usernames))
511 |               placeholders = ", ".join(["%s"] * len(unique_usernames))
512 |               login_sids_sql = f"""
    |  ______________________________^
513 | |                 SELECT name, sid
514 | |                 FROM sys.server_principals
515 | |                 WHERE name IN ({placeholders})
516 | |                   AND type IN ('S', 'U', 'G')
517 | |             """
    | |_______________^
518 |               login_rows = connection.execute_query(login_sids_sql, tuple(unique_usernames))
519 |               sid_to_logins: dict[bytes, list[str]] = {}
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:543:21
    |
541 |                   quoted_db = self._quote_identifier(db)
542 |                   principals_parts.append(
543 | /                     f"""
544 | |                     SELECT '{db}' AS db_name,
545 | |                            name COLLATE SQL_Latin1_General_CP1_CI_AS AS user_name,
546 | |                            principal_id,
547 | |                            sid
548 | |                     FROM {quoted_db}.sys.database_principals
549 | |                     WHERE type IN ('S', 'U', 'G')
550 | |                       AND name != 'dbo'
551 | |                       AND sid IN ({sid_filter})
552 | |                     """,
    | |_______________________^
553 |                   )
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:556:21
    |
555 |                   roles_parts.append(
556 | /                     f"""
557 | |                     SELECT '{db}' AS db_name,
558 | |                            role.name COLLATE SQL_Latin1_General_CP1_CI_AS AS role_name,
559 | |                            member.principal_id AS member_principal_id
560 | |                     FROM {quoted_db}.sys.database_role_members drm
561 | |                     JOIN {quoted_db}.sys.database_principals role
562 | |                       ON drm.role_principal_id = role.principal_id
563 | |                     JOIN {quoted_db}.sys.database_principals member
564 | |                       ON drm.member_principal_id = member.principal_id
565 | |                     WHERE member.sid IN ({sid_filter})
566 | |                     """,
    | |_______________________^
567 |                   )
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:570:21
    |
569 |   …     perms_parts.append(
570 | / …         f"""
571 | | …         SELECT '{db}' AS db_name,
572 | | …                perm.permission_name COLLATE SQL_Latin1_General_CP1_CI_AS AS permission_name,
573 | | …                perm.grantee_principal_id,
574 | | …                perm.major_id,
575 | | …                perm.minor_id,
576 | | …                CASE
577 | | …                    WHEN perm.class_desc = 'DATABASE' THEN 'DATABASE'
578 | | …                    WHEN perm.class_desc = 'SCHEMA' THEN 'SCHEMA'
579 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' AND perm.minor_id = 0 THEN 'OBJECT'
580 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' AND perm.minor_id > 0 THEN 'COLUMN'
581 | | …                    ELSE perm.class_desc
582 | | …                END AS permission_scope,
583 | | …                CASE
584 | | …                    WHEN perm.class_desc = 'SCHEMA' THEN SCHEMA_NAME(perm.major_id)
585 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' THEN OBJECT_SCHEMA_NAME(perm.major_id)
586 | | …                    ELSE NULL
587 | | …                END AS schema_name,
588 | | …                CASE
589 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' THEN OBJECT_NAME(perm.major_id)
590 | | …                    ELSE NULL
591 | | …                END AS object_name,
592 | | …                CASE
593 | | …                    WHEN perm.class_desc = 'OBJECT_OR_COLUMN' AND perm.minor_id > 0 THEN COL_NAME(perm.major_id, perm.minor_id)
594 | | …                    ELSE NULL
595 | | …                END AS column_name
596 | | …         FROM {quoted_db}.sys.database_permissions perm
597 | | …         JOIN {quoted_db}.sys.database_principals dp
598 | | …           ON perm.grantee_principal_id = dp.principal_id
599 | | …         WHERE perm.state = 'G'
600 | | …           AND dp.sid IN ({sid_filter})
601 | | …         """,
    | |_____________^
602 |   …     )
    |

E501 Line too long (138 > 120)
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:593:121
    |
591 | …                     END AS object_name,
592 | …                     CASE
593 | …                         WHEN perm.class_desc = 'OBJECT_OR_COLUMN' AND perm.minor_id > 0 THEN COL_NAME(perm.major_id, perm.minor_id)
    |                                                                                                                    ^^^^^^^^^^^^^^^^^^
594 | …                         ELSE NULL
595 | …                     END AS column_name
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:701:13
    |
699 |             )
700 |
701 |             return result
    |             ^^^^^^^^^^^^^
702 |         except Exception as exc:
703 |             self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:703:25
    |
701 |             return result
702 |         except Exception as exc:
703 |             self.logger.error(
    |                         ^^^^^
704 |                 "sqlserver_batch_database_permissions_failed",
705 |                 module="sqlserver_account_adapter",
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `raw_sid`
   --> app/services/accounts_sync/adapters/sqlserver_adapter.py:712:33
    |
711 |     @staticmethod
712 |     def _normalize_sid(raw_sid: Any) -> bytes | None:
    |                                 ^^^
713 |         """标准化 SID 字节串.
    |

D107 Missing docstring in `__init__`
  --> app/services/accounts_sync/coordinator.py:39:9
   |
37 |     """
38 |
39 |     def __init__(self, instance: Instance) -> None:
   |         ^^^^^^^^
40 |         self.instance = instance
41 |         self.logger = get_sync_logger()
   |

ANN001 Missing type annotation for function argument `exc_type`
  --> app/services/accounts_sync/coordinator.py:71:24
   |
69 |         return self
70 |
71 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                        ^^^^^^^^
72 |         """退出上下文时释放连接资源.
   |

ANN001 Missing type annotation for function argument `exc_val`
  --> app/services/accounts_sync/coordinator.py:71:34
   |
69 |         return self
70 |
71 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                                  ^^^^^^^
72 |         """退出上下文时释放连接资源.
   |

ANN001 Missing type annotation for function argument `exc_tb`
  --> app/services/accounts_sync/coordinator.py:71:43
   |
69 |         return self
70 |
71 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                                           ^^^^^^
72 |         """退出上下文时释放连接资源.
   |

PLR0911 Too many return statements (7 > 6)
  --> app/services/accounts_sync/coordinator.py:85:9
   |
83 |         self.disconnect()
84 |
85 |     def connect(self) -> bool:
   |         ^^^^^^^
86 |         """建立到数据库实例的连接.
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/coordinator.py:111:25
    |
109 |             self._connection_failed = True
110 |             self._connection_error = str(exc)
111 |             self.logger.error(
    |                         ^^^^^
112 |                 "accounts_sync_connection_init_failed",
113 |                 instance_id=self.instance.id,
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/accounts_sync/coordinator.py:156:13
    |
154 |                 module=MODULE,
155 |             )
156 |             return False
    |             ^^^^^^^^^^^^
157 |         except Exception as exc:
158 |             self._connection_failed = True
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/coordinator.py:160:25
    |
158 |             self._connection_failed = True
159 |             self._connection_error = str(exc)
160 |             self.logger.error(
    |                         ^^^^^
161 |                 "accounts_sync_connection_exception",
162 |                 instance_id=self.instance.id,
    |

E501 Line too long (122 > 120)
   --> app/services/accounts_sync/coordinator.py:358:121
    |
356 |         active_usernames = [account.username for account in active_accounts if getattr(account, "username", None)]
357 |         enriched_usernames = getattr(self, "_enriched_usernames", set())
358 |         pending_usernames = [username for username in active_usernames if username and username not in enriched_usernames]
    |                                                                                                                         ^^
359 |         if pending_usernames:
360 |             self._ensure_connection()
    |

E501 Line too long (121 > 120)
   --> app/services/accounts_sync/coordinator.py:396:121
    |
394 |             "updated": summary.get("updated", 0),
395 |             "skipped": summary.get("skipped", 0),
396 |             "processed_records": summary.get("processed_records", summary.get("created", 0) + summary.get("updated", 0)),
    |                                                                                                                         ^
397 |             "errors": summary.get("errors", []),
398 |             "message": summary.get("message"),
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/inventory_manager.py:128:25
    |
126 |         except Exception as exc:
127 |             db.session.rollback()
128 |             self.logger.error(
    |                         ^^^^^
129 |                 "account_inventory_sync_commit_failed",
130 |                 instance=instance.name,
    |

C901 `synchronize` is too complex (11 > 10)
  --> app/services/accounts_sync/permission_manager.py:96:9
   |
94 |         self.logger = get_sync_logger()
95 |
96 |     def synchronize(
   |         ^^^^^^^^^^^
97 |         self,
98 |         instance: Instance,
   |

PLR0915 Too many statements (62 > 50)
  --> app/services/accounts_sync/permission_manager.py:96:9
   |
94 |         self.logger = get_sync_logger()
95 |
96 |     def synchronize(
   |         ^^^^^^^^^^^
97 |         self,
98 |         instance: Instance,
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/accounts_sync/permission_manager.py:252:25
    |
250 |         except SQLAlchemyError as exc:
251 |             db.session.rollback()
252 |             self.logger.error(
    |                         ^^^^^
253 |                 "account_permission_sync_commit_failed",
254 |                 instance=instance.name,
    |

C901 `_calculate_diff` is too complex (11 > 10)
   --> app/services/accounts_sync/permission_manager.py:334:9
    |
332 |                 setattr(record, field, None)
333 |
334 |     def _calculate_diff(
    |         ^^^^^^^^^^^^^^^
335 |         self,
336 |         record: AccountPermission,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `old_value`
   --> app/services/accounts_sync/permission_manager.py:506:20
    |
504 |         self,
505 |         field: str,
506 |         old_value: Any,
    |                    ^^^
507 |         new_value: Any,
508 |     ) -> list[dict[str, Any]]:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `new_value`
   --> app/services/accounts_sync/permission_manager.py:507:20
    |
505 |         field: str,
506 |         old_value: Any,
507 |         new_value: Any,
    |                    ^^^
508 |     ) -> list[dict[str, Any]]:
509 |         """比较权限字段并返回差异条目.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `old_value`
   --> app/services/accounts_sync/permission_manager.py:611:20
    |
609 |         self,
610 |         field: str,
611 |         old_value: Any,
    |                    ^^^
612 |         new_value: Any,
613 |     ) -> dict[str, Any] | None:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `new_value`
   --> app/services/accounts_sync/permission_manager.py:612:20
    |
610 |         field: str,
611 |         old_value: Any,
612 |         new_value: Any,
    |                    ^^^
613 |     ) -> dict[str, Any] | None:
614 |         """构建非权限字段的差异条目.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `old_value`
   --> app/services/accounts_sync/permission_manager.py:638:63
    |
636 |         }
637 |
638 |     def _build_other_description(self, label: str, old_value: Any, new_value: Any) -> str:
    |                                                               ^^^
639 |         """生成非权限字段差异的自然语言描述.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `new_value`
   --> app/services/accounts_sync/permission_manager.py:638:79
    |
636 |         }
637 |
638 |     def _build_other_description(self, label: str, old_value: Any, new_value: Any) -> str:
    |                                                                               ^^^
639 |         """生成非权限字段差异的自然语言描述.
    |

C901 `_build_change_summary` is too complex (11 > 10)
   --> app/services/accounts_sync/permission_manager.py:660:9
    |
658 |         return f"{label} 已更新"
659 |
660 |     def _build_change_summary(
    |         ^^^^^^^^^^^^^^^^^^^^^
661 |         self,
662 |         username: str,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/accounts_sync/permission_manager.py:713:28
    |
712 |     @staticmethod
713 |     def _is_mapping(value: Any) -> bool:
    |                            ^^^
714 |         """判断值是否为映射类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/accounts_sync/permission_manager.py:726:35
    |
725 |     @staticmethod
726 |     def _normalize_mapping(value: Any) -> dict[str, set]:
    |                                   ^^^
727 |         """将权限映射标准化为 {str: set} 结构.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/accounts_sync/permission_manager.py:744:36
    |
743 |     @staticmethod
744 |     def _normalize_sequence(value: Any) -> set:
    |                                    ^^^
745 |         """将单值或序列转换为集合形式.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/accounts_sync/permission_manager.py:761:28
    |
760 |     @staticmethod
761 |     def _repr_value(value: Any) -> str:
    |                            ^^^
762 |         """将值转换为日志友好的文本.
    |

ARG002 Unused method argument: `target_date`
  --> app/services/aggregation/aggregation_service.py:94:42
   |
92 |         return instance
93 |
94 |     def _ensure_partition_for_date(self, target_date: date) -> None:
   |                                          ^^^^^^^^^^^
95 |         """保留接口,当前环境无需分区预处理.
   |

ANN001 Missing type annotation for function argument `aggregation`
   --> app/services/aggregation/aggregation_service.py:106:44
    |
104 |         return
105 |
106 |     def _commit_with_partition_retry(self, aggregation, start_date: date) -> None:
    |                                            ^^^^^^^^^^^
107 |         """提交聚合记录,移除分区重试逻辑.
    |

ARG002 Unused method argument: `aggregation`
   --> app/services/aggregation/aggregation_service.py:106:44
    |
104 |         return
105 |
106 |     def _commit_with_partition_retry(self, aggregation, start_date: date) -> None:
    |                                            ^^^^^^^^^^^
107 |         """提交聚合记录,移除分区重试逻辑.
    |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/aggregation/aggregation_service.py:152:61
    |
150 |         return (period_type or "").lower() == "daily"
151 |
152 |     def _resolve_use_current_period(self, period_type: str, override: bool | None = None) -> bool:
    |                                                             ^^^^^^^^
153 |         """结合覆盖配置判断是否使用当前周期."""
154 |         if override is not None:
    |

ANN001 Missing type annotation for function argument `runner`
   --> app/services/aggregation/aggregation_service.py:255:9
    |
253 |         self,
254 |         *,
255 |         runner,
    |         ^^^^^^
256 |         period_type: str,
257 |         use_current_period: bool,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/aggregation_service.py:325:20
    |
323 |             try:
324 |                 period_result = method(use_current_period=use_current)
325 |             except Exception as exc:  # pragma: no cover - 防御性日志
    |                    ^^^^^^^^^
326 |                 log_error(
327 |                     "数据库级聚合执行失败",
    |

E501 Line too long (121 > 120)
   --> app/services/aggregation/aggregation_service.py:375:121
    |
374 |         failed_periods = [
375 |             period for period, result in period_results.items() if result.get("status") == AggregationStatus.FAILED.value
    |                                                                                                                         ^
376 |         ]
377 |         failed_instance_periods = [
    |

C901 `aggregate_current_period` is too complex (11 > 10)
   --> app/services/aggregation/aggregation_service.py:444:9
    |
442 |         )
443 |
444 |     def aggregate_current_period(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
445 |         self,
446 |         period_type: str = "daily",
    |

C901 `calculate_instance_aggregations` is too complex (11 > 10)
   --> app/services/aggregation/aggregation_service.py:681:9
    |
679 |         )
680 |
681 |     def calculate_instance_aggregations(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
682 |         self,
683 |         instance_id: int,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/aggregation_service.py:726:20
    |
724 |             try:
725 |                 result = func(instance_id, use_current_period=use_current_period)
726 |             except Exception as exc:  # pragma: no cover - 防御性日志
    |                    ^^^^^^^^^
727 |                 log_error(
728 |                     "实例周期聚合执行失败",
    |

ANN001 Missing type annotation for function argument `now_func`
  --> app/services/aggregation/calculator.py:23:24
   |
21 |     """
22 |
23 |     def __init__(self, now_func=None) -> None:
   |                        ^^^^^^^^
24 |         """初始化周期计算器.
   |

ANN002 Missing type annotation for `*args`
  --> app/services/aggregation/database_aggregation_runner.py:62:70
   |
60 |         self._module = module
61 |
62 |     def _invoke_callback(self, callback: Callable[..., None] | None, *args) -> None:
   |                                                                      ^^^^^
63 |         """安全执行回调.
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/aggregation/database_aggregation_runner.py:77:16
   |
75 |         try:
76 |             callback(*args)
77 |         except Exception as exc:  # pragma: no cover - 防御性处理
   |                ^^^^^^^^^
78 |             log_warning(
79 |                 "聚合回调执行失败",
   |

PLR0913 Too many arguments in function definition (6 > 5)
  --> app/services/aggregation/database_aggregation_runner.py:85:9
   |
83 |             )
84 |
85 |     def aggregate_period(
   |         ^^^^^^^^^^^^^^^^
86 |         self,
87 |         period_type: str,
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/database_aggregation_runner.py:187:20
    |
185 |                 }
186 |                 self._invoke_callback(on_instance_complete, instance, result_payload)
187 |             except Exception as exc:  # pragma: no cover - 防御性日志
    |                    ^^^^^^^^^
188 |                 db.session.rollback()
189 |                 summary.failed_instances += 1
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> app/services/aggregation/database_aggregation_runner.py:366:9
    |
364 |         return grouped
365 |
366 |     def _persist_database_aggregation(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
367 |         self,
368 |         *,
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/services/aggregation/database_aggregation_runner.py:503:9
    |
501 |             ) from exc
502 |
503 |     def _apply_change_statistics(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^
504 |         self,
505 |         *,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/database_aggregation_runner.py:583:16
    |
581 |             aggregation.log_size_change_percent = None
582 |             aggregation.growth_rate = aggregation.size_change_percent
583 |         except Exception as exc:  # pragma: no cover - 防御性日志
    |                ^^^^^^^^^
584 |             log_error(
585 |                 "计算数据库增量统计失败,使用默认值",
    |

ANN002 Missing type annotation for `*args`
  --> app/services/aggregation/instance_aggregation_runner.py:62:70
   |
60 |         self._module = module
61 |
62 |     def _invoke_callback(self, callback: Callable[..., None] | None, *args) -> None:
   |                                                                      ^^^^^
63 |         """安全地执行回调.
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/aggregation/instance_aggregation_runner.py:77:16
   |
75 |         try:
76 |             callback(*args)
77 |         except Exception as exc:  # pragma: no cover
   |                ^^^^^^^^^
78 |             log_warning(
79 |                 "聚合回调执行失败",
   |

PLR0913 Too many arguments in function definition (6 > 5)
  --> app/services/aggregation/instance_aggregation_runner.py:85:9
   |
83 |             )
84 |
85 |     def aggregate_period(
   |         ^^^^^^^^^^^^^^^^
86 |         self,
87 |         period_type: str,
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/instance_aggregation_runner.py:182:20
    |
180 |                 }
181 |                 self._invoke_callback(on_instance_complete, instance, result_payload)
182 |             except Exception as exc:  # pragma: no cover - 防御性日志
    |                    ^^^^^^^^^
183 |                 db.session.rollback()
184 |                 summary.failed_instances += 1
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/services/aggregation/instance_aggregation_runner.py:315:9
    |
313 |         ).all()
314 |
315 |     def _persist_instance_aggregation(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
316 |         self,
317 |         *,
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> app/services/aggregation/instance_aggregation_runner.py:519:56
    |
517 |             aggregation.growth_rate = aggregation.total_size_change_percent
518 |
519 |             if aggregation.total_size_change_percent > 5:
    |                                                        ^
520 |                 aggregation.trend_direction = "growing"
521 |             elif aggregation.total_size_change_percent < -5:
    |

PLR2004 Magic value used in comparison, consider replacing `-5` with a constant variable
   --> app/services/aggregation/instance_aggregation_runner.py:521:58
    |
519 |             if aggregation.total_size_change_percent > 5:
520 |                 aggregation.trend_direction = "growing"
521 |             elif aggregation.total_size_change_percent < -5:
    |                                                          ^^
522 |                 aggregation.trend_direction = "shrinking"
523 |             else:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/aggregation/instance_aggregation_runner.py:525:16
    |
523 |             else:
524 |                 aggregation.trend_direction = "stable"
525 |         except Exception as exc:  # pragma: no cover - defensive logging
    |                ^^^^^^^^^
526 |             log_error(
527 |                 "计算实例增量统计失败,使用默认值",
    |

D107 Missing docstring in `__init__`
  --> app/services/cache_service.py:35:9
   |
33 |     """
34 |
35 |     def __init__(self, cache: Cache = None) -> None:
   |         ^^^^^^^^
36 |         self.cache = cache
37 |         self.default_ttl = Config.CACHE_DEFAULT_TTL  # 7天,按用户要求
   |

FBT001 Boolean-typed positional argument in function definition
   --> app/services/cache_service.py:149:72
    |
147 |         return result
148 |
149 |     def set_rule_evaluation_cache(self, rule_id: int, account_id: int, result: bool, ttl: int | None = None) -> bool:
    |                                                                        ^^^^^^
150 |         """设置规则评估缓存.
    |

E501 Line too long (131 > 120)
   --> app/services/cache_service.py:347:121
    |
345 |         return rules
346 |
347 |     def set_classification_rules_by_db_type_cache(self, db_type: str, rules: list[dict[str, Any]], ttl: int | None = None) -> bool:
    |                                                                                                                         ^^^^^^^^^^^
348 |         """设置按数据库类型分类的规则缓存.
    |

D205 1 blank line required between summary line and description
 --> app/services/connection_adapters/__init__.py:1:1
  |
1 | / """鲸落 - 连接适配器模块
2 | | 集中提供数据库连接工厂与连接测试服务.
3 | | """
  | |___^
4 |
5 |   from .connection_factory import ConnectionFactory
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/services/connection_adapters/adapters/base.py:56:9
   |
54 |     """
55 |
56 |     def __init__(self, instance: Instance) -> None:
   |         ^^^^^^^^
57 |         self.instance = instance
58 |         self.db_logger = get_db_logger()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `params`
   --> app/services/connection_adapters/adapters/base.py:99:49
    |
 98 |     @abstractmethod
 99 |     def execute_query(self, query: str, params: Any | None = None) -> Any:
    |                                                 ^^^^^^^^^^
100 |         """执行查询并返回结果.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
   --> app/services/connection_adapters/adapters/base.py:99:71
    |
 98 |     @abstractmethod
 99 |     def execute_query(self, query: str, params: Any | None = None) -> Any:
    |                                                                       ^^^
100 |         """执行查询并返回结果.
    |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/mysql_adapter.py:21:13
   |
19 |         """
20 |         try:
21 |             import pymysql
   |             ^^^^^^^^^^^^^^
22 |
23 |             password = self.instance.credential.get_plain_password() if self.instance.credential else ""
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/mysql_adapter.py:39:13
   |
37 |             )
38 |             self.is_connected = True
39 |             return True
   |             ^^^^^^^^^^^
40 |         except Exception as exc:
41 |             self.db_logger.exception(
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/mysql_adapter.py:79:13
   |
78 |               version = self.get_version()
79 | /             return {
80 | |                 "success": True,
81 | |                 "message": f"MySQL连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
82 | |                 "database_version": version,
83 | |             }
   | |_____________^
84 |           except Exception as exc:
85 |               return {"success": False, "error": str(exc)}
   |

E501 Line too long (121 > 120)
  --> app/services/connection_adapters/adapters/mysql_adapter.py:81:111
   |
79 |             return {
80 |                 "success": True,
81 |                 "message": f"MySQL连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
   |                                                                                                                         ^
82 |                 "database_version": version,
83 |             }
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/connection_adapters/adapters/mysql_adapter.py:84:16
   |
82 |                 "database_version": version,
83 |             }
84 |         except Exception as exc:
   |                ^^^^^^^^^
85 |             return {"success": False, "error": str(exc)}
86 |         finally:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
  --> app/services/connection_adapters/adapters/mysql_adapter.py:89:73
   |
87 |             self.disconnect()
88 |
89 |     def execute_query(self, query: str, params: tuple | None = None) -> Any:
   |                                                                         ^^^
90 |         """执行 SQL 查询并返回全部结果.
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/mysql_adapter.py:122:13
    |
120 |             if result:
121 |                 return result[0][0]
122 |             return None
    |             ^^^^^^^^^^^
123 |         except Exception:
124 |             return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/mysql_adapter.py:123:16
    |
121 |                 return result[0][0]
122 |             return None
123 |         except Exception:
    |                ^^^^^^^^^
124 |             return None
    |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/oracle_adapter.py:23:13
   |
21 |         username_for_connection = None
22 |         try:
23 |             import os
   |             ^^^^^^^^^
24 |
25 |             import oracledb
   |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/oracle_adapter.py:25:13
   |
23 |             import os
24 |
25 |             import oracledb
   |             ^^^^^^^^^^^^^^^
26 |
27 |             password = self.instance.credential.get_plain_password() if self.instance.credential else ""
   |

E501 Line too long (129 > 120)
  --> app/services/connection_adapters/adapters/oracle_adapter.py:33:121
   |
31 |             port = self.instance.port
32 |             service_name = self.instance.database_name or "ORCL"
33 |             dsn = f"(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST={host})(PORT={port}))(CONNECT_DATA=(SERVICE_NAME={service_name})))"
   |                                                                                                                         ^^^^^^^^^
34 |
35 |             if not hasattr(oracledb, "is_thin") or not oracledb.is_thin():
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/connection_adapters/adapters/oracle_adapter.py:54:24
   |
52 |                     else:
53 |                         oracledb.init_oracle_client()
54 |                 except Exception as init_error:
   |                        ^^^^^^^^^
55 |                     if "already been initialized" not in str(init_error).lower():
56 |                         self.db_logger.warning(
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/oracle_adapter.py:75:13
   |
73 |                 username=username_for_connection,
74 |             )
75 |             return True
   |             ^^^^^^^^^^^
76 |         except Exception as exc:
77 |             self.db_logger.exception(
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/oracle_adapter.py:119:13
    |
118 |               version = self.get_version()
119 | /             return {
120 | |                 "success": True,
121 | |                 "message": f"Oracle连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
122 | |                 "database_version": version,
123 | |             }
    | |_____________^
124 |           except Exception as exc:
125 |               return {"success": False, "error": str(exc)}
    |

E501 Line too long (122 > 120)
   --> app/services/connection_adapters/adapters/oracle_adapter.py:121:111
    |
119 |             return {
120 |                 "success": True,
121 |                 "message": f"Oracle连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
    |                                                                                                                         ^^
122 |                 "database_version": version,
123 |             }
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/oracle_adapter.py:124:16
    |
122 |                 "database_version": version,
123 |             }
124 |         except Exception as exc:
    |                ^^^^^^^^^
125 |             return {"success": False, "error": str(exc)}
126 |         finally:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
   --> app/services/connection_adapters/adapters/oracle_adapter.py:129:80
    |
127 |             self.disconnect()
128 |
129 |     def execute_query(self, query: str, params: tuple | dict | None = None) -> Any:
    |                                                                                ^^^
130 |         """执行 SQL 查询并返回全部行.
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/oracle_adapter.py:162:13
    |
160 |             if result:
161 |                 return result[0][0]
162 |             return None
    |             ^^^^^^^^^^^
163 |         except Exception:
164 |             return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/oracle_adapter.py:163:16
    |
161 |                 return result[0][0]
162 |             return None
163 |         except Exception:
    |                ^^^^^^^^^
164 |             return None
    |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:21:13
   |
19 |         """
20 |         try:
21 |             import psycopg
   |             ^^^^^^^^^^^^^^
22 |
23 |             password = self.instance.credential.get_plain_password() if self.instance.credential else ""
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:35:13
   |
33 |             )
34 |             self.is_connected = True
35 |             return True
   |             ^^^^^^^^^^^
36 |         except Exception as exc:
37 |             self.db_logger.exception(
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:75:13
   |
74 |   …         version = self.get_version()
75 | / …         return {
76 | | …             "success": True,
77 | | …             "message": f"PostgreSQL连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
78 | | …             "database_version": version,
79 | | …         }
   | |___________^
80 |   …     except Exception as exc:
81 |   …         return {"success": False, "error": str(exc)}
   |

E501 Line too long (126 > 120)
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:77:112
   |
75 | …     return {
76 | …         "success": True,
77 | …         "message": f"PostgreSQL连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
   |                                                                                                                    ^^^^^
78 | …         "database_version": version,
79 | …     }
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:80:16
   |
78 |                 "database_version": version,
79 |             }
80 |         except Exception as exc:
   |                ^^^^^^^^^
81 |             return {"success": False, "error": str(exc)}
82 |         finally:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
  --> app/services/connection_adapters/adapters/postgresql_adapter.py:85:73
   |
83 |             self.disconnect()
84 |
85 |     def execute_query(self, query: str, params: tuple | None = None) -> Any:
   |                                                                         ^^^
86 |         """执行 SQL 查询并返回所有结果.
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/postgresql_adapter.py:118:13
    |
116 |             if result:
117 |                 return result[0][0]
118 |             return None
    |             ^^^^^^^^^^^
119 |         except Exception:
120 |             return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/postgresql_adapter.py:119:16
    |
117 |                 return result[0][0]
118 |             return None
119 |         except Exception:
    |                ^^^^^^^^^
120 |             return None
    |

D107 Missing docstring in `__init__`
  --> app/services/connection_adapters/adapters/sqlserver_adapter.py:15:9
   |
13 |     """SQL Server 数据库连接."""
14 |
15 |     def __init__(self, instance: Any) -> None:
   |         ^^^^^^^^
16 |         super().__init__(instance)
17 |         self.driver_type: str | None = None
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
  --> app/services/connection_adapters/adapters/sqlserver_adapter.py:15:34
   |
13 |     """SQL Server 数据库连接."""
14 |
15 |     def __init__(self, instance: Any) -> None:
   |                                  ^^^
16 |         super().__init__(instance)
17 |         self.driver_type: str | None = None
   |

PLC0415 `import` should be at the top-level of a file
  --> app/services/connection_adapters/adapters/sqlserver_adapter.py:60:13
   |
58 |         """
59 |         try:
60 |             import pymssql
   |             ^^^^^^^^^^^^^^
61 |
62 |             self.connection = pymssql.connect(
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/adapters/sqlserver_adapter.py:74:13
   |
72 |             self.is_connected = True
73 |             self.driver_type = "pymssql"
74 |             return True
   |             ^^^^^^^^^^^
75 |         except ImportError:
76 |             self.db_logger.exception(
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:112:20
    |
110 |             try:
111 |                 self.connection.close()
112 |             except Exception as exc:
    |                    ^^^^^^^^^
113 |                 self.db_logger.warning(
114 |                     "SQL Server断开连接出现异常",
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:131:13
    |
130 |   …         version = self.get_version()
131 | / …         return {
132 | | …             "success": True,
133 | | …             "message": f"SQL Server连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
134 | | …             "database_version": version,
135 | | …         }
    | |___________^
136 |   …     except Exception as exc:
137 |   …         return {"success": False, "error": str(exc)}
    |

E501 Line too long (126 > 120)
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:133:112
    |
131 | …     return {
132 | …         "success": True,
133 | …         "message": f"SQL Server连接成功 (主机: {self.instance.host}:{self.instance.port}, 版本: {version or '未知'})",
    |                                                                                                                    ^^^^^
134 | …         "database_version": version,
135 | …     }
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:136:16
    |
134 |                 "database_version": version,
135 |             }
136 |         except Exception as exc:
    |                ^^^^^^^^^
137 |             return {"success": False, "error": str(exc)}
138 |         finally:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `execute_query`
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:141:73
    |
139 |             self.disconnect()
140 |
141 |     def execute_query(self, query: str, params: tuple | None = None) -> Any:
    |                                                                         ^^^
142 |         """执行 SQL 查询并返回 `fetchall` 结果.
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:174:13
    |
172 |             if result:
173 |                 return result[0][0]
174 |             return None
    |             ^^^^^^^^^^^
175 |         except Exception:
176 |             return None
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/adapters/sqlserver_adapter.py:175:16
    |
173 |                 return result[0][0]
174 |             return None
175 |         except Exception:
    |                ^^^^^^^^^
176 |             return None
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/services/connection_adapters/connection_factory.py:37:26
   |
35 |       """
36 |
37 |       CONNECTION_CLASSES = {
   |  __________________________^
38 | |         "mysql": MySQLConnection,
39 | |         "postgresql": PostgreSQLConnection,
40 | |         "sqlserver": SQLServerConnection,
41 | |         "oracle": OracleConnection,
42 | |     }
   | |_____^
43 |
44 |       @staticmethod
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/connection_adapters/connection_test_service.py:80:13
   |
78 |               db.session.commit()
79 |
80 | /             return {
81 | |                 "success": True,
82 | |                 "message": f"连接成功,数据库版本: {formatted_version}",
83 | |                 "version": formatted_version,
84 | |                 "database_version": instance.database_version,
85 | |                 "main_version": instance.main_version,
86 | |                 "detailed_version": instance.detailed_version,
87 | |             }
   | |_____________^
88 |
89 |           except Exception as e:
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/connection_adapters/connection_test_service.py:134:24
    |
132 |                 try:
133 |                     connection_obj.disconnect()
134 |                 except Exception as close_error:
    |                        ^^^^^^^^^
135 |                     self.test_logger.warning(
136 |                         "关闭数据库连接时发生错误",
    |

D107 Missing docstring in `__init__`
  --> app/services/database_sync/adapters/base_adapter.py:30:9
   |
28 |     """
29 |
30 |     def __init__(self) -> None:
   |         ^^^^^^^^
31 |         self.logger = get_system_logger()
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/base_adapter.py:33:51
   |
31 |         self.logger = get_system_logger()
32 |
33 |     def fetch_inventory(self, instance: Instance, connection) -> list[dict]:
   |                                                   ^^^^^^^^^^
34 |         """列出实例当前的数据库/表空间.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/base_adapter.py:54:9
   |
52 |         self,
53 |         instance: Instance,
54 |         connection,
   |         ^^^^^^^^^^
55 |         target_databases: Sequence[str] | None = None,
56 |     ) -> list[dict]:
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/services/database_sync/adapters/mysql_adapter.py:32:25
   |
30 |     """
31 |
32 |     _SYSTEM_DATABASES = {"information_schema", "performance_schema", "mysql", "sys"}
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
33 |
34 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/mysql_adapter.py:34:31
   |
32 |     _SYSTEM_DATABASES = {"information_schema", "performance_schema", "mysql", "sys"}
33 |
34 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                               ^^^^^^^^
35 |         """列出 MySQL 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/mysql_adapter.py:34:41
   |
32 |     _SYSTEM_DATABASES = {"information_schema", "performance_schema", "mysql", "sys"}
33 |
34 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                                         ^^^^^^^^^^
35 |         """列出 MySQL 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/mysql_adapter.py:78:9
   |
76 |     def fetch_capacity(
77 |         self,
78 |         instance,
   |         ^^^^^^^^
79 |         connection,
80 |         target_databases: Sequence[str] | None = None,
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/mysql_adapter.py:79:9
   |
77 |         self,
78 |         instance,
79 |         connection,
   |         ^^^^^^^^^^
80 |         target_databases: Sequence[str] | None = None,
81 |     ) -> list[dict]:
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/adapters/mysql_adapter.py:107:25
    |
105 |             tablespace_stats = self._collect_tablespace_sizes(connection, instance)
106 |         except Exception as exc:  # pragma: no cover - defensive logging
107 |             self.logger.error(
    |                         ^^^^^
108 |                 "mysql_tablespace_collection_failed",
109 |                 instance=instance.name,
    |

ANN001 Missing type annotation for function argument `connection`
   --> app/services/database_sync/adapters/mysql_adapter.py:132:34
    |
130 |         return data
131 |
132 |     def _assert_permission(self, connection, instance) -> None:
    |                                  ^^^^^^^^^^
133 |         """验证 MySQL 权限.
    |

ANN001 Missing type annotation for function argument `instance`
   --> app/services/database_sync/adapters/mysql_adapter.py:132:46
    |
130 |         return data
131 |
132 |     def _assert_permission(self, connection, instance) -> None:
    |                                              ^^^^^^^^
133 |         """验证 MySQL 权限.
    |

C901 `_collect_tablespace_sizes` is too complex (15 > 10)
   --> app/services/database_sync/adapters/mysql_adapter.py:164:9
    |
162 |         )
163 |
164 |     def _collect_tablespace_sizes(self, connection, instance) -> dict[str, int]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
165 |         """采集 MySQL 表空间大小.
    |

PLR0912 Too many branches (15 > 12)
   --> app/services/database_sync/adapters/mysql_adapter.py:164:9
    |
162 |         )
163 |
164 |     def _collect_tablespace_sizes(self, connection, instance) -> dict[str, int]:
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
165 |         """采集 MySQL 表空间大小.
    |

ANN001 Missing type annotation for function argument `connection`
   --> app/services/database_sync/adapters/mysql_adapter.py:164:41
    |
162 |         )
163 |
164 |     def _collect_tablespace_sizes(self, connection, instance) -> dict[str, int]:
    |                                         ^^^^^^^^^^
165 |         """采集 MySQL 表空间大小.
    |

ANN001 Missing type annotation for function argument `instance`
   --> app/services/database_sync/adapters/mysql_adapter.py:164:53
    |
162 |         )
163 |
164 |     def _collect_tablespace_sizes(self, connection, instance) -> dict[str, int]:
    |                                                     ^^^^^^^^
165 |         """采集 MySQL 表空间大小.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/database_sync/adapters/mysql_adapter.py:218:20
    |
216 |                         view=label,
217 |                     )
218 |             except Exception as exc:
    |                    ^^^^^^^^^
219 |                 self.logger.warning(
220 |                     "mysql_tablespace_query_failed",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/database_sync/adapters/mysql_adapter.py:238:16
    |
236 |                         continue
237 |                     aggregated.setdefault(db_name, 0)
238 |         except Exception as exc:
    |                ^^^^^^^^^
239 |             self.logger.warning(
240 |                 "mysql_show_databases_failed",
    |

ANN001 Missing type annotation for function argument `instance`
   --> app/services/database_sync/adapters/mysql_adapter.py:248:45
    |
246 |         return aggregated
247 |
248 |     def _build_stats_from_tablespaces(self, instance, stats: dict[str, int]) -> list[dict]:
    |                                             ^^^^^^^^
249 |         """将表空间统计转换为标准容量数据.
    |

ANN001 Missing type annotation for function argument `instance`
   --> app/services/database_sync/adapters/mysql_adapter.py:323:41
    |
321 |         return re.sub(r"@([0-9A-Fa-f]{4})", _replace, raw_name)
322 |
323 |     def _build_tablespace_queries(self, instance) -> list[tuple[str, str]]:
    |                                         ^^^^^^^^
324 |         """构建表空间查询语句列表.
    |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/oracle_adapter.py:27:31
   |
25 |     """
26 |
27 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                               ^^^^^^^^
28 |         """列出 Oracle 实例当前的表空间清单.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/oracle_adapter.py:27:41
   |
25 |     """
26 |
27 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                                         ^^^^^^^^^^
28 |         """列出 Oracle 实例当前的表空间清单.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/oracle_adapter.py:71:9
   |
69 |     def fetch_capacity(
70 |         self,
71 |         instance,
   |         ^^^^^^^^
72 |         connection,
73 |         target_databases: Sequence[str] | None = None,
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/oracle_adapter.py:72:9
   |
70 |         self,
71 |         instance,
72 |         connection,
   |         ^^^^^^^^^^
73 |         target_databases: Sequence[str] | None = None,
74 |     ) -> list[dict]:
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/services/database_sync/adapters/postgresql_adapter.py:30:25
   |
28 |     """
29 |
30 |     _SYSTEM_DATABASES = {"postgres"}
   |                         ^^^^^^^^^^^^
31 |
32 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/postgresql_adapter.py:32:31
   |
30 |     _SYSTEM_DATABASES = {"postgres"}
31 |
32 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                               ^^^^^^^^
33 |         """列出 PostgreSQL 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/postgresql_adapter.py:32:41
   |
30 |     _SYSTEM_DATABASES = {"postgres"}
31 |
32 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                                         ^^^^^^^^^^
33 |         """列出 PostgreSQL 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/postgresql_adapter.py:77:9
   |
75 |     def fetch_capacity(
76 |         self,
77 |         instance,
   |         ^^^^^^^^
78 |         connection,
79 |         target_databases: Sequence[str] | None = None,
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/postgresql_adapter.py:78:9
   |
76 |         self,
77 |         instance,
78 |         connection,
   |         ^^^^^^^^^^
79 |         target_databases: Sequence[str] | None = None,
80 |     ) -> list[dict]:
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/sqlserver_adapter.py:27:31
   |
25 |     """
26 |
27 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                               ^^^^^^^^
28 |         """列出 SQL Server 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/sqlserver_adapter.py:27:41
   |
25 |     """
26 |
27 |     def fetch_inventory(self, instance, connection) -> list[dict]:
   |                                         ^^^^^^^^^^
28 |         """列出 SQL Server 实例当前的数据库清单.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/services/database_sync/adapters/sqlserver_adapter.py:71:9
   |
69 |     def fetch_capacity(
70 |         self,
71 |         instance,
   |         ^^^^^^^^
72 |         connection,
73 |         target_databases: Sequence[str] | None = None,
   |

ANN001 Missing type annotation for function argument `connection`
  --> app/services/database_sync/adapters/sqlserver_adapter.py:72:9
   |
70 |         self,
71 |         instance,
72 |         connection,
   |         ^^^^^^^^^^
73 |         target_databases: Sequence[str] | None = None,
74 |     ) -> list[dict]:
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/coordinator.py:105:25
    |
103 |                 return True
104 |         except Exception as exc:
105 |             self.logger.error(
    |                         ^^^^^
106 |                 "capacity_sync_connection_error",
107 |                 instance=self.instance.name,
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/database_sync/coordinator.py:130:20
    |
128 |             try:
129 |                 self._connection.disconnect()
130 |             except Exception as exc:
    |                    ^^^^^^^^^
131 |                 self.logger.warning(
132 |                     "capacity_sync_disconnect_error",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/coordinator.py:292:29
    |
290 |             except Exception as exc:
291 |                 db.session.rollback()
292 |                 self.logger.error(
    |                             ^^^^^
293 |                     "capacity_sync_commit_failed",
294 |                     instance=self.instance.name,
    |

D107 Missing docstring in `__init__`
  --> app/services/database_sync/database_filters.py:29:9
   |
27 |     """负责加载数据库发现/容量同步所需的过滤配置."""
28 |
29 |     def __init__(self, config_path: str | Path | None = None) -> None:
   |         ^^^^^^^^
30 |         self._config_path = Path(config_path) if config_path else _DEFAULT_CONFIG_PATH
31 |         self._normalized_rules: dict[str, dict[str, Any]] = {}
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/services/database_sync/database_filters.py:111:49
    |
109 |         return re.compile(regex, re.IGNORECASE)
110 |
111 |     def should_exclude_database(self, instance: Any, database_name: str | None) -> tuple[bool, str | None]:
    |                                                 ^^^
112 |         """判断给定实例下的数据库是否需要被过滤.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/services/database_sync/database_filters.py:143:47
    |
141 |         return False, None
142 |
143 |     def filter_database_names(self, instance: Any, names: Iterable[str]) -> tuple[list[str], list[str]]:
    |                                               ^^^
144 |         """过滤数据库名称,返回保留与排除列表.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/services/database_sync/database_filters.py:164:49
    |
162 |         return allowed, excluded
163 |
164 |     def filter_capacity_payload(self, instance: Any, payload: Sequence[dict[str, Any]]) -> tuple[list[dict[str, Any]], list[str]]:
    |                                                 ^^^
165 |         """过滤容量采集结果,返回保留记录与被排除的库名.
    |

E501 Line too long (130 > 120)
   --> app/services/database_sync/database_filters.py:164:121
    |
162 |         return allowed, excluded
163 |
164 |     def filter_capacity_payload(self, instance: Any, payload: Sequence[dict[str, Any]]) -> tuple[list[dict[str, Any]], list[str]]:
    |                                                                                                                         ^^^^^^^^^^
165 |         """过滤容量采集结果,返回保留记录与被排除的库名.
    |

ANN001 Missing type annotation for function argument `exc_type`
  --> app/services/database_sync/database_sync_service.py:58:24
   |
56 |         return self
57 |
58 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                        ^^^^^^^^
59 |         """退出上下文管理器,断开数据库连接.
   |

ANN001 Missing type annotation for function argument `exc_val`
  --> app/services/database_sync/database_sync_service.py:58:34
   |
56 |         return self
57 |
58 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                                  ^^^^^^^
59 |         """退出上下文管理器,断开数据库连接.
   |

ANN001 Missing type annotation for function argument `exc_tb`
  --> app/services/database_sync/database_sync_service.py:58:43
   |
56 |         return self
57 |
58 |     def __exit__(self, exc_type, exc_val, exc_tb) -> None:
   |                                           ^^^^^^
59 |         """退出上下文管理器,断开数据库连接.
   |

PLC0415 `import` should be at the top-level of a file
   --> app/services/database_sync/database_sync_service.py:209:5
    |
208 |     """
209 |     from app.models.instance import Instance
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
210 |
211 |     logger = get_system_logger()
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/database_sync_service.py:251:20
    |
249 |         except Exception as exc:
250 |             error_msg = f"实例 {instance.name} 采集失败: {exc}"
251 |             logger.error(
    |                    ^^^^^
252 |                 "capacity_collection_failed",
253 |                 instance=instance.name,
    |

D107 Missing docstring in `__init__`
  --> app/services/database_sync/inventory_manager.py:24:9
   |
22 |     """负责维护 instance_databases 表的增量同步逻辑."""
23 |
24 |     def __init__(self, filter_manager=database_sync_filter_manager) -> None:
   |         ^^^^^^^^
25 |         self.logger = get_system_logger()
26 |         self.filter_manager = filter_manager
   |

ANN001 Missing type annotation for function argument `filter_manager`
  --> app/services/database_sync/inventory_manager.py:24:24
   |
22 |     """负责维护 instance_databases 表的增量同步逻辑."""
23 |
24 |     def __init__(self, filter_manager=database_sync_filter_manager) -> None:
   |                        ^^^^^^^^^^^^^^
25 |         self.logger = get_system_logger()
26 |         self.filter_manager = filter_manager
   |

C901 `synchronize` is too complex (11 > 10)
  --> app/services/database_sync/inventory_manager.py:28:9
   |
26 |         self.filter_manager = filter_manager
27 |
28 |     def synchronize(
   |         ^^^^^^^^^^^
29 |         self,
30 |         instance: Instance,
   |

PLR0915 Too many statements (54 > 50)
  --> app/services/database_sync/inventory_manager.py:28:9
   |
26 |         self.filter_manager = filter_manager
27 |
28 |     def synchronize(
   |         ^^^^^^^^^^^
29 |         self,
30 |         instance: Instance,
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/inventory_manager.py:121:25
    |
119 |         except SQLAlchemyError as exc:
120 |             db.session.rollback()
121 |             self.logger.error(
    |                         ^^^^^
122 |                 "inventory_sync_commit_failed",
123 |                 instance=instance.name,
    |

D107 Missing docstring in `__init__`
  --> app/services/database_sync/persistence.py:27:9
   |
25 |     """负责容量采集相关的数据持久化."""
26 |
27 |     def __init__(self) -> None:
   |         ^^^^^^^^
28 |         self.logger = get_system_logger()
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/persistence.py:101:25
    |
 99 |         except SQLAlchemyError as exc:
100 |             db.session.rollback()
101 |             self.logger.error(
    |                         ^^^^^
102 |                 "save_database_stats_upsert_failed",
103 |                 instance=instance.name,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/persistence.py:118:25
    |
116 |         except SQLAlchemyError as exc:
117 |             db.session.rollback()
118 |             self.logger.error(
    |                         ^^^^^
119 |                 "save_database_stats_commit_failed",
120 |                 instance=instance.name,
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/database_sync/persistence.py:191:13
    |
189 |                 database_count=database_count,
190 |             )
191 |             return True
    |             ^^^^^^^^^^^
192 |         except SQLAlchemyError as exc:
193 |             self.logger.error(
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/persistence.py:193:25
    |
191 |             return True
192 |         except SQLAlchemyError as exc:
193 |             self.logger.error(
    |                         ^^^^^
194 |                 "save_instance_stats_failed",
195 |                 instance=instance.name,
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/services/database_sync/persistence.py:250:29
    |
248 |             except SQLAlchemyError as exc:
249 |                 db.session.rollback()
250 |                 self.logger.error(
    |                             ^^^^^
251 |                     "update_instance_total_size_commit_failed",
252 |                     instance=instance.name,
    |

D205 1 blank line required between summary line and description
 --> app/services/database_type_service.py:1:1
  |
1 | / """鲸落 - 数据库类型管理服务
2 | | 提供数据库类型的CRUD操作和业务逻辑.
3 | | """
  | |___^
4 |
5 |   from typing import Any
  |
help: Insert single blank line

PLR0911 Too many return statements (8 > 6)
  --> app/services/form_service/classification_rule_service.py:45:9
   |
43 |         return dict(payload or {})
44 |
45 |     def validate(self, data: dict[str, Any], *, resource: ClassificationRule | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
46 |         """校验分类规则数据.
   |

ARG002 Unused method argument: `data`
   --> app/services/form_service/classification_rule_service.py:118:56
    |
116 |         instance.is_active = data["is_active"]
117 |
118 |     def after_save(self, instance: ClassificationRule, data: dict[str, Any]) -> None:
    |                                                        ^^^^
119 |         """保存后记录日志并清除缓存.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/services/form_service/classification_rule_service.py:129:9
    |
128 |         """
129 |         from app.utils.structlog_config import log_info
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
130 |
131 |         log_info(
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/classification_rule_service.py:140:16
    |
138 |             service = AccountClassificationService()
139 |             service.invalidate_cache()
140 |         except Exception as exc:
    |                ^^^^^^^^^
141 |             log_info(
142 |                 "清除分类缓存失败",
    |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/classification_rule_service.py:148:32
    |
146 |             )
147 |
148 |     def build_context(self, *, resource: ClassificationRule | None) -> dict[str, Any]:
    |                                ^^^^^^^^
149 |         """构建模板渲染上下文.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `expression`
   --> app/services/form_service/classification_rule_service.py:167:49
    |
165 |         }
166 |
167 |     def _normalize_expression(self, expression: Any) -> str:
    |                                                 ^^^
168 |         """规范化规则表达式为 JSON 字符串.
    |

PLR0911 Too many return statements (7 > 6)
   --> app/services/form_service/classification_rule_service.py:183:9
    |
181 |         return json.dumps(parsed, ensure_ascii=False, sort_keys=True)
182 |
183 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |         ^^^^^^^^^^^^
184 |         """将值转换为布尔类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/form_service/classification_rule_service.py:183:35
    |
181 |         return json.dumps(parsed, ensure_ascii=False, sort_keys=True)
182 |
183 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
184 |         """将值转换为布尔类型.
    |

PLR0911 Too many return statements (7 > 6)
  --> app/services/form_service/classification_service.py:43:9
   |
41 |         return dict(payload or {})
42 |
43 |     def validate(self, data: dict[str, Any], *, resource: AccountClassification | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
44 |         """校验账户分类数据.
   |

E501 Line too long (121 > 120)
  --> app/services/form_service/classification_service.py:43:121
   |
41 |         return dict(payload or {})
42 |
43 |     def validate(self, data: dict[str, Any], *, resource: AccountClassification | None) -> ServiceResult[dict[str, Any]]:
   |                                                                                                                         ^
44 |         """校验账户分类数据.
   |

PLC0415 `import` should be at the top-level of a file
   --> app/services/form_service/classification_service.py:117:9
    |
115 |         """
116 |         action = "创建账户分类成功" if data.get("_is_create") else "更新账户分类成功"
117 |         from app.utils.structlog_config import log_info  # avoid circular import
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
118 |
119 |         log_info(
    |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/classification_service.py:126:32
    |
124 |         )
125 |
126 |     def build_context(self, *, resource: AccountClassification | None) -> dict[str, Any]:
    |                                ^^^^^^^^
127 |         """构建模板渲染上下文.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `raw_value`
   --> app/services/form_service/classification_service.py:146:42
    |
144 |         }
145 |
146 |     def _parse_priority(self, raw_value: Any, default: int) -> int:
    |                                          ^^^
147 |         """解析优先级值.
    |

C901 `validate` is too complex (11 > 10)
  --> app/services/form_service/credential_service.py:52:9
   |
50 |         return sanitize_form_data(payload or {})
51 |
52 |     def validate(self, data: dict[str, Any], *, resource: Credential | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
53 |         """校验凭据数据.
   |

PLR0911 Too many return statements (7 > 6)
  --> app/services/form_service/credential_service.py:52:9
   |
50 |         return sanitize_form_data(payload or {})
51 |
52 |     def validate(self, data: dict[str, Any], *, resource: Credential | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
53 |         """校验凭据数据.
   |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/credential_service.py:149:32
    |
147 |         )
148 |
149 |     def build_context(self, *, resource: Credential | None) -> dict[str, Any]:
    |                                ^^^^^^^^
150 |         """构建模板渲染上下文.
    |

E501 Line too long (127 > 120)
   --> app/services/form_service/credential_service.py:180:121
    |
178 |         normalized: dict[str, Any] = {}
179 |         normalized["name"] = (data.get("name") or (resource.name if resource else "")).strip()
180 |         normalized["credential_type"] = (data.get("credential_type") or (resource.credential_type if resource else "")).strip()
    |                                                                                                                         ^^^^^^^
181 |         normalized["username"] = (data.get("username") or (resource.username if resource else "")).strip()
    |

PLR0911 Too many return statements (7 > 6)
   --> app/services/form_service/credential_service.py:200:9
    |
198 |         return normalized
199 |
200 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |         ^^^^^^^^^^^^
201 |         """将值转换为布尔类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/form_service/credential_service.py:200:35
    |
198 |         return normalized
199 |
200 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
201 |         """将值转换为布尔类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `credential_raw`
   --> app/services/form_service/instance_service.py:150:54
    |
148 |     # Helpers
149 |     # ------------------------------------------------------------------ #
150 |     def _resolve_credential_id(self, credential_raw: Any) -> int | None:
    |                                                      ^^^
151 |         """解析凭据 ID.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `tag_field`
   --> app/services/form_service/instance_service.py:177:47
    |
175 |         return credential_id
176 |
177 |     def _normalize_tag_names(self, tag_field: Any) -> list[str]:
    |                                               ^^^
178 |         """规范化标签名称列表.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/instance_service.py:261:16
    |
259 |                     tags=added,
260 |                 )
261 |         except Exception as exc:
    |                ^^^^^^^^^
262 |             db.session.rollback()
263 |             log_error(
    |

PLR0911 Too many return statements (7 > 6)
  --> app/services/form_service/password_service.py:43:9
   |
41 |         return sanitize_form_data(payload or {})
42 |
43 |     def validate(self, data: dict[str, Any], *, resource: User | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
44 |         """校验密码修改数据.
   |

ARG002 Unused method argument: `instance`
  --> app/services/form_service/password_service.py:94:26
   |
92 |         instance.set_password(data["new_password"])
93 |
94 |     def after_save(self, instance: User, data: dict[str, Any]) -> None:
   |                          ^^^^^^^^
95 |         """保存后记录日志.
   |

ARG002 Unused method argument: `data`
  --> app/services/form_service/password_service.py:94:42
   |
92 |         instance.set_password(data["new_password"])
93 |
94 |     def after_save(self, instance: User, data: dict[str, Any]) -> None:
   |                                          ^^^^
95 |         """保存后记录日志.
   |

E501 Line too long (131 > 120)
   --> app/services/form_service/password_service.py:125:117
    |
123 | …rce)
124 | …
125 | …"验证失败", message_key=validation.message_key, extra=validation.extra)
    |                                                              ^^^^^^^^^^^
126 | …
127 | …
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/form_service/password_service.py:136:16
    |
134 |             db.session.add(instance)
135 |             db.session.commit()
136 |         except Exception as exc:
    |                ^^^^^^^^^
137 |             db.session.rollback()
138 |             return ServiceResult.fail("密码修改失败,请稍后再试", extra={"exception": str(exc)})
    |

D205 1 blank line required between summary line and description
 --> app/services/form_service/resource_service.py:1:1
  |
1 | / """通用资源表单服务基类.
2 | | ---------------------------------
3 | | 负责封装表单校验、模型赋值、数据库提交与统一的结果返回.
4 | | """
  | |___^
5 |
6 |   from __future__ import annotations
  |
help: Insert single blank line

ARG002 Unused method argument: `resource`
   --> app/services/form_service/resource_service.py:125:49
    |
123 |         return dict(payload or {})
124 |
125 |     def validate(self, data: dict[str, Any], *, resource: TModel | None) -> ServiceResult[dict[str, Any]]:
    |                                                 ^^^^^^^^
126 |         """子类应该实现具体校验逻辑.
    |

ARG002 Unused method argument: `instance`
   --> app/services/form_service/resource_service.py:154:26
    |
152 |         raise NotImplementedError
153 |
154 |     def after_save(self, instance: TModel, data: dict[str, Any]) -> None:
    |                          ^^^^^^^^
155 |         """保存成功后的钩子(可选).
    |

ARG002 Unused method argument: `data`
   --> app/services/form_service/resource_service.py:154:44
    |
152 |         raise NotImplementedError
153 |
154 |     def after_save(self, instance: TModel, data: dict[str, Any]) -> None:
    |                                            ^^^^
155 |         """保存成功后的钩子(可选).
    |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/resource_service.py:167:32
    |
165 |         return
166 |
167 |     def build_context(self, *, resource: TModel | None) -> dict[str, Any]:
    |                                ^^^^^^^^
168 |         """提供模板渲染所需的额外上下文.
    |

E501 Line too long (131 > 120)
   --> app/services/form_service/resource_service.py:198:117
    |
196 | …rce)
197 | …
198 | …"验证失败", message_key=validation.message_key, extra=validation.extra)
    |                                                              ^^^^^^^^^^^
199 | …
200 | …
    |

G004 Logging statement uses f-string
   --> app/services/form_service/resource_service.py:208:42
    |
206 |         except SQLAlchemyError as exc:
207 |             db.session.rollback()
208 |             current_app.logger.exception(f"资源表单保存失败: {self.__class__.__name__}")
    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
209 |             return ServiceResult.fail("保存失败,请稍后再试", extra={"exception": str(exc)})
    |
help: Convert to lazy `%` formatting

PGH003 Use specific rule codes when ignoring type issues
  --> app/services/form_service/scheduler_job_service.py:72:38
   |
71 |         """
72 |         scheduler = get_scheduler()  # type: ignore
   |                                      ^^^^^^^^^^^^^^
73 |         if not scheduler.running:
74 |             log_error("调度器未启动,无法加载任务", module="scheduler")
   |

ARG002 Unused method argument: `data`
   --> app/services/form_service/scheduler_job_service.py:128:52
    |
126 |         scheduler.modify_job(job.id, trigger=data["trigger"])
127 |
128 |     def after_save(self, instance: dict[str, Any], data: dict[str, Any]) -> None:
    |                                                    ^^^^
129 |         """触发器更新后的善后处理,负责记录下一次执行时间.
    |

E501 Line too long (122 > 120)
   --> app/services/form_service/scheduler_job_service.py:150:121
    |
148 |         )
149 |
150 |     def upsert(self, payload: Mapping[str, Any], resource: dict[str, Any] | None = None) -> ServiceResult[dict[str, Any]]:
    |                                                                                                                         ^^
151 |         """更新内置任务的触发器配置.
    |

E501 Line too long (131 > 120)
   --> app/services/form_service/scheduler_job_service.py:164:117
    |
162 | …rce)
163 | …
164 | …"验证失败", message_key=validation.message_key, extra=validation.extra)
    |                                                              ^^^^^^^^^^^
165 | …
166 | …
    |

C901 `_build_trigger` is too complex (28 > 10)
   --> app/services/form_service/scheduler_job_service.py:180:9
    |
178 |         return ServiceResult.ok(resource)
179 |
180 |     def _build_trigger(self, data: Mapping[str, Any]) -> CronTrigger | IntervalTrigger | DateTrigger | None:
    |         ^^^^^^^^^^^^^^
181 |         """根据表单数据构建 APScheduler 触发器.
    |

PLR0911 Too many return statements (10 > 6)
   --> app/services/form_service/scheduler_job_service.py:180:9
    |
178 |         return ServiceResult.ok(resource)
179 |
180 |     def _build_trigger(self, data: Mapping[str, Any]) -> CronTrigger | IntervalTrigger | DateTrigger | None:
    |         ^^^^^^^^^^^^^^
181 |         """根据表单数据构建 APScheduler 触发器.
    |

PLR0912 Too many branches (24 > 12)
   --> app/services/form_service/scheduler_job_service.py:180:9
    |
178 |         return ServiceResult.ok(resource)
179 |
180 |     def _build_trigger(self, data: Mapping[str, Any]) -> CronTrigger | IntervalTrigger | DateTrigger | None:
    |         ^^^^^^^^^^^^^^
181 |         """根据表单数据构建 APScheduler 触发器.
    |

PLR0915 Too many statements (69 > 50)
   --> app/services/form_service/scheduler_job_service.py:180:9
    |
178 |         return ServiceResult.ok(resource)
179 |
180 |     def _build_trigger(self, data: Mapping[str, Any]) -> CronTrigger | IntervalTrigger | DateTrigger | None:
    |         ^^^^^^^^^^^^^^
181 |         """根据表单数据构建 APScheduler 触发器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `pick`
   --> app/services/form_service/scheduler_job_service.py:197:37
    |
195 |             parts: list[str] = expr.split() if expr else []
196 |
197 |             def pick(*keys: str) -> Any:
    |                                     ^^^
198 |                 for key in keys:
199 |                     value = data.get(key)
    |

PLR2004 Magic value used in comparison, consider replacing `7` with a constant variable
   --> app/services/form_service/scheduler_job_service.py:212:30
    |
210 |             year = pick("year")
211 |
212 |             if len(parts) == 7:
    |                              ^
213 |                 second, minute, hour, day, month, day_of_week, year = [
214 |                     pick_value or part
    |

PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   --> app/services/form_service/scheduler_job_service.py:221:32
    |
219 |                     )
220 |                 ]
221 |             elif len(parts) == 6:
    |                                ^
222 |                 second, minute, hour, day, month, day_of_week = [
223 |                     pick_value or part
    |

PLR2004 Magic value used in comparison, consider replacing `5` with a constant variable
   --> app/services/form_service/scheduler_job_service.py:230:32
    |
228 |                     )
229 |                 ]
230 |             elif len(parts) == 5:
    |                                ^
231 |                 minute, hour, day, month, day_of_week = [
232 |                     pick_value or part
    |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/tag_service.py:125:32
    |
123 |         )
124 |
125 |     def build_context(self, *, resource: Tag | None) -> dict[str, Any]:
    |                                ^^^^^^^^
126 |         """构建模板渲染上下文.
    |

PLR0911 Too many return statements (7 > 6)
   --> app/services/form_service/tag_service.py:175:9
    |
173 |         return normalized
174 |
175 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |         ^^^^^^^^^^^^
176 |         """将值转换为布尔类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/form_service/tag_service.py:175:35
    |
173 |         return normalized
174 |
175 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
176 |         """将值转换为布尔类型.
    |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/services/form_service/user_service.py:35:21
   |
33 |     model = User
34 |     USERNAME_PATTERN = re.compile(r"^[A-Za-z0-9_]{3,20}$")
35 |     ALLOWED_ROLES = {UserRole.ADMIN, UserRole.USER}
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
36 |     MESSAGE_USERNAME_EXISTS = "USERNAME_EXISTS"
37 |     MESSAGE_LAST_ADMIN_REQUIRED = "LAST_ADMIN_REQUIRED"
   |

C901 `validate` is too complex (11 > 10)
  --> app/services/form_service/user_service.py:51:9
   |
49 |         return sanitize_form_data(payload or {})
50 |
51 |     def validate(self, data: dict[str, Any], *, resource: User | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
52 |         """校验用户数据.
   |

PLR0911 Too many return statements (8 > 6)
  --> app/services/form_service/user_service.py:51:9
   |
49 |         return sanitize_form_data(payload or {})
50 |
51 |     def validate(self, data: dict[str, Any], *, resource: User | None) -> ServiceResult[dict[str, Any]]:
   |         ^^^^^^^^
52 |         """校验用户数据.
   |

ARG002 Unused method argument: `resource`
   --> app/services/form_service/user_service.py:141:32
    |
139 |         )
140 |
141 |     def build_context(self, *, resource: User | None) -> dict[str, Any]:
    |                                ^^^^^^^^
142 |         """构建模板渲染上下文.
    |

ANN202 Missing return type annotation for private function `_user_query`
   --> app/services/form_service/user_service.py:199:9
    |
197 |         return data.get("role") == UserRole.ADMIN and bool(data.get("is_active", True))
198 |
199 |     def _user_query(self):
    |         ^^^^^^^^^^^
200 |         """暴露 user query,便于单测注入."""
201 |         return User.query
    |
help: Add return type annotation

PLR0911 Too many return statements (7 > 6)
   --> app/services/form_service/user_service.py:203:9
    |
201 |         return User.query
202 |
203 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |         ^^^^^^^^^^^^
204 |         """将值转换为布尔类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/services/form_service/user_service.py:203:35
    |
201 |         return User.query
202 |
203 |     def _coerce_bool(self, value: Any, *, default: bool) -> bool:
    |                                   ^^^
204 |         """将值转换为布尔类型.
    |

PLR2004 Magic value used in comparison, consider replacing `8` with a constant variable
   --> app/services/form_service/user_service.py:241:28
    |
240 |         """
241 |         if len(password) < 8:
    |                            ^
242 |             return "密码长度至少8位"
243 |         if not any(char.isupper() for char in password):
    |

C901 `create_instances` is too complex (11 > 10)
  --> app/services/instances/batch_service.py:60:9
   |
58 |     """
59 |
60 |     def create_instances(
   |         ^^^^^^^^^^^^^^^^
61 |         self,
62 |         instances_data: list[dict[str, Any]],
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/instances/batch_service.py:299:13
    |
297 |             stats["deleted_sync_data"] = stats["deleted_account_permissions"]
298 |
299 |             return stats
    |             ^^^^^^^^^^^^
300 |         except SQLAlchemyError as exc:
301 |             db.session.rollback()
    |

INP001 File `app/services/ledgers/database_ledger_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/ledgers/database_ledger_service.py:1:1

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `session`
  --> app/services/ledgers/database_ledger_service.py:35:36
   |
33 |     MAX_TREND_DAYS = 90
34 |
35 |     def __init__(self, *, session: Any | None = None) -> None:
   |                                    ^^^^^^^^^^
36 |         """初始化服务.
   |

TRY300 Consider moving this statement to an `else` block
   --> app/services/ledgers/database_ledger_service.py:97:13
    |
 95 |               ]
 96 |
 97 | /             return {
 98 | |                 "items": rows,
 99 | |                 "total": total,
100 | |                 "page": page,
101 | |                 "per_page": per_page,
102 | |             }
    | |_____________^
103 |           except Exception as exc:
104 |               log_error(
    |

ANN202 Missing return type annotation for private function `_base_query`
   --> app/services/ledgers/database_ledger_service.py:219:9
    |
217 |         }
218 |
219 |     def _base_query(self):
    |         ^^^^^^^^^^^
220 |         """构造基础查询."""
221 |         return (
    |
help: Add return type annotation

ANN202 Missing return type annotation for private function `_apply_filters`
   --> app/services/ledgers/database_ledger_service.py:231:9
    |
229 |         )
230 |
231 |     def _apply_filters(
    |         ^^^^^^^^^^^^^^
232 |         self,
233 |         query,
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `query`
   --> app/services/ledgers/database_ledger_service.py:233:9
    |
231 |     def _apply_filters(
232 |         self,
233 |         query,
    |         ^^^^^
234 |         *,
235 |         search: str = "",
    |

ANN202 Missing return type annotation for private function `_with_latest_stats`
   --> app/services/ledgers/database_ledger_service.py:278:9
    |
276 |         return query
277 |
278 |     def _with_latest_stats(self, query):
    |         ^^^^^^^^^^^^^^^^^^
279 |         """为查询附加最新容量信息."""
280 |         latest_stats = (
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `query`
   --> app/services/ledgers/database_ledger_service.py:278:34
    |
276 |         return query
277 |
278 |     def _with_latest_stats(self, query):
    |                                  ^^^^^
279 |         """为查询附加最新容量信息."""
280 |         latest_stats = (
    |

ANN001 Missing type annotation for function argument `collected_at`
   --> app/services/ledgers/database_ledger_service.py:318:9
    |
316 |         record: InstanceDatabase,
317 |         instance: Instance,
318 |         collected_at,
    |         ^^^^^^^^^^^^
319 |         size_mb,
320 |         tags: list[dict[str, Any]] | None = None,
    |

ANN001 Missing type annotation for function argument `size_mb`
   --> app/services/ledgers/database_ledger_service.py:319:9
    |
317 |         instance: Instance,
318 |         collected_at,
319 |         size_mb,
    |         ^^^^^^^
320 |         tags: list[dict[str, Any]] | None = None,
321 |     ) -> dict[str, Any]:
    |

ANN001 Missing type annotation for function argument `collected_at`
   --> app/services/ledgers/database_ledger_service.py:404:36
    |
402 |         return mapping
403 |
404 |     def _resolve_sync_status(self, collected_at) -> dict[str, str]:
    |                                    ^^^^^^^^^^^^
405 |         """根据采集时间生成同步状态.
    |

PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   --> app/services/ledgers/database_ledger_service.py:422:27
    |
420 |         delay_hours = (now - collected_at).total_seconds() / 3600
421 |
422 |         if delay_hours <= 6:
    |                           ^
423 |             return {"value": SyncStatus.COMPLETED, "label": "已更新", "variant": "success"}
424 |         if delay_hours <= 48:
    |

PLR2004 Magic value used in comparison, consider replacing `48` with a constant variable
   --> app/services/ledgers/database_ledger_service.py:424:27
    |
422 |         if delay_hours <= 6:
423 |             return {"value": SyncStatus.COMPLETED, "label": "已更新", "variant": "success"}
424 |         if delay_hours <= 48:
    |                           ^^
425 |             return {"value": SyncStatus.RUNNING, "label": "待刷新", "variant": "warning"}
426 |         return {"value": SyncStatus.FAILED, "label": "超时", "variant": "danger"}
    |

PLR2004 Magic value used in comparison, consider replacing `1024` with a constant variable
   --> app/services/ledgers/database_ledger_service.py:442:23
    |
440 |         if size_mb is None:
441 |             return "未采集"
442 |         if size_mb >= 1024:
    |                       ^^^^
443 |             size_gb = size_mb / 1024
444 |             return f"{size_gb:.2f} GB"
    |

D205 1 blank line required between summary line and description
 --> app/services/partition_management_service.py:1:1
  |
1 | / """分区管理服务
2 | | 负责创建、清理与查询数据库容量相关表的分区信息.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

TC003 Move standard library import `types.TracebackType` into a type-checking block
  --> app/services/partition_management_service.py:10:19
   |
 8 | from dataclasses import asdict, dataclass, field
 9 | from datetime import date, datetime, timedelta, timezone
10 | from types import TracebackType
   |                   ^^^^^^^^^^^^^
11 | from typing import Any
   |
help: Move into type-checking block

D107 Missing docstring in `__init__`
  --> app/services/partition_management_service.py:48:9
   |
46 |     """PostgreSQL 分区管理服务."""
47 |
48 |     def __init__(self) -> None:
   |         ^^^^^^^^
49 |         self.tables: dict[str, dict[str, str]] = {
50 |             "stats": {
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/partition_management_service.py:185:20
    |
183 |                     exception=exc,
184 |                 )
185 |             except Exception as exc:  # pragma: no cover - 防御性分支
    |                    ^^^^^^^^^
186 |                 failures.append(
187 |                     {
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/partition_management_service.py:283:20
    |
281 |                     issues=exc.extra,
282 |                 )
283 |             except Exception as exc:
    |                    ^^^^^^^^^
284 |                 issues.append({"month": target_month.isoformat(), "message": str(exc)})
285 |                 log_error(
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/partition_management_service.py:374:24
    |
372 |                         exception=exc,
373 |                     )
374 |                 except Exception as exc:  # pragma: no cover - 防御性分支
    |                        ^^^^^^^^^
375 |                     failures.append(
376 |                         {
    |

PLR2004 Magic value used in comparison, consider replacing `12` with a constant variable
   --> app/services/partition_management_service.py:436:33
    |
434 |         """
435 |         month_start = target_date.replace(day=1)
436 |         if month_start.month == 12:
    |                                 ^^
437 |             month_end = month_start.replace(year=month_start.year + 1, month=1)
438 |         else:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/partition_management_service.py:498:20
    |
496 |                     },
497 |                 )
498 |             except Exception as exc:  # pragma: no cover - 单条记录失败不影响总体
    |                    ^^^^^^^^^
499 |                 log_warning(
500 |                     "处理单个分区信息失败",
    |

UP017 [*] Use `datetime.UTC` alias
   --> app/services/partition_management_service.py:584:37
    |
582 |                 partition_date = (
583 |                     datetime.strptime(date_str, "%Y/%m/%d")
584 |                     .replace(tzinfo=timezone.utc)
    |                                     ^^^^^^^^^^^^
585 |                     .date()
586 |                 )
    |
help: Convert to `datetime.UTC` alias

TRY300 Consider moving this statement to an `else` block
   --> app/services/partition_management_service.py:608:13
    |
606 |             date_part = partition_name.replace(prefix, "")
607 |             year, month, *_ = date_part.split("_")
608 |             return f"{year}/{month}/01"
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
609 |         except ValueError:
610 |             return None
    |

S608 Possible SQL injection vector through string-based query construction
   --> app/services/partition_management_service.py:622:17
    |
621 |         """
622 |         query = f"SELECT COUNT(*) FROM {partition_name};"
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
623 |         try:
624 |             result = db.session.execute(text(query)).scalar()
    |

UP017 [*] Use `datetime.UTC` alias
   --> app/services/partition_management_service.py:651:33
    |
649 |             partition_date = (
650 |                 datetime.strptime(date_str, "%Y/%m/%d")
651 |                 .replace(tzinfo=timezone.utc)
    |                                 ^^^^^^^^^^^^
652 |                 .date()
653 |             )
    |
help: Convert to `datetime.UTC` alias

PLR2004 Magic value used in comparison, consider replacing `1024` with a constant variable
   --> app/services/partition_management_service.py:732:25
    |
731 |         """
732 |         if size_bytes < 1024:
    |                         ^^^^
733 |             return f"{size_bytes} B"
734 |         if size_bytes < 1024**2:
    |

UP037 [*] Remove quotes from type annotation
   --> app/services/partition_management_service.py:753:36
    |
751 |         """
752 |         class _RollbackContext(AbstractContextManager[None]):
753 |             def __enter__(self) -> "_RollbackContext":
    |                                    ^^^^^^^^^^^^^^^^^^
754 |                 return self
    |
help: Remove quotes

INP001 File `app/services/statistics/account_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/account_statistics_service.py:1:1

INP001 File `app/services/statistics/database_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/database_statistics_service.py:1:1

TRY300 Consider moving this statement to an `else` block
  --> app/services/statistics/database_statistics_service.py:67:9
   |
65 |           deleted_databases = deleted_databases.scalar() or 0
66 |
67 | /         return {
68 | |             "total_databases": total_databases,
69 | |             "active_databases": active_databases,
70 | |             "inactive_databases": inactive_databases,
71 | |             "deleted_databases": deleted_databases,
72 | |         }
   | |_________^
73 |       except Exception as exc:
74 |           log_error("获取数据库统计失败", module="database_statistics", exception=exc)
   |

C901 `fetch_aggregations` is too complex (12 > 10)
  --> app/services/statistics/database_statistics_service.py:94:5
   |
94 | def fetch_aggregations(
   |     ^^^^^^^^^^^^^^^^^^
95 |     *,
96 |     instance_id: int | None,
   |

PLR0913 Too many arguments in function definition (11 > 5)
  --> app/services/statistics/database_statistics_service.py:94:5
   |
94 | def fetch_aggregations(
   |     ^^^^^^^^^^^^^^^^^^
95 |     *,
96 |     instance_id: int | None,
   |

PLR0912 Too many branches (13 > 12)
  --> app/services/statistics/database_statistics_service.py:94:5
   |
94 | def fetch_aggregations(
   |     ^^^^^^^^^^^^^^^^^^
95 |     *,
96 |     instance_id: int | None,
   |

E501 Line too long (129 > 120)
   --> app/services/statistics/database_statistics_service.py:199:121
    |
197 |             pair_values = [(row.instance_id, row.database_name) for row in top_pairs]
198 |             aggregations = (
199 |                 query.filter(tuple_(DatabaseSizeAggregation.instance_id, DatabaseSizeAggregation.database_name).in_(pair_values))
    |                                                                                                                         ^^^^^^^^^
200 |                 .order_by(DatabaseSizeAggregation.period_start.asc())
201 |                 .all()
    |

C901 `fetch_aggregation_summary` is too complex (11 > 10)
   --> app/services/statistics/database_statistics_service.py:235:5
    |
235 | def fetch_aggregation_summary(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
236 |     *,
237 |     instance_id: int | None,
    |

PLR0913 Too many arguments in function definition (7 > 5)
   --> app/services/statistics/database_statistics_service.py:235:5
    |
235 | def fetch_aggregation_summary(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
236 |     *,
237 |     instance_id: int | None,
    |

INP001 File `app/services/statistics/instance_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/instance_statistics_service.py:1:1

TRY300 Consider moving this statement to an `else` block
  --> app/services/statistics/instance_statistics_service.py:55:9
   |
53 |           normal_instances = active_instances
54 |
55 | /         return {
56 | |             "total_instances": total_instances,
57 | |             "active_instances": active_instances,
58 | |             "normal_instances": normal_instances,
59 | |             "disabled_instances": disabled_instances,
60 | |             "deleted_instances": deleted_instances,
61 | |         }
   | |_________^
62 |       except Exception as exc:
63 |           log_error("获取实例汇总失败", module="instance_statistics", exception=exc)
   |

PLC0415 `import` should be at the top-level of a file
  --> app/services/statistics/instance_statistics_service.py:89:9
   |
87 |     """
88 |     try:
89 |         from app.models.instance_size_stat import InstanceSizeStat
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
90 |
91 |         recent_date = time_utils.now_china().date() - timedelta(days=recent_days)
   |

INP001 File `app/services/statistics/log_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/log_statistics_service.py:1:1

SIM118 Use `key in dict` instead of `key in dict.keys()`
   --> app/services/statistics/log_statistics_service.py:110:61
    |
108 |         result_mapping: dict[str, Any] = {}
109 |         if result is not None:
110 |             result_mapping = {key: getattr(result, key) for key in result.keys()}
    |                                                             ^^^^^^^^^^^^^^^^^^^^
111 |
112 |         trend_data: list[dict[str, int | str]] = []
    |
help: Remove `.keys()`

TRY300 Consider moving this statement to an `else` block
   --> app/services/statistics/log_statistics_service.py:122:9
    |
120 |             )
121 |
122 |         return trend_data
    |         ^^^^^^^^^^^^^^^^^
123 |     except Exception as exc:
124 |         log_error("获取日志趋势数据失败", module="log_statistics", exception=exc)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/statistics/log_statistics_service.py:123:12
    |
122 |         return trend_data
123 |     except Exception as exc:
    |            ^^^^^^^^^
124 |         log_error("获取日志趋势数据失败", module="log_statistics", exception=exc)
125 |         return []
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/services/statistics/log_statistics_service.py:154:12
    |
153 |         return [{"level": stat.level.value, "count": stat.count} for stat in level_stats]
154 |     except Exception as exc:
    |            ^^^^^^^^^
155 |         log_error("获取日志级别分布失败", module="log_statistics", exception=exc)
156 |         return []
    |

INP001 File `app/services/statistics/partition_statistics_service.py` is part of an implicit namespace package. Add an `__init__.py`.
--> app/services/statistics/partition_statistics_service.py:1:1

D205 1 blank line required between summary line and description
 --> app/services/sync_session_service.py:1:1
  |
1 | / """鲸落 - 同步会话服务
2 | | 管理同步会话和实例记录的业务逻辑.
3 | | """
  | |___^
4 |
5 |   from typing import Any
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/services/sync_session_service.py:30:9
   |
28 |     """
29 |
30 |     def __init__(self) -> None:
   |         ^^^^^^^^
31 |         self.system_logger = get_system_logger()
32 |         self.sync_logger = get_sync_logger()
   |

ANN202 Missing return type annotation for private function `clean_value`
  --> app/services/sync_session_service.py:50:13
   |
48 |             return None
49 |
50 |         def clean_value(value):
   |             ^^^^^^^^^^^
51 |             if hasattr(value, "isoformat"):  # datetime 或 date 对象
52 |                 return value.isoformat()
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `value`
  --> app/services/sync_session_service.py:50:25
   |
48 |             return None
49 |
50 |         def clean_value(value):
   |                         ^^^^^
51 |             if hasattr(value, "isoformat"):  # datetime 或 date 对象
52 |                 return value.isoformat()
   |

E501 Line too long (123 > 120)
  --> app/services/sync_session_service.py:61:121
   |
59 |         return clean_value(sync_details)
60 |
61 |     def create_session(self, sync_type: str, sync_category: str = "account", created_by: int | None = None) -> SyncSession:
   |                                                                                                                         ^^^
62 |         """创建同步会话.
   |

TRY300 Consider moving this statement to an `else` block
  --> app/services/sync_session_service.py:95:13
   |
93 |             )
94 |
95 |             return session
   |             ^^^^^^^^^^^^^^
96 |         except Exception as e:
97 |             db.session.rollback()
   |

E501 Line too long (137 > 120)
   --> app/services/sync_session_service.py:107:121
    |
105 | …
106 | …
107 | …s: list[int], sync_category: str = "account") -> list[SyncInstanceRecord]:
    |                                                           ^^^^^^^^^^^^^^^^^
108 | …
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:152:13
    |
150 |             )
151 |
152 |             return records
    |             ^^^^^^^^^^^^^^
153 |         except Exception as e:
154 |             db.session.rollback()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:192:13
    |
190 |             )
191 |
192 |             return True
    |             ^^^^^^^^^^^
193 |         except Exception as e:
194 |             db.session.rollback()
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/services/sync_session_service.py:203:9
    |
201 |             return False
202 |
203 |     def complete_instance_sync(
    |         ^^^^^^^^^^^^^^^^^^^^^^
204 |         self,
205 |         record_id: int,
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:257:13
    |
255 |             )
256 |
257 |             return True
    |             ^^^^^^^^^^^
258 |         except Exception as e:
259 |             db.session.rollback()
    |

E501 Line too long (121 > 120)
   --> app/services/sync_session_service.py:268:121
    |
266 |             return False
267 |
268 |     def fail_instance_sync(self, record_id: int, error_message: str, sync_details: dict[str, Any] | None = None) -> bool:
    |                                                                                                                         ^
269 |         """标记实例同步失败.
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:302:13
    |
300 |             )
301 |
302 |             return True
    |             ^^^^^^^^^^^
303 |         except Exception as e:
304 |             db.session.rollback()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/services/sync_session_service.py:495:13
    |
493 |                 self.sync_logger.info("取消同步会话", module="sync_session", session_id=session_id)
494 |
495 |             return True
    |             ^^^^^^^^^^^
496 |         except Exception as e:
497 |             db.session.rollback()
    |

PLR0915 Too many statements (66 > 50)
  --> app/tasks/accounts_sync_tasks.py:15:5
   |
15 | def sync_accounts(*, manual_run: bool = False, created_by: int | None = None, **kwargs: Any) -> None:
   |     ^^^^^^^^^^^^^
16 |     """同步账户任务 - 同步所有实例的账户信息.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> app/tasks/accounts_sync_tasks.py:15:89
   |
15 | def sync_accounts(*, manual_run: bool = False, created_by: int | None = None, **kwargs: Any) -> None:
   |                                                                                         ^^^
16 |     """同步账户任务 - 同步所有实例的账户信息.
   |

E501 Line too long (136 > 120)
   --> app/tasks/accounts_sync_tasks.py:115:121
    |
113 | …         continue
114 | …     except PermissionSyncError as permission_error:
115 | …         sync_session_service.fail_instance_sync(record.id, str(permission_error), sync_details=permission_error.summary)
    |                                                                                                           ^^^^^^^^^^^^^^^^
116 | …         sync_logger.exception(
117 | …             "账户同步权限阶段失败",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/accounts_sync_tasks.py:169:33
    |
167 |                     sync_session_service.fail_instance_sync(record.id, str(exc))
168 |
169 |                     sync_logger.error(
    |                                 ^^^^^
170 |                         "实例账户同步异常",
171 |                         module="accounts_sync",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/accounts_sync_tasks.py:205:25
    |
203 |                 db.session.commit()
204 |
205 |             sync_logger.error(
    |                         ^^^^^
206 |                 "账户同步任务失败",
207 |                 module="accounts_sync",
    |

D205 1 blank line required between summary line and description
 --> app/tasks/capacity_aggregation_tasks.py:1:1
  |
1 | / """数据库大小统计聚合定时任务
2 | | 负责计算每周、每月、每季度的统计聚合数据.
3 | | """
  | |___^
4 |
5 |   from collections.abc import Sequence
  |
help: Insert single blank line

ANN001 Missing type annotation for function argument `logger`
  --> app/tasks/capacity_aggregation_tasks.py:29:54
   |
29 | def _select_periods(requested: Sequence[str] | None, logger, allowed_periods: Sequence[str]) -> list[str]:
   |                                                      ^^^^^^
30 |     """根据请求的周期返回有效周期列表.
   |

C901 `calculate_database_size_aggregations` is too complex (24 > 10)
   --> app/tasks/capacity_aggregation_tasks.py:111:5
    |
111 | def calculate_database_size_aggregations(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |     *,
113 |     manual_run: bool = False,
    |

PLR0912 Too many branches (28 > 12)
   --> app/tasks/capacity_aggregation_tasks.py:111:5
    |
111 | def calculate_database_size_aggregations(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |     *,
113 |     manual_run: bool = False,
    |

PLR0915 Too many statements (111 > 50)
   --> app/tasks/capacity_aggregation_tasks.py:111:5
    |
111 | def calculate_database_size_aggregations(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
112 |     *,
113 |     manual_run: bool = False,
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_aggregation_tasks.py:528:13
    |
526 |                 message=result.get("message"),
527 |             )
528 |             return result
    |             ^^^^^^^^^^^^^
529 |
530 |         except Exception as exc:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:530:16
    |
528 |             return result
529 |
530 |         except Exception as exc:
    |                ^^^^^^^^^
531 |             log_error(
532 |                 "计算实例统计聚合失败",
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_aggregation_tasks.py:581:13
    |
579 |             )
580 |
581 |             return result
    |             ^^^^^^^^^^^^^
582 |
583 |         except Exception as exc:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:583:16
    |
581 |             return result
582 |
583 |         except Exception as exc:
    |                ^^^^^^^^^
584 |             log_error(
585 |                 "计算指定周期统计聚合失败",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:635:16
    |
633 |             }
634 |
635 |         except Exception as exc:
    |                ^^^^^^^^^
636 |             log_error(
637 |                 "获取聚合状态失败",
    |

PLR2004 Magic value used in comparison, consider replacing `23` with a constant variable
   --> app/tasks/capacity_aggregation_tasks.py:664:96
    |
662 |         # 检查聚合时间配置
663 |         aggregation_hour = getattr(Config, "AGGREGATION_HOUR", 4)
664 |         if not isinstance(aggregation_hour, int) or aggregation_hour < 0 or aggregation_hour > 23:
    |                                                                                                ^^
665 |             config_issues.append("聚合时间配置无效,应为0-23之间的整数")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_aggregation_tasks.py:680:12
    |
678 |         }
679 |
680 |     except Exception as exc:
    |            ^^^^^^^^^
681 |         log_error(
682 |             "验证聚合配置失败",
    |

D205 1 blank line required between summary line and description
 --> app/tasks/capacity_collection_tasks.py:1:1
  |
1 | / """数据库大小采集定时任务
2 | | 负责每日自动采集所有数据库实例的大小信息.
3 | | """
  | |___^
4 |
5 |   from typing import Any
  |
help: Insert single blank line

C901 `collect_database_sizes` is too complex (12 > 10)
  --> app/tasks/capacity_collection_tasks.py:19:5
   |
19 | def collect_database_sizes():
   |     ^^^^^^^^^^^^^^^^^^^^^^
20 |     """容量同步定时任务.
   |

PLR0915 Too many statements (97 > 50)
  --> app/tasks/capacity_collection_tasks.py:19:5
   |
19 | def collect_database_sizes():
   |     ^^^^^^^^^^^^^^^^^^^^^^
20 |     """容量同步定时任务.
   |

ANN201 Missing return type annotation for public function `collect_database_sizes`
  --> app/tasks/capacity_collection_tasks.py:19:5
   |
19 | def collect_database_sizes():
   |     ^^^^^^^^^^^^^^^^^^^^^^
20 |     """容量同步定时任务.
   |
help: Add return type annotation

E501 Line too long (140 > 120)
  --> app/tasks/capacity_collection_tasks.py:71:121
   |
69 | …
70 | …]
71 | …session.session_id, instance_ids, sync_category=SyncCategory.CAPACITY.value)
   |                                                          ^^^^^^^^^^^^^^^^^^^^
72 | …
   |

G004 Logging statement uses f-string
  --> app/tasks/capacity_collection_tasks.py:90:25
   |
89 |                     sync_logger.info(
90 |                         f"开始同步实例: {instance.name} (ID: {instance.id})",
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
91 |                         module="capacity_sync",
92 |                         session_id=session.session_id,
   |
help: Convert to lazy `%` formatting

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:125:41
    |
123 |                         except Exception as inventory_error:
124 |                             error_msg = f"同步数据库列表失败: {inventory_error}"
125 |                             sync_logger.error(
    |                                         ^^^^^
126 |                                 error_msg,
127 |                                 module="capacity_sync",
    |

E501 Line too long (124 > 120)
   --> app/tasks/capacity_collection_tasks.py:151:121
    |
149 | …                     items_synced=0,
150 | …                     items_created=inventory_result.get("created", 0),
151 | …                     items_updated=inventory_result.get("refreshed", 0) + inventory_result.get("reactivated", 0),
    |                                                                                                               ^^^^
152 | …                     items_deleted=inventory_result.get("deactivated", 0),
153 | …                     sync_details={
    |

G004 Logging statement uses f-string
   --> app/tasks/capacity_collection_tasks.py:202:33
    |
200 | …                     error_msg = "未采集到任何数据库大小数据"
201 | …                     sync_logger.error(
202 | …                         f"实例容量同步失败: {instance.name} - {error_msg}",
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
203 | …                         module="capacity_sync",
204 | …                         session_id=session.session_id,
    |
help: Convert to lazy `%` formatting

G004 Logging statement uses f-string
   --> app/tasks/capacity_collection_tasks.py:249:29
    |
248 |                         sync_logger.info(
249 |                             f"实例容量同步成功: {instance.name}",
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
250 |                             module="capacity_sync",
251 |                             session_id=session.session_id,
    |
help: Convert to lazy `%` formatting

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:274:33
    |
272 |                 except Exception as e:
273 |                     error_msg = f"实例同步异常: {e!s}"
274 |                     sync_logger.error(
    |                                 ^^^^^
275 |                         error_msg,
276 |                         module="capacity_sync",
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_collection_tasks.py:317:13
    |
315 |             )
316 |
317 |             return result
    |             ^^^^^^^^^^^^^
318 |
319 |         except Exception as e:
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:320:25
    |
319 |         except Exception as e:
320 |             sync_logger.error(
    |                         ^^^^^
321 |                 "容量同步任务执行失败",
322 |                 module="capacity_sync",
    |

C901 `collect_specific_instance_database_sizes` is too complex (11 > 10)
   --> app/tasks/capacity_collection_tasks.py:341:5
    |
341 | def collect_specific_instance_database_sizes(instance_id: int) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
342 |     """采集指定实例的数据库大小信息.
    |

PLR0911 Too many return statements (9 > 6)
   --> app/tasks/capacity_collection_tasks.py:341:5
    |
341 | def collect_specific_instance_database_sizes(instance_id: int) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
342 |     """采集指定实例的数据库大小信息.
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:393:33
    |
391 |                     inventory_result = collector.synchronize_database_inventory()
392 |                 except Exception as inventory_error:
393 |                     sync_logger.error(
    |                                 ^^^^^
394 |                         "同步数据库列表失败",
395 |                         module="capacity_sync",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:431:37
    |
429 |                         saved_count = collector.save_collected_data(databases_data)
430 |                     except Exception as save_error:
431 |                         sync_logger.error(
    |                                     ^^^^^
432 |                             "保存实例容量数据失败",
433 |                             module="capacity_sync",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:461:37
    |
459 |                         aggregation_service.calculate_daily_aggregations_for_instance(instance.id)
460 |                     except Exception as agg_exc:  # pragma: no cover - 防御性日志
461 |                         sync_logger.error(
    |                                     ^^^^^
462 |                             "实例容量聚合刷新失败",
463 |                             module="capacity_sync",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:490:25
    |
489 |         except Exception as e:
490 |             sync_logger.error(
    |                         ^^^^^
491 |                 "采集实例数据库大小失败",
492 |                 module="capacity_sync",
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/capacity_collection_tasks.py:557:24
    |
555 |                     else:
556 |                         errors.append(f"实例 {instance.name}: {result['message']}")
557 |                 except Exception as e:
    |                        ^^^^^^^^^
558 |                     errors.append(f"实例 {instance.name}: {e!s}")
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_collection_tasks.py:560:13
    |
558 |                       errors.append(f"实例 {instance.name}: {e!s}")
559 |
560 | /             return {
561 | |                 "success": True,
562 | |                 "message": f"{db_type} 类型数据库大小采集完成",
563 | |                 "instances_processed": total_processed,
564 | |                 "total_size_mb": total_size_mb,
565 | |                 "errors": errors,
566 | |             }
    | |_____________^
567 |
568 |           except Exception as e:
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:569:25
    |
568 |         except Exception as e:
569 |             sync_logger.error(
    |                         ^^^^^
570 |                 "按类型采集数据库容量失败",
571 |                 module="capacity_sync",
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:617:25
    |
615 |         except Exception as e:
616 |             sync_logger = get_sync_logger()
617 |             sync_logger.error(
    |                         ^^^^^
618 |                 "获取容量采集状态失败",
619 |                 module="capacity_sync",
    |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/capacity_collection_tasks.py:648:9
    |
646 |           DatabaseSizeCollectorService()
647 |
648 | /         return {
649 | |             "success": True,
650 | |             "config": config_checks,
651 | |             "service_available": True,
652 | |             "message": "配置验证通过",
653 | |         }
    | |_________^
654 |
655 |       except Exception as e:
    |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
   --> app/tasks/capacity_collection_tasks.py:657:21
    |
655 |     except Exception as e:
656 |         sync_logger = get_sync_logger()
657 |         sync_logger.error(
    |                     ^^^^^
658 |             "容量采集配置验证失败",
659 |             module="capacity_sync",
    |

PLC0415 `import` should be at the top-level of a file
  --> app/tasks/log_cleanup_tasks.py:36:13
   |
34 |             cleaned_files = _cleanup_temp_files()
35 |
36 |             from app.models.sync_instance_record import SyncInstanceRecord
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
37 |             from app.models.sync_session import SyncSession
   |

PLC0415 `import` should be at the top-level of a file
  --> app/tasks/log_cleanup_tasks.py:37:13
   |
36 |             from app.models.sync_instance_record import SyncInstanceRecord
37 |             from app.models.sync_session import SyncSession
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |
39 |             deleted_sync_sessions = SyncSession.query.filter(SyncSession.created_at < cutoff_date).delete()
   |

G201 Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`
  --> app/tasks/log_cleanup_tasks.py:61:25
   |
59 |         except Exception as exc:
60 |             db.session.rollback()
61 |             task_logger.error(
   |                         ^^^^^
62 |                 "定时任务清理失败",
63 |                 module="task",
   |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/log_cleanup_tasks.py:99:12
    |
 97 |                         cleaned_count += 1
 98 |
 99 |     except Exception as exc:
    |            ^^^^^^^^^
100 |         get_task_logger().warning(f"清理临时文件时出错: {exc}")
    |

D205 1 blank line required between summary line and description
 --> app/tasks/partition_management_tasks.py:1:1
  |
1 | / """分区管理定时任务
2 | | 负责自动创建、清理和监控数据库大小统计表的分区.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

TRY300 Consider moving this statement to an `else` block
  --> app/tasks/partition_management_tasks.py:56:9
   |
54 |             message="分区创建任务已完成",
55 |         )
56 |         return payload
   |         ^^^^^^^^^^^^^^
57 |     except Exception as exc:
58 |         app_error = _as_app_error(exc)
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/tasks/partition_management_tasks.py:57:12
   |
55 |         )
56 |         return payload
57 |     except Exception as exc:
   |            ^^^^^^^^^
58 |         app_error = _as_app_error(exc)
59 |         log_error("分区创建任务失败", module=MODULE, exception=exc)
   |

TRY300 Consider moving this statement to an `else` block
  --> app/tasks/partition_management_tasks.py:93:9
   |
91 |             message="旧分区清理任务已完成",
92 |         )
93 |         return payload
   |         ^^^^^^^^^^^^^^
94 |     except Exception as exc:
95 |         app_error = _as_app_error(exc)
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/tasks/partition_management_tasks.py:94:12
   |
92 |         )
93 |         return payload
94 |     except Exception as exc:
   |            ^^^^^^^^^
95 |         app_error = _as_app_error(exc)
96 |         log_error("旧分区清理任务失败", module=MODULE, exception=exc)
   |

TRY300 Consider moving this statement to an `else` block
   --> app/tasks/partition_management_tasks.py:157:9
    |
155 |             message="分区健康监控完成",
156 |         )
157 |         return payload
    |         ^^^^^^^^^^^^^^
158 |     except Exception as exc:
159 |         app_error = _as_app_error(exc)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/tasks/partition_management_tasks.py:158:12
    |
156 |         )
157 |         return payload
158 |     except Exception as exc:
    |            ^^^^^^^^^
159 |         app_error = _as_app_error(exc)
160 |         log_error("分区健康监控任务失败", module=MODULE, exception=exc)
    |

D205 1 blank line required between summary line and description
 --> app/utils/cache_utils.py:1:1
  |
1 | / """鲸落 - 缓存管理工具
2 | | 基于Flask-Caching的通用缓存管理器,提供装饰器和通用缓存功能.
3 | | """
  | |___^
4 |
5 |   import hashlib
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/utils/cache_utils.py:28:9
   |
26 |     """
27 |
28 |     def __init__(self, cache: Cache) -> None:
   |         ^^^^^^^^
29 |         self.cache = cache
30 |         self.default_timeout = 300  # 5分钟默认超时
   |

ANN002 Missing type annotation for `*args`
  --> app/utils/cache_utils.py:33:42
   |
31 |         self.system_logger = get_system_logger()
32 |
33 |     def _generate_key(self, prefix: str, *args, **kwargs: Any) -> str:
   |                                          ^^^^^
34 |         """生成缓存键.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> app/utils/cache_utils.py:33:59
   |
31 |         self.system_logger = get_system_logger()
32 |
33 |     def _generate_key(self, prefix: str, *args, **kwargs: Any) -> str:
   |                                                           ^^^
34 |         """生成缓存键.
   |

ERA001 Found commented-out code
  --> app/utils/cache_utils.py:51:9
   |
49 |         key_string = json.dumps(key_data, sort_keys=True, default=str)
50 |
51 |         # 生成哈希值(使用SHA256替代MD5)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
52 |         key_hash = hashlib.sha256(key_string.encode()).hexdigest()
   |
help: Remove commented-out code

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get`
  --> app/utils/cache_utils.py:56:32
   |
54 |         return f"{prefix}:{key_hash}"
55 |
56 |     def get(self, key: str) -> Any | None:
   |                                ^^^^^^^^^^
57 |         """获取缓存值.
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/utils/cache_utils.py:68:16
   |
66 |         try:
67 |             return self.cache.get(key)
68 |         except Exception as e:
   |                ^^^^^^^^^
69 |             self.system_logger.warning("获取缓存失败", module="cache", key=key, exception=str(e))
70 |             return None
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
  --> app/utils/cache_utils.py:72:36
   |
70 |             return None
71 |
72 |     def set(self, key: str, value: Any, timeout: int | None = None) -> bool:
   |                                    ^^^
73 |         """设置缓存值.
   |

TRY300 Consider moving this statement to an `else` block
  --> app/utils/cache_utils.py:87:13
   |
85 |             timeout = timeout or self.default_timeout
86 |             self.cache.set(key, value, timeout=timeout)
87 |             return True
   |             ^^^^^^^^^^^
88 |         except Exception as e:
89 |             self.system_logger.warning("设置缓存失败", module="cache", key=key, exception=str(e))
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/utils/cache_utils.py:88:16
   |
86 |             self.cache.set(key, value, timeout=timeout)
87 |             return True
88 |         except Exception as e:
   |                ^^^^^^^^^
89 |             self.system_logger.warning("设置缓存失败", module="cache", key=key, exception=str(e))
90 |             return False
   |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/cache_utils.py:104:13
    |
102 |         try:
103 |             self.cache.delete(key)
104 |             return True
    |             ^^^^^^^^^^^
105 |         except Exception:
106 |             self.system_logger.warning("删除缓存失败: {key}, 错误: {e}")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/cache_utils.py:105:16
    |
103 |             self.cache.delete(key)
104 |             return True
105 |         except Exception:
    |                ^^^^^^^^^
106 |             self.system_logger.warning("删除缓存失败: {key}, 错误: {e}")
107 |             return False
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/cache_utils.py:118:13
    |
116 |         try:
117 |             self.cache.clear()
118 |             return True
    |             ^^^^^^^^^^^
119 |         except Exception:
120 |             self.system_logger.warning("清空缓存失败: {e}")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/cache_utils.py:119:16
    |
117 |             self.cache.clear()
118 |             return True
119 |         except Exception:
    |                ^^^^^^^^^
120 |             self.system_logger.warning("清空缓存失败: {e}")
121 |             return False
    |

ANN002 Missing type annotation for `*args`
   --> app/utils/cache_utils.py:123:80
    |
121 |             return False
122 |
123 |     def get_or_set(self, key: str, func: Callable, timeout: int | None = None, *args, **kwargs: Any) -> Any:
    |                                                                                ^^^^^
124 |         """获取缓存值,如果不存在则调用函数生成并写入.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/cache_utils.py:123:97
    |
121 |             return False
122 |
123 |     def get_or_set(self, key: str, func: Callable, timeout: int | None = None, *args, **kwargs: Any) -> Any:
    |                                                                                                 ^^^
124 |         """获取缓存值,如果不存在则调用函数生成并写入.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `get_or_set`
   --> app/utils/cache_utils.py:123:105
    |
121 |             return False
122 |
123 |     def get_or_set(self, key: str, func: Callable, timeout: int | None = None, *args, **kwargs: Any) -> Any:
    |                                                                                                         ^^^
124 |         """获取缓存值,如果不存在则调用函数生成并写入.
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/cache_utils.py:159:13
    |
157 |                 return self.cache.cache.delete_pattern(pattern)
158 |             self.system_logger.warning("当前缓存后端不支持模式删除")
159 |             return 0
    |             ^^^^^^^^
160 |         except Exception:
161 |             self.system_logger.warning("模式删除缓存失败: {pattern}, 错误: {e}")
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/cache_utils.py:160:16
    |
158 |             self.system_logger.warning("当前缓存后端不支持模式删除")
159 |             return 0
160 |         except Exception:
    |                ^^^^^^^^^
161 |             self.system_logger.warning("模式删除缓存失败: {pattern}, 错误: {e}")
162 |             return 0
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*args`
   --> app/utils/cache_utils.py:213:39
    |
211 |     def cache_decorator(f: Callable) -> Callable:
212 |         @wraps(f)
213 |         def decorated_function(*args: "Any", **kwargs: "Any") -> "Any":
    |                                       ^^^^^
214 |             # 检查是否跳过缓存
215 |             if unless and unless():
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/cache_utils.py:213:56
    |
211 |     def cache_decorator(f: Callable) -> Callable:
212 |         @wraps(f)
213 |         def decorated_function(*args: "Any", **kwargs: "Any") -> "Any":
    |                                                        ^^^^^
214 |             # 检查是否跳过缓存
215 |             if unless and unless():
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
   --> app/utils/cache_utils.py:213:66
    |
211 |     def cache_decorator(f: Callable) -> Callable:
212 |         @wraps(f)
213 |         def decorated_function(*args: "Any", **kwargs: "Any") -> "Any":
    |                                                                  ^^^^^
214 |             # 检查是否跳过缓存
215 |             if unless and unless():
    |

SLF001 Private member accessed: `_generate_key`
   --> app/utils/cache_utils.py:223:29
    |
221 |                 cache_key = key_func(*args, **kwargs)
222 |             else:
223 |                 cache_key = manager._generate_key(f"{key_prefix}:{f.__name__}", *args, **kwargs)
    |                             ^^^^^^^^^^^^^^^^^^^^^
224 |
225 |             # 尝试获取缓存
    |

D205 1 blank line required between summary line and description
 --> app/utils/data_validator.py:1:1
  |
1 | / """数据验证工具类
2 | | 提供严格的数据验证功能,防止无效数据进入系统.
3 | | """
  | |___^
4 |
5 |   import html
  |
help: Insert single blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/utils/data_validator.py:34:26
   |
33 |     # 支持的数据库类型
34 |     SUPPORTED_DB_TYPES = ["mysql", "postgresql", "sqlserver", "oracle", "sqlite"]
   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
35 |
36 |     # 支持的凭据类型
   |

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/utils/data_validator.py:37:34
   |
36 |     # 支持的凭据类型
37 |     SUPPORTED_CREDENTIAL_TYPES = ["database", "ssh", "windows", "api", "ldap"]
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
38 |     _custom_db_types: set[str] | None = None
   |

C901 `validate_instance_data` is too complex (14 > 10)
  --> app/utils/data_validator.py:51:9
   |
50 |     @classmethod
51 |     def validate_instance_data(cls, data: dict[str, Any]) -> tuple[bool, str | None]:
   |         ^^^^^^^^^^^^^^^^^^^^^^
52 |         """验证实例数据.
   |

PLR0911 Too many return statements (10 > 6)
  --> app/utils/data_validator.py:51:9
   |
50 |     @classmethod
51 |     def validate_instance_data(cls, data: dict[str, Any]) -> tuple[bool, str | None]:
   |         ^^^^^^^^^^^^^^^^^^^^^^
52 |         """验证实例数据.
   |

PLR0912 Too many branches (13 > 12)
  --> app/utils/data_validator.py:51:9
   |
50 |     @classmethod
51 |     def validate_instance_data(cls, data: dict[str, Any]) -> tuple[bool, str | None]:
   |         ^^^^^^^^^^^^^^^^^^^^^^
52 |         """验证实例数据.
   |

ERA001 Found commented-out code
  --> app/utils/data_validator.py:93:13
   |
91 |                 return False, port_error
92 |
93 |             # 验证数据库名称(可选)
   |             ^^^^^^^^^^^^^^^^^^^^^^
94 |             if data.get("database_name"):
95 |                 db_name_error = cls._validate_database_name(data.get("database_name"))
   |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/data_validator.py:99:13
    |
 97 |                     return False, db_name_error
 98 |
 99 |             # 验证描述(可选)
    |             ^^^^^^^^^^^^^^^^
100 |             if data.get("description"):
101 |                 desc_error = cls._validate_description(data.get("description"))
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/data_validator.py:105:13
    |
103 |                     return False, desc_error
104 |
105 |             # 验证凭据ID(可选)
    |             ^^^^^^^^^^^^^^^^^^
106 |             if data.get("credential_id"):
107 |                 cred_error = cls._validate_credential_id(data.get("credential_id"))
    |
help: Remove commented-out code

TRY300 Consider moving this statement to an `else` block
   --> app/utils/data_validator.py:111:13
    |
109 |                     return False, cred_error
110 |
111 |             return True, None
    |             ^^^^^^^^^^^^^^^^^
112 |
113 |         except Exception as e:
    |

G004 Logging statement uses f-string
   --> app/utils/data_validator.py:114:30
    |
113 |         except Exception as e:
114 |             logger.exception(f"数据验证过程中发生错误: {e!s}")
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
115 |             return False, f"数据验证失败: {e!s}"
    |
help: Convert to lazy `%` formatting

TRY401 Redundant exception object included in `logging.exception` call
   --> app/utils/data_validator.py:114:46
    |
113 |         except Exception as e:
114 |             logger.exception(f"数据验证过程中发生错误: {e!s}")
    |                                                         ^
115 |             return False, f"数据验证失败: {e!s}"
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `name`
   --> app/utils/data_validator.py:118:35
    |
117 |     @classmethod
118 |     def _validate_name(cls, name: Any) -> str | None:
    |                                   ^^^
119 |         """验证实例名称并返回错误信息.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `db_type`
   --> app/utils/data_validator.py:145:41
    |
144 |     @classmethod
145 |     def _validate_db_type(cls, db_type: Any) -> str | None:
    |                                         ^^^
146 |         """验证数据库类型是否在受支持范围.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `host`
   --> app/utils/data_validator.py:166:35
    |
165 |     @classmethod
166 |     def _validate_host(cls, host: Any) -> str | None:
    |                                   ^^^
167 |         """验证主机地址格式.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `port`
   --> app/utils/data_validator.py:193:35
    |
192 |     @classmethod
193 |     def _validate_port(cls, port: Any) -> str | None:
    |                                   ^^^
194 |         """验证端口号是否处于允许范围.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `db_name`
   --> app/utils/data_validator.py:214:47
    |
213 |     @classmethod
214 |     def _validate_database_name(cls, db_name: Any) -> str | None:
    |                                               ^^^
215 |         """验证数据库名称长度与字符集合.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `description`
   --> app/utils/data_validator.py:241:49
    |
240 |     @classmethod
241 |     def _validate_description(cls, description: Any) -> str | None:
    |                                                 ^^^
242 |         """验证描述字段长度.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `credential_id`
   --> app/utils/data_validator.py:261:53
    |
260 |     @classmethod
261 |     def _validate_credential_id(cls, credential_id: Any) -> str | None:
    |                                                     ^^^
262 |         """验证凭据 ID 是否为正整数.
    |

PLR2004 Magic value used in comparison, consider replacing `255` with a constant variable
   --> app/utils/data_validator.py:295:42
    |
293 |         if re.match(ip_pattern, host):
294 |             parts = host.split(".")
295 |             return all(0 <= int(part) <= 255 for part in parts)
    |                                          ^^^
296 |
297 |         # 检查域名格式
    |

E501 Line too long (123 > 120)
   --> app/utils/data_validator.py:298:121
    |
297 |         # 检查域名格式
298 |         domain_pattern = r"^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$"
    |                                                                                                                         ^^^
299 |         return bool(re.match(domain_pattern, host))
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
   --> app/utils/data_validator.py:329:37
    |
328 |     @classmethod
329 |     def sanitize_string(cls, value: Any) -> str:
    |                                     ^^^
330 |         """清理字符串,移除潜在的危险内容.
    |

C901 `sanitize_form_data` is too complex (12 > 10)
   --> app/utils/data_validator.py:380:9
    |
379 |     @classmethod
380 |     def sanitize_form_data(cls, data: Mapping[str, Any]) -> dict[str, Any]:
    |         ^^^^^^^^^^^^^^^^^^
381 |         """清理表单提交的数据结构.
    |

PLR0912 Too many branches (14 > 12)
   --> app/utils/data_validator.py:380:9
    |
379 |     @classmethod
380 |     def sanitize_form_data(cls, data: Mapping[str, Any]) -> dict[str, Any]:
    |         ^^^^^^^^^^^^^^^^^^
381 |         """清理表单提交的数据结构.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `db_type`
   --> app/utils/data_validator.py:448:40
    |
447 |     @classmethod
448 |     def validate_db_type(cls, db_type: Any) -> str | None:
    |                                        ^^^
449 |         """验证数据库类型是否受支持.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/data_validator.py:488:13
    |
487 |         try:
488 |             from app.services.database_type_service import DatabaseTypeService
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
489 |
490 |             configs = DatabaseTypeService.get_active_types()
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/data_validator.py:494:16
    |
492 |             if dynamic_types:
493 |                 return dynamic_types
494 |         except Exception as exc:
    |                ^^^^^^^^^
495 |             logger.warning("获取数据库类型配置失败,回退到静态白名单: %s", exc)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `credential_type`
   --> app/utils/data_validator.py:500:56
    |
499 |     @classmethod
500 |     def validate_credential_type(cls, credential_type: Any) -> str | None:
    |                                                        ^^^
501 |         """验证凭据类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `username`
   --> app/utils/data_validator.py:526:37
    |
525 |     @staticmethod
526 |     def validate_username(username: Any) -> str | None:
    |                                     ^^^
527 |         """验证用户名格式.
    |

PLR2004 Magic value used in comparison, consider replacing `3` with a constant variable
   --> app/utils/data_validator.py:545:30
    |
544 |         normalized = username.strip()
545 |         if len(normalized) < 3:
    |                              ^
546 |             return "用户名长度至少3个字符"
    |

PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
   --> app/utils/data_validator.py:548:30
    |
546 |             return "用户名长度至少3个字符"
547 |
548 |         if len(normalized) > 50:
    |                              ^^
549 |             return "用户名长度不能超过50个字符"
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `password`
   --> app/utils/data_validator.py:557:37
    |
556 |     @staticmethod
557 |     def validate_password(password: Any) -> str | None:
    |                                     ^^^
558 |         """验证密码强度.
    |

PLR2004 Magic value used in comparison, consider replacing `6` with a constant variable
   --> app/utils/data_validator.py:575:28
    |
573 |             return "密码必须是字符串"
574 |
575 |         if len(password) < 6:
    |                            ^
576 |             return "密码长度至少6个字符"
    |

PLR2004 Magic value used in comparison, consider replacing `128` with a constant variable
   --> app/utils/data_validator.py:578:28
    |
576 |             return "密码长度至少6个字符"
577 |
578 |         if len(password) > 128:
    |                            ^^^
579 |             return "密码长度不能超过128个字符"
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `db_type`
   --> app/utils/data_validator.py:613:31
    |
613 | def validate_db_type(db_type: Any) -> str | None:
    |                               ^^^
614 |     """函数式入口校验数据库类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `credential_type`
   --> app/utils/data_validator.py:626:47
    |
626 | def validate_credential_type(credential_type: Any) -> str | None:
    |                                               ^^^
627 |     """函数式入口校验凭据类型.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `username`
   --> app/utils/data_validator.py:639:33
    |
639 | def validate_username(username: Any) -> str | None:
    |                                 ^^^
640 |     """函数式入口校验用户名.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `password`
   --> app/utils/data_validator.py:652:33
    |
652 | def validate_password(password: Any) -> str | None:
    |                                 ^^^
653 |     """函数式入口校验密码.
    |

D205 1 blank line required between summary line and description
 --> app/utils/database_batch_manager.py:1:1
  |
1 | / """鲸落 - 数据库批量操作管理器
2 | | 提供高效的批量提交机制,优化大量数据处理性能.
3 | | """
  | |___^
4 |
5 |   from typing import Any
  |
help: Insert single blank line

I001 [*] Import block is un-sorted or un-formatted
  --> app/utils/database_batch_manager.py:5:1
   |
 3 |   """
 4 |
 5 | / from typing import Any
 6 | | from types import TracebackType
 7 | |
 8 | | import structlog
 9 | |
10 | | from app import db
   | |__________________^
   |
help: Organize imports

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `logger`
  --> app/utils/database_batch_manager.py:37:55
   |
35 |     """
36 |
37 |     def __init__(self, batch_size: int = 100, logger: Any | None = None, instance_name: str = "") -> None:
   |                                                       ^^^^^^^^^^
38 |         """初始化批量管理器.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `entity`
  --> app/utils/database_batch_manager.py:66:58
   |
64 |         )
65 |
66 |     def add_operation(self, operation_type: str, entity: Any, description: str = "") -> None:
   |                                                          ^^^
67 |         """添加数据库操作到批次队列.
   |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/database_batch_manager.py:161:13
    |
159 |             # 清空当前批次
160 |             self.pending_operations.clear()
161 |             return True
    |             ^^^^^^^^^^^
162 |
163 |         except Exception as e:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
  --> app/utils/decorators.py:18:23
   |
16 | SAFE_CSRF_METHODS = {"GET", "HEAD", "OPTIONS", "TRACE"}
17 |
18 | def admin_required(f: Any) -> Any:
   |                       ^^^
19 |     """确保被装饰函数仅允许管理员访问的装饰器.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `admin_required`
  --> app/utils/decorators.py:18:31
   |
16 | SAFE_CSRF_METHODS = {"GET", "HEAD", "OPTIONS", "TRACE"}
17 |
18 | def admin_required(f: Any) -> Any:
   |                               ^^^
19 |     """确保被装饰函数仅允许管理员访问的装饰器.
   |

ANN002 Missing type annotation for `*args`
  --> app/utils/decorators.py:37:28
   |
36 |     @wraps(f)
37 |     def decorated_function(*args, **kwargs: Any) -> Any:
   |                            ^^^^^
38 |         system_logger = get_system_logger()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
  --> app/utils/decorators.py:37:45
   |
36 |     @wraps(f)
37 |     def decorated_function(*args, **kwargs: Any) -> Any:
   |                                             ^^^
38 |         system_logger = get_system_logger()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
  --> app/utils/decorators.py:37:53
   |
36 |     @wraps(f)
37 |     def decorated_function(*args, **kwargs: Any) -> Any:
   |                                                     ^^^
38 |         system_logger = get_system_logger()
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:111:23
    |
111 | def login_required(f: Any) -> Any:
    |                       ^^^
112 |     """要求调用者已登录的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `login_required`
   --> app/utils/decorators.py:111:31
    |
111 | def login_required(f: Any) -> Any:
    |                               ^^^
112 |     """要求调用者已登录的装饰器.
    |

ANN002 Missing type annotation for `*args`
   --> app/utils/decorators.py:123:28
    |
122 |     @wraps(f)
123 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                            ^^^^^
124 |         system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/decorators.py:123:45
    |
122 |     @wraps(f)
123 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                                             ^^^
124 |         system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
   --> app/utils/decorators.py:123:53
    |
122 |     @wraps(f)
123 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                                                     ^^^
124 |         system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `permission_required`
   --> app/utils/decorators.py:168:45
    |
168 | def permission_required(permission: str) -> Any:
    |                                             ^^^
169 |     """校验指定权限(view/create/update/delete)的装饰器工厂.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:179:22
    |
177 |     """
178 |
179 |     def decorator(f: Any) -> Any:
    |                      ^^^
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:179:30
    |
177 |     """
178 |
179 |     def decorator(f: Any) -> Any:
    |                              ^^^
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |

ANN002 Missing type annotation for `*args`
   --> app/utils/decorators.py:181:32
    |
179 |     def decorator(f: Any) -> Any:
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |                                ^^^^^
182 |             system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/decorators.py:181:49
    |
179 |     def decorator(f: Any) -> Any:
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |                                                 ^^^
182 |             system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
   --> app/utils/decorators.py:181:57
    |
179 |     def decorator(f: Any) -> Any:
180 |         @wraps(f)
181 |         def decorated_function(*args, **kwargs: Any) -> Any:
    |                                                         ^^^
182 |             system_logger = get_system_logger()
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:283:21
    |
283 | def require_csrf(f: Any) -> Any:
    |                     ^^^
284 |     """统一的 CSRF 校验装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `require_csrf`
   --> app/utils/decorators.py:283:29
    |
283 | def require_csrf(f: Any) -> Any:
    |                             ^^^
284 |     """统一的 CSRF 校验装饰器.
    |

ANN002 Missing type annotation for `*args`
   --> app/utils/decorators.py:295:28
    |
294 |     @wraps(f)
295 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                            ^^^^^
296 |         if request.method.upper() in SAFE_CSRF_METHODS:
297 |             return f(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `**kwargs`
   --> app/utils/decorators.py:295:45
    |
294 |     @wraps(f)
295 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                                             ^^^
296 |         if request.method.upper() in SAFE_CSRF_METHODS:
297 |             return f(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorated_function`
   --> app/utils/decorators.py:295:53
    |
294 |     @wraps(f)
295 |     def decorated_function(*args, **kwargs: Any) -> Any:
    |                                                     ^^^
296 |         if request.method.upper() in SAFE_CSRF_METHODS:
297 |             return f(*args, **kwargs)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `user`
   --> app/utils/decorators.py:347:26
    |
347 | def has_permission(user: Any, permission: str) -> bool:
    |                          ^^^
348 |     """检查给定用户是否具备指定权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:382:22
    |
382 | def view_required(f: Any = None, *, permission: str = "view") -> Any:
    |                      ^^^
383 |     """校验查看权限的装饰器,可直接使用或指定自定义权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `view_required`
   --> app/utils/decorators.py:382:66
    |
382 | def view_required(f: Any = None, *, permission: str = "view") -> Any:
    |                                                                  ^^^
383 |     """校验查看权限的装饰器,可直接使用或指定自定义权限.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/utils/decorators.py:394:25
    |
392 |     """
393 |
394 |     def decorator(func: Any) -> Any:
    |                         ^^^
395 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:394:33
    |
392 |     """
393 |
394 |     def decorator(func: Any) -> Any:
    |                                 ^^^
395 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:402:24
    |
402 | def create_required(f: Any = None, *, permission: str = "create") -> Any:
    |                        ^^^
403 |     """校验创建权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `create_required`
   --> app/utils/decorators.py:402:70
    |
402 | def create_required(f: Any = None, *, permission: str = "create") -> Any:
    |                                                                      ^^^
403 |     """校验创建权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/utils/decorators.py:414:25
    |
412 |     """
413 |
414 |     def decorator(func: Any) -> Any:
    |                         ^^^
415 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:414:33
    |
412 |     """
413 |
414 |     def decorator(func: Any) -> Any:
    |                                 ^^^
415 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:422:24
    |
422 | def update_required(f: Any = None, *, permission: str = "update") -> Any:
    |                        ^^^
423 |     """校验更新权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `update_required`
   --> app/utils/decorators.py:422:70
    |
422 | def update_required(f: Any = None, *, permission: str = "update") -> Any:
    |                                                                      ^^^
423 |     """校验更新权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/utils/decorators.py:434:25
    |
432 |     """
433 |
434 |     def decorator(func: Any) -> Any:
    |                         ^^^
435 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:434:33
    |
432 |     """
433 |
434 |     def decorator(func: Any) -> Any:
    |                                 ^^^
435 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:442:24
    |
442 | def delete_required(f: Any = None, *, permission: str = "delete") -> Any:
    |                        ^^^
443 |     """校验删除权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `delete_required`
   --> app/utils/decorators.py:442:70
    |
442 | def delete_required(f: Any = None, *, permission: str = "delete") -> Any:
    |                                                                      ^^^
443 |     """校验删除权限的装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `func`
   --> app/utils/decorators.py:454:25
    |
452 |     """
453 |
454 |     def decorator(func: Any) -> Any:
    |                         ^^^
455 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `decorator`
   --> app/utils/decorators.py:454:33
    |
452 |     """
453 |
454 |     def decorator(func: Any) -> Any:
    |                                 ^^^
455 |         return permission_required(permission)(func)
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:462:32
    |
462 | def scheduler_view_required(f: Any) -> Any:
    |                                ^^^
463 |     """定时任务查看权限装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `scheduler_view_required`
   --> app/utils/decorators.py:462:40
    |
462 | def scheduler_view_required(f: Any) -> Any:
    |                                        ^^^
463 |     """定时任务查看权限装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `f`
   --> app/utils/decorators.py:475:34
    |
475 | def scheduler_manage_required(f: Any) -> Any:
    |                                  ^^^
476 |     """定时任务管理权限装饰器.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `scheduler_manage_required`
   --> app/utils/decorators.py:475:42
    |
475 | def scheduler_manage_required(f: Any) -> Any:
    |                                          ^^^
476 |     """定时任务管理权限装饰器.
    |

PLC0415 `import` should be at the top-level of a file
  --> app/utils/logging/error_adapter.py:60:13
   |
58 |         """
59 |         if self.request is None and has_request_context():
60 |             from flask import request as flask_request
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
61 |
62 |             self.request = flask_request
   |

FBT001 Boolean-typed positional argument in function definition
  --> app/utils/logging/handlers.py:37:27
   |
35 |         self.enabled = enabled
36 |
37 |     def set_enabled(self, enabled: bool) -> None:
   |                           ^^^^^^^
38 |         """设置是否启用 DEBUG 日志.
   |

ARG002 Unused method argument: `logger`
  --> app/utils/logging/handlers.py:49:24
   |
47 |         self.enabled = enabled
48 |
49 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]) -> dict[str, Any]:
   |                        ^^^^^^
50 |         """处理日志事件,根据配置决定是否丢弃 DEBUG 日志.
   |

ARG002 Unused method argument: `method_name`
  --> app/utils/logging/handlers.py:49:55
   |
47 |         self.enabled = enabled
48 |
49 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]) -> dict[str, Any]:
   |                                                       ^^^^^^^^^^^
50 |         """处理日志事件,根据配置决定是否丢弃 DEBUG 日志.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `worker`
  --> app/utils/logging/handlers.py:78:32
   |
76 |     """
77 |
78 |     def __init__(self, worker: Any | None = None) -> None:
   |                                ^^^^^^^^^^
79 |         """初始化数据库日志处理器.
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `worker`
  --> app/utils/logging/handlers.py:87:34
   |
85 |         self.worker = worker
86 |
87 |     def set_worker(self, worker: Any | None) -> None:
   |                                  ^^^^^^^^^^
88 |         """设置日志队列工作线程.
   |

ARG002 Unused method argument: `logger`
   --> app/utils/logging/handlers.py:99:24
    |
 97 |         self.worker = worker
 98 |
 99 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]) -> dict[str, Any]:
    |                        ^^^^^^
100 |         """处理日志事件,将其入队等待写入数据库.
    |

ARG002 Unused method argument: `method_name`
   --> app/utils/logging/handlers.py:99:55
    |
 97 |         self.worker = worker
 98 |
 99 |     def __call__(self, logger: structlog.BoundLogger, method_name: str, event_dict: dict[str, Any]) -> dict[str, Any]:
    |                                                       ^^^^^^^^^^^
100 |         """处理日志事件,将其入队等待写入数据库.
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/logging/handlers.py:157:16
    |
155 |         try:
156 |             timestamp = time_utils.to_utc(timestamp)
157 |         except Exception:
    |                ^^^^^^^^^
158 |             timestamp = time_utils.now()
159 |     if timestamp is None:
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/logging/handlers.py:231:12
    |
229 |             else:
230 |                 context["is_admin"] = bool(is_admin)
231 |     except Exception as exc:
    |            ^^^^^^^^^
232 |         _logger.warning("logging_handler_extract_user_failed", error=str(exc))
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/logging/handlers.py:242:20
    |
240 |             try:
241 |                 context[key] = value.to_dict()
242 |             except Exception:
    |                    ^^^^^^^^^
243 |                 context[key] = str(value)
244 |         else:
    |

I001 [*] Import block is un-sorted or un-formatted
  --> app/utils/logging/queue_worker.py:3:1
   |
 1 |   """负责异步持久化结构化日志的队列工作线程."""
 2 |
 3 | / from __future__ import annotations
 4 | |
 5 | | import contextlib
 6 | | import logging
 7 | | import threading
 8 | | import time
 9 | | from queue import Empty, Full, Queue
10 | | from typing import Any
   | |______________________^
   |
help: Organize imports

ANN001 Missing type annotation for function argument `app`
  --> app/utils/logging/queue_worker.py:29:9
   |
27 |     def __init__(
28 |         self,
29 |         app,
   |         ^^^
30 |         *,
31 |         queue_size: int = 1000,
   |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/logging/queue_worker.py:138:13
    |
136 |         db_instance = None
137 |         try:
138 |             from app import db as db_instance
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
139 |             from app.models.unified_log import UnifiedLog
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/logging/queue_worker.py:139:13
    |
137 |         try:
138 |             from app import db as db_instance
139 |             from app.models.unified_log import UnifiedLog
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
140 |
141 |             with self.app.app_context():
    |

D205 1 blank line required between summary line and description
 --> app/utils/password_crypto_utils.py:1:1
  |
1 | / """密码管理工具
2 | | 用于安全地存储和获取数据库密码.
3 | | """
  | |___^
4 |
5 |   import base64
  |
help: Insert single blank line

D107 Missing docstring in `__init__`
  --> app/utils/password_crypto_utils.py:31:9
   |
29 |     """
30 |
31 |     def __init__(self) -> None:
   |         ^^^^^^^^
32 |         self.key = self._get_or_create_key()
33 |         self.cipher = Fernet(self.key)
   |

ANN202 Missing return type annotation for private function `_get_or_create_key`
  --> app/utils/password_crypto_utils.py:35:9
   |
33 |         self.cipher = Fernet(self.key)
34 |
35 |     def _get_or_create_key(self):
   |         ^^^^^^^^^^^^^^^^^^
36 |         """获取或创建加密密钥.
   |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
  --> app/utils/password_crypto_utils.py:51:17
   |
49 |             # 延迟导入避免循环导入
50 |             try:
51 |                 from app.utils.structlog_config import get_system_logger
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
52 |                 system_logger = get_system_logger()
53 |                 system_logger.warning("没有设置PASSWORD_ENCRYPTION_KEY环境变量", module="password_manager")
   |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/password_crypto_utils.py:102:13
    |
100 |             return decrypted.decode()
101 |         except Exception as e:
102 |             from app.utils.structlog_config import get_system_logger
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
103 |
104 |             system_logger = get_system_logger()
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/password_crypto_utils.py:128:13
    |
126 |         try:
127 |             base64.b64decode(password.encode())
128 |             return True
    |             ^^^^^^^^^^^
129 |         except Exception:
130 |             return False
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/password_crypto_utils.py:129:16
    |
127 |             base64.b64decode(password.encode())
128 |             return True
129 |         except Exception:
    |                ^^^^^^^^^
130 |             return False
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/query_filter_utils.py:264:9
    |
262 |     query = db.session.query(distinct(UnifiedLog.module))
263 |     if limit_hours is not None:
264 |         from datetime import timedelta
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
265 |
266 |         from app.utils.time_utils import time_utils
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/query_filter_utils.py:266:9
    |
264 |         from datetime import timedelta
265 |
266 |         from app.utils.time_utils import time_utils
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
267 |
268 |         start_time = time_utils.now() - timedelta(hours=limit_hours)
    |

BLE001 Do not catch blind exception: `Exception`
  --> app/utils/rate_limiter.py:86:20
   |
84 |             try:
85 |                 return self._check_cache(identifier, endpoint, limit, window, current_time, window_start)
86 |             except Exception as e:
   |                    ^^^^^^^^^
87 |                 system_logger = get_system_logger()
88 |                 system_logger.warning(
   |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/utils/rate_limiter.py:98:9
    |
 96 |             return self._check_memory(identifier, endpoint, limit, window, current_time, window_start)
 97 |
 98 |     def _check_cache(
    |         ^^^^^^^^^^^^
 99 |         self,
100 |         identifier: str,
    |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/utils/rate_limiter.py:151:9
    |
149 |         }
150 |
151 |     def _check_memory(
    |         ^^^^^^^^^^^^^
152 |         self,
153 |         identifier: str,
    |

ANN201 Missing return type annotation for public function `login_rate_limit`
   --> app/utils/rate_limiter.py:220:5
    |
220 | def login_rate_limit(func=None, *, limit: int | None = None, window: int | None = None):
    |     ^^^^^^^^^^^^^^^^
221 |     """登录接口速率限制装饰器.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `func`
   --> app/utils/rate_limiter.py:220:22
    |
220 | def login_rate_limit(func=None, *, limit: int | None = None, window: int | None = None):
    |                      ^^^^
221 |     """登录接口速率限制装饰器.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/rate_limiter.py:232:5
    |
231 |     """
232 |     from app.config import Config
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
233 |
234 |     if limit is None:
    |

ANN202 Missing return type annotation for private function `wrapped`
   --> app/utils/rate_limiter.py:241:13
    |
239 |     def decorator(f: Callable) -> Callable:
240 |         @wraps(f)
241 |         def wrapped(*args, **kwargs):
    |             ^^^^^^^
242 |             if request.method.upper() in SAFE_METHODS:
243 |                 return f(*args, **kwargs)
    |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
   --> app/utils/rate_limiter.py:241:21
    |
239 |     def decorator(f: Callable) -> Callable:
240 |         @wraps(f)
241 |         def wrapped(*args, **kwargs):
    |                     ^^^^^
242 |             if request.method.upper() in SAFE_METHODS:
243 |                 return f(*args, **kwargs)
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/rate_limiter.py:241:28
    |
239 |     def decorator(f: Callable) -> Callable:
240 |         @wraps(f)
241 |         def wrapped(*args, **kwargs):
    |                            ^^^^^^^^
242 |             if request.method.upper() in SAFE_METHODS:
243 |                 return f(*args, **kwargs)
    |

ANN201 Missing return type annotation for public function `password_reset_rate_limit`
   --> app/utils/rate_limiter.py:305:5
    |
305 | def password_reset_rate_limit(func=None, *, limit: int | None = None, window: int | None = None):
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
306 |     """密码重置速率限制装饰器.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `func`
   --> app/utils/rate_limiter.py:305:31
    |
305 | def password_reset_rate_limit(func=None, *, limit: int | None = None, window: int | None = None):
    |                               ^^^^
306 |     """密码重置速率限制装饰器.
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/rate_limiter.py:324:5
    |
323 |     """
324 |     from app.config import Config
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
325 |
326 |     if limit is None:
    |

RUF022 [*] `__all__` is not sorted
   --> app/utils/rate_limiter.py:356:11
    |
356 |   __all__ = [
    |  ___________^
357 | |     "init_rate_limiter",
358 | |     "login_rate_limit",
359 | |     "password_reset_rate_limit",
360 | |     "RateLimiterRegistry",
361 | | ]
    | |_^
    |
help: Apply an isort-style sorting to `__all__`

D205 1 blank line required between summary line and description
 --> app/utils/response_utils.py:1:1
  |
1 | / """鲸落 - 统一响应工具
2 | | 提供统一的成功/错误响应结构,避免在业务层散落 JSON 拼装逻辑.
3 | | """
  | |___^
4 |
5 |   from __future__ import annotations
  |
help: Insert single blank line

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `data`
  --> app/utils/response_utils.py:22:11
   |
21 | def unified_success_response(
22 |     data: Any | None = None,
   |           ^^^^^^^^^^
23 |     message: str | None = None,
24 |     *,
   |

ANN201 Missing return type annotation for public function `jsonify_unified_success`
  --> app/utils/response_utils.py:83:5
   |
83 | def jsonify_unified_success(*args, **kwargs):
   |     ^^^^^^^^^^^^^^^^^^^^^^^
84 |     """返回 Flask Response 对象的成功响应便捷函数.
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> app/utils/response_utils.py:83:29
   |
83 | def jsonify_unified_success(*args, **kwargs):
   |                             ^^^^^
84 |     """返回 Flask Response 对象的成功响应便捷函数.
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/utils/response_utils.py:83:36
   |
83 | def jsonify_unified_success(*args, **kwargs):
   |                                    ^^^^^^^^
84 |     """返回 Flask Response 对象的成功响应便捷函数.
   |

ANN201 Missing return type annotation for public function `jsonify_unified_error`
  --> app/utils/response_utils.py:98:5
   |
98 | def jsonify_unified_error(*args, **kwargs):
   |     ^^^^^^^^^^^^^^^^^^^^^
99 |     """返回 Flask Response 对象的错误响应便捷函数.
   |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
  --> app/utils/response_utils.py:98:27
   |
98 | def jsonify_unified_error(*args, **kwargs):
   |                           ^^^^^
99 |     """返回 Flask Response 对象的错误响应便捷函数.
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/utils/response_utils.py:98:34
   |
98 | def jsonify_unified_error(*args, **kwargs):
   |                                  ^^^^^^^^
99 |     """返回 Flask Response 对象的错误响应便捷函数.
   |

PLR0913 Too many arguments in function definition (6 > 5)
   --> app/utils/response_utils.py:113:5
    |
113 | def jsonify_unified_error_message(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
114 |     message: str,
115 |     *,
    |

ANN201 Missing return type annotation for public function `jsonify_unified_error_message`
   --> app/utils/response_utils.py:113:5
    |
113 | def jsonify_unified_error_message(
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
114 |     message: str,
115 |     *,
    |
help: Add return type annotation

D205 1 blank line required between summary line and description
 --> app/utils/safe_query_builder.py:1:1
  |
1 | / """鲸落 - 安全查询构建器
2 | | 提供安全的SQL查询构建功能,防止SQL注入攻击
3 | | 支持MySQL、PostgreSQL、SQL Server、Oracle等多种数据库.
4 | | """
  | |___^
5 |
6 |   from typing import Any
  |
help: Insert single blank line

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `*params`
  --> app/utils/safe_query_builder.py:54:54
   |
52 |             self.parameters: list[Any] = []
53 |
54 |     def add_condition(self, condition: str, *params: Any) -> "SafeQueryBuilder":
   |                                                      ^^^
55 |         """添加查询条件.
   |

ERA001 Found commented-out code
   --> app/utils/safe_query_builder.py:118:9
    |
116 |             # SQL Server使用%s占位符
117 |             return ", ".join(["%s"] * count)
118 |         # MySQL, PostgreSQL使用%s
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^
119 |         return ", ".join(["%s"] * count)
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/safe_query_builder.py:314:13
    |
312 |         # 处理排除用户
313 |         if values:
314 |             # PostgreSQL特殊处理:保留postgres用户
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
315 |             if self.db_type == DatabaseType.POSTGRESQL and "postgres" in values:
316 |                 filtered_values = [v for v in values if v != "postgres"]
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/safe_query_builder.py:324:13
    |
322 |         # 处理排除模式
323 |         for pattern in patterns:
324 |             # PostgreSQL特殊处理:pg_%模式不排除postgres用户
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
325 |             if self.db_type == DatabaseType.POSTGRESQL and pattern == "pg_%":
326 |                 self.add_condition(f"({field} NOT LIKE %s OR {field} = %s)", pattern, "postgres")
    |
help: Remove commented-out code

ERA001 Found commented-out code
   --> app/utils/safe_query_builder.py:420:5
    |
418 |     where_clause, params = build_safe_filter_conditions(db_type, username_field, filter_rules)
419 |
420 |     # 如果是Oracle返回的dict,转换为list(虽然会丢失命名信息,但保持兼容性)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
421 |     if isinstance(params, dict):
422 |         return where_clause, list(params.values())
    |
help: Remove commented-out code

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `value`
  --> app/utils/sensitive_data.py:49:23
   |
47 |         normalized_keys.update(str(key).lower() for key in extra_keys)
48 |
49 |     def _scrub(value: Any, *, field_name: str | None = None) -> Any:
   |                       ^^^
50 |         key_lower = field_name.lower() if field_name else None
51 |         if key_lower and key_lower in normalized_keys:
   |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `_scrub`
  --> app/utils/sensitive_data.py:49:65
   |
47 |         normalized_keys.update(str(key).lower() for key in extra_keys)
48 |
49 |     def _scrub(value: Any, *, field_name: str | None = None) -> Any:
   |                                                                 ^^^
50 |         key_lower = field_name.lower() if field_name else None
51 |         if key_lower and key_lower in normalized_keys:
   |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/sqlserver_connection_utils.py:150:13
    |
148 |         try:
149 |             socket.gethostbyname(host)
150 |             return True
    |             ^^^^^^^^^^^
151 |         except socket.gaierror:
152 |             return False
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/sqlserver_connection_utils.py:172:13
    |
170 |             result = sock.connect_ex((host, port))
171 |             sock.close()
172 |             return result == 0
    |             ^^^^^^^^^^^^^^^^^^
173 |         except Exception:
174 |             return False
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/sqlserver_connection_utils.py:173:16
    |
171 |             sock.close()
172 |             return result == 0
173 |         except Exception:
    |                ^^^^^^^^^
174 |             return False
    |

E501 Line too long (124 > 120)
   --> app/utils/sqlserver_connection_utils.py:176:121
    |
174 |             return False
175 |
176 |     def get_connection_string_suggestions(self, host: str, port: int, username: str, database: str = "master") -> list[str]:
    |                                                                                                                         ^^^^
177 |         """获取连接字符串建议.
    |

E501 Line too long (126 > 120)
   --> app/utils/sqlserver_connection_utils.py:204:121
    |
203 |         # 带超时的连接字符串
204 |         suggestions.append(f"Server={host},{port};Database={database};User Id={username};Password=***;Connection Timeout=60;")
    |                                                                                                                         ^^^^^^
205 |
206 |         # 带加密的连接字符串
    |

E501 Line too long (145 > 120)
   --> app/utils/sqlserver_connection_utils.py:207:121
    |
206 | …
207 | …e};User Id={username};Password=***;Encrypt=True;TrustServerCertificate=True;")
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^
208 | …
209 | …
    |

E501 Line too long (146 > 120)
   --> app/utils/sqlserver_connection_utils.py:210:121
    |
209 | …
210 | …e};User Id={username};Password=***;Connection Timeout=60;Command Timeout=300;")
    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^
211 | …
212 | …
    |

E501 Line too long (138 > 120)
   --> app/utils/sqlserver_connection_utils.py:237:121
    |
235 | …
236 | …
237 | …ower() for keyword in ["timeout", "connection", "network", "unreachable"]),
    |                                                           ^^^^^^^^^^^^^^^^^^
238 | …r() for keyword in ["login", "authentication", "password", "user"]),
239 | …wer() for keyword in ["server", "service", "database", "sql"]),
    |

E501 Line too long (131 > 120)
   --> app/utils/sqlserver_connection_utils.py:238:121
    |
236 | …
237 | …e.lower() for keyword in ["timeout", "connection", "network", "unreachable"]),
238 | …ower() for keyword in ["login", "authentication", "password", "user"]),
    |                                                              ^^^^^^^^^^^
239 | ….lower() for keyword in ["server", "service", "database", "sql"]),
240 | …sage.lower() for keyword in ["permission", "access", "denied", "unauthorized"]),
    |

E501 Line too long (126 > 120)
   --> app/utils/sqlserver_connection_utils.py:239:121
    |
237 | …         "has_network_error": any(keyword in error_message.lower() for keyword in ["timeout", "connection", "network", "unreachable"…
238 | …         "has_auth_error": any(keyword in error_message.lower() for keyword in ["login", "authentication", "password", "user"]),
239 | …         "has_server_error": any(keyword in error_message.lower() for keyword in ["server", "service", "database", "sql"]),
    |                                                                                                                       ^^^^^^
240 | …         "has_permission_error": any(keyword in error_message.lower() for keyword in ["permission", "access", "denied", "unauthorize…
241 | …     }
    |

E501 Line too long (140 > 120)
   --> app/utils/sqlserver_connection_utils.py:240:121
    |
238 | …() for keyword in ["login", "authentication", "password", "user"]),
239 | …er() for keyword in ["server", "service", "database", "sql"]),
240 | ….lower() for keyword in ["permission", "access", "denied", "unauthorized"]),
    |                                                          ^^^^^^^^^^^^^^^^^^^^
241 | …
    |

ANN001 Missing type annotation for function argument `app`
  --> app/utils/structlog_config.py:56:25
   |
54 |         self.configured = False
55 |
56 |     def configure(self, app=None) -> None:
   |                         ^^^
57 |         """初始化 structlog 处理器(幂等).
   |

ANN001 Missing type annotation for function argument `app`
  --> app/utils/structlog_config.py:94:27
   |
92 |             self._attach_app(app)
93 |
94 |     def _attach_app(self, app) -> None:
   |                           ^^^
95 |         """绑定位于 Flask 应用上的队列配置.
   |

ANN202 Missing return type annotation for private function `_add_request_context`
   --> app/utils/structlog_config.py:119:9
    |
117 |         self.debug_filter.set_enabled(enable_debug)
118 |
119 |     def _add_request_context(self, logger, method_name, event_dict):
    |         ^^^^^^^^^^^^^^^^^^^^
120 |         """向事件字典写入请求上下文.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `logger`
   --> app/utils/structlog_config.py:119:36
    |
117 |         self.debug_filter.set_enabled(enable_debug)
118 |
119 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                    ^^^^^^
120 |         """向事件字典写入请求上下文.
    |

ARG002 Unused method argument: `logger`
   --> app/utils/structlog_config.py:119:36
    |
117 |         self.debug_filter.set_enabled(enable_debug)
118 |
119 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                    ^^^^^^
120 |         """向事件字典写入请求上下文.
    |

ANN001 Missing type annotation for function argument `method_name`
   --> app/utils/structlog_config.py:119:44
    |
117 |         self.debug_filter.set_enabled(enable_debug)
118 |
119 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                            ^^^^^^^^^^^
120 |         """向事件字典写入请求上下文.
    |

ARG002 Unused method argument: `method_name`
   --> app/utils/structlog_config.py:119:44
    |
117 |         self.debug_filter.set_enabled(enable_debug)
118 |
119 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                            ^^^^^^^^^^^
120 |         """向事件字典写入请求上下文.
    |

ANN001 Missing type annotation for function argument `event_dict`
   --> app/utils/structlog_config.py:119:57
    |
117 |         self.debug_filter.set_enabled(enable_debug)
118 |
119 |     def _add_request_context(self, logger, method_name, event_dict):
    |                                                         ^^^^^^^^^^
120 |         """向事件字典写入请求上下文.
    |

ANN202 Missing return type annotation for private function `_add_user_context`
   --> app/utils/structlog_config.py:136:9
    |
134 |         return event_dict
135 |
136 |     def _add_user_context(self, logger, method_name, event_dict):
    |         ^^^^^^^^^^^^^^^^^
137 |         """附加当前用户上下文.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `logger`
   --> app/utils/structlog_config.py:136:33
    |
134 |         return event_dict
135 |
136 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                 ^^^^^^
137 |         """附加当前用户上下文.
    |

ARG002 Unused method argument: `logger`
   --> app/utils/structlog_config.py:136:33
    |
134 |         return event_dict
135 |
136 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                 ^^^^^^
137 |         """附加当前用户上下文.
    |

ANN001 Missing type annotation for function argument `method_name`
   --> app/utils/structlog_config.py:136:41
    |
134 |         return event_dict
135 |
136 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                         ^^^^^^^^^^^
137 |         """附加当前用户上下文.
    |

ARG002 Unused method argument: `method_name`
   --> app/utils/structlog_config.py:136:41
    |
134 |         return event_dict
135 |
136 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                         ^^^^^^^^^^^
137 |         """附加当前用户上下文.
    |

ANN001 Missing type annotation for function argument `event_dict`
   --> app/utils/structlog_config.py:136:54
    |
134 |         return event_dict
135 |
136 |     def _add_user_context(self, logger, method_name, event_dict):
    |                                                      ^^^^^^^^^^
137 |         """附加当前用户上下文.
    |

ANN202 Missing return type annotation for private function `_add_global_context`
   --> app/utils/structlog_config.py:154:9
    |
152 |         return event_dict
153 |
154 |     def _add_global_context(self, logger, method_name, event_dict):
    |         ^^^^^^^^^^^^^^^^^^^
155 |         """附加环境、版本等全局上下文.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `logger`
   --> app/utils/structlog_config.py:154:35
    |
152 |         return event_dict
153 |
154 |     def _add_global_context(self, logger, method_name, event_dict):
    |                                   ^^^^^^
155 |         """附加环境、版本等全局上下文.
    |

ANN001 Missing type annotation for function argument `method_name`
   --> app/utils/structlog_config.py:154:43
    |
152 |         return event_dict
153 |
154 |     def _add_global_context(self, logger, method_name, event_dict):
    |                                           ^^^^^^^^^^^
155 |         """附加环境、版本等全局上下文.
    |

ARG002 Unused method argument: `method_name`
   --> app/utils/structlog_config.py:154:43
    |
152 |         return event_dict
153 |
154 |     def _add_global_context(self, logger, method_name, event_dict):
    |                                           ^^^^^^^^^^^
155 |         """附加环境、版本等全局上下文.
    |

ANN001 Missing type annotation for function argument `event_dict`
   --> app/utils/structlog_config.py:154:56
    |
152 |         return event_dict
153 |
154 |     def _add_global_context(self, logger, method_name, event_dict):
    |                                                        ^^^^^^^^^^
155 |         """附加环境、版本等全局上下文.
    |

ANN202 Missing return type annotation for private function `_get_console_renderer`
   --> app/utils/structlog_config.py:180:9
    |
178 |         return event_dict
179 |
180 |     def _get_console_renderer(self):
    |         ^^^^^^^^^^^^^^^^^^^^^
181 |         """根据终端能力返回渲染器.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `app`
   --> app/utils/structlog_config.py:232:25
    |
232 | def configure_structlog(app) -> None:
    |                         ^^^
233 |     """配置 structlog 并注册 Flask 钩子.
    |

ANN001 Missing type annotation for function argument `exception`
   --> app/utils/structlog_config.py:245:28
    |
244 |     @app.teardown_appcontext
245 |     def log_teardown_error(exception) -> None:
    |                            ^^^^^^^^^
246 |         if exception:
247 |             get_logger("app").error("应用请求处理异常", module="system", exception=str(exception))
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:263:49
    |
263 | def log_info(message: str, module: str = "app", **kwargs) -> None:
    |                                                 ^^^^^^^^
264 |     """记录信息级别日志.
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:282:88
    |
282 | def log_warning(message: str, module: str = "app", exception: Exception | None = None, **kwargs) -> None:
    |                                                                                        ^^^^^^^^
283 |     """记录警告级别日志.
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:305:86
    |
305 | def log_error(message: str, module: str = "app", exception: Exception | None = None, **kwargs) -> None:
    |                                                                                      ^^^^^^^^
306 |     """记录错误级别日志.
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:331:89
    |
331 | def log_critical(message: str, module: str = "app", exception: Exception | None = None, **kwargs) -> None:
    |                                                                                         ^^^^^^^^
332 |     """记录严重错误级别日志.
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:354:50
    |
354 | def log_debug(message: str, module: str = "app", **kwargs) -> None:
    |                                                  ^^^^^^^^
355 |     """记录调试级别日志.
    |

ANN201 Missing return type annotation for public function `error_handler`
   --> app/utils/structlog_config.py:529:5
    |
529 | def error_handler(func: Callable):
    |     ^^^^^^^^^^^^^
530 |     """Flask 视图装饰器,统一捕获异常并输出结构化日志.
    |
help: Add return type annotation

PLC0415 `import` should be at the top-level of a file
   --> app/utils/structlog_config.py:539:5
    |
538 |     """
539 |     from functools import wraps
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
540 |
541 |     from flask import jsonify
    |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/structlog_config.py:541:5
    |
539 |     from functools import wraps
540 |
541 |     from flask import jsonify
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^
542 |
543 |     @wraps(func)
    |

ANN202 Missing return type annotation for private function `wrapper`
   --> app/utils/structlog_config.py:544:9
    |
543 |     @wraps(func)
544 |     def wrapper(*args, **kwargs):
    |         ^^^^^^^
545 |         try:
546 |             return func(*args, **kwargs)
    |
help: Add return type annotation

ANN002 Missing type annotation for `*args`
   --> app/utils/structlog_config.py:544:17
    |
543 |     @wraps(func)
544 |     def wrapper(*args, **kwargs):
    |                 ^^^^^
545 |         try:
546 |             return func(*args, **kwargs)
    |

ANN003 Missing type annotation for `**kwargs`
   --> app/utils/structlog_config.py:544:24
    |
543 |     @wraps(func)
544 |     def wrapper(*args, **kwargs):
    |                        ^^^^^^^^
545 |         try:
546 |             return func(*args, **kwargs)
    |

BLE001 Do not catch blind exception: `Exception`
   --> app/utils/structlog_config.py:547:16
    |
545 |         try:
546 |             return func(*args, **kwargs)
547 |         except Exception as error:
    |                ^^^^^^^^^
548 |             context = ErrorContext(error)
549 |             payload = enhanced_error_handler(error, context)
    |

D205 1 blank line required between summary line and description
 --> app/utils/time_utils.py:1:1
  |
1 | / """统一时间处理工具模块
2 | | 基于Python 3.9+的zoneinfo模块,提供一致的时间处理功能.
3 | | """
  | |___^
4 |
5 |   from datetime import UTC, date, datetime
  |
help: Insert single blank line

PLC0415 `import` should be at the top-level of a file
  --> app/utils/time_utils.py:93:13
   |
91 |             return dt.astimezone(CHINA_TZ)
92 |         except (ValueError, TypeError) as e:
93 |             from app.utils.structlog_config import get_system_logger
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
94 |
95 |             get_system_logger().warning(f"时间转换错误: {e}")
   |

PLC0415 `import` should be at the top-level of a file
   --> app/utils/time_utils.py:126:13
    |
124 |             return dt.astimezone(UTC_TZ)
125 |         except (ValueError, TypeError) as e:
126 |             from app.utils.structlog_config import get_system_logger
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
127 |
128 |             get_system_logger().warning(f"时间转换错误: {e}")
    |

PLR0911 Too many return statements (7 > 6)
   --> app/utils/time_utils.py:176:9
    |
175 |     @staticmethod
176 |     def get_relative_time(dt: str | date | datetime | None) -> str:
    |         ^^^^^^^^^^^^^^^^^
177 |         """获取相对时间描述.
    |

PLR2004 Magic value used in comparison, consider replacing `60` with a constant variable
   --> app/utils/time_utils.py:196:39
    |
194 |             diff = now - china_dt
195 |
196 |             if diff.total_seconds() < 60:
    |                                       ^^
197 |                 return "刚刚"
198 |             if diff.total_seconds() < TimeConstants.ONE_HOUR:
    |

PLR2004 Magic value used in comparison, consider replacing `7` with a constant variable
   --> app/utils/time_utils.py:204:28
    |
202 |                 hours = int(diff.total_seconds() / TimeConstants.ONE_HOUR)
203 |                 return f"{hours}小时前"
204 |             if diff.days < 7:
    |                            ^
205 |                 return f"{diff.days}天前"
206 |             return TimeUtils.format_china_time(china_dt)
    |

PLR2004 Magic value used in comparison, consider replacing `24` with a constant variable
   --> app/utils/time_utils.py:244:20
    |
242 |         now = TimeUtils.now_china()
243 |         start = now.replace(hour=0, minute=0, second=0, microsecond=0)
244 |         if hours < 24:
    |                    ^^
245 |             start = now.replace(hour=now.hour - hours, minute=0, second=0, microsecond=0)
    |

TRY300 Consider moving this statement to an `else` block
   --> app/utils/time_utils.py:275:13
    |
273 |             if isinstance(dt, date):
274 |                 return dt.isoformat()
275 |             return None
    |             ^^^^^^^^^^^
276 |         except (ValueError, TypeError):
277 |             return None
    |

ERA001 Found commented-out code
   --> app/utils/time_utils.py:287:1
    |
287 | # 常量(向后兼容)
    | ^^^^^^^^^^^^^^^^
288 | # UTC_TZ 已在文件顶部定义
    |
help: Remove commented-out code

D205 1 blank line required between summary line and description
 --> app/utils/version_parser.py:1:1
  |
1 | / """数据库版本解析工具
2 | | 使用正则表达式提取简洁的版本信息.
3 | | """
  | |___^
4 |
5 |   import re
  |
help: Insert single blank line

RUF012 Mutable class attributes should be annotated with `typing.ClassVar`
  --> app/utils/version_parser.py:28:24
   |
27 |       # 版本提取正则表达式
28 |       VERSION_PATTERNS = {
   |  ________________________^
29 | |         "mysql": [
30 | |             r"(\d+\.\d+\.\d+)",  # 8.0.32
31 | |             r"(\d+\.\d+)",  # 8.0
32 | |         ],
33 | |         "postgresql": [
34 | |             r"PostgreSQL\s+(\d+\.\d+)",  # PostgreSQL 13.4
35 | |             r"(\d+\.\d+)",  # 13.4
36 | |         ],
37 | |         "sqlserver": [
38 | |             r"Microsoft SQL Server \d+\s+\([^)]+\)\s+\([^)]+\)\s+-\s+(\d+\.\d+\.\d+\.\d+)",  # 14.0.3465.1
39 | |             r"(\d+\.\d+\.\d+\.\d+)",  # 14.0.3465.1
40 | |         ],
41 | |         "oracle": [
42 | |             r"Oracle Database \d+g Release (\d+\.\d+\.\d+\.\d+\.\d+)",  # Oracle Database 11g Release 11.2.0.1.0
43 | |             r"(\d+\.\d+\.\d+\.\d+\.\d+)",  # 11.2.0.1.0
44 | |         ],
45 | |     }
   | |_____^
46 |
47 |       @classmethod
   |

PLR2004 Magic value used in comparison, consider replacing `50` with a constant variable
  --> app/utils/version_parser.py:86:86
   |
84 |         return {
85 |             "main_version": "未知",
86 |             "detailed_version": version_string[:50] + "..." if len(version_string) > 50 else version_string,
   |                                                                                      ^^
87 |             "original": version_string,
88 |         }
   |

C901 `_extract_main_version` is too complex (11 > 10)
  --> app/utils/version_parser.py:91:9
   |
90 |     @classmethod
91 |     def _extract_main_version(cls, version: str, db_type: str) -> str:
   |         ^^^^^^^^^^^^^^^^^^^^^
92 |         """提取主版本号.
   |

PLR0911 Too many return statements (11 > 6)
  --> app/utils/version_parser.py:91:9
   |
90 |     @classmethod
91 |     def _extract_main_version(cls, version: str, db_type: str) -> str:
   |         ^^^^^^^^^^^^^^^^^^^^^
92 |         """提取主版本号.
   |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:115:30
    |
113 |             # MySQL: 8.0.32 -> 8.0
114 |             parts = version.split(".")
115 |             if len(parts) >= 2:
    |                              ^
116 |                 return f"{parts[0]}.{parts[1]}"
117 |             return version
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:122:30
    |
120 |             # PostgreSQL: 13.4 -> 13.4
121 |             parts = version.split(".")
122 |             if len(parts) >= 2:
    |                              ^
123 |                 return f"{parts[0]}.{parts[1]}"
124 |             return version
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:129:30
    |
127 |             # SQL Server: 14.0.3465.1 -> 14.0
128 |             parts = version.split(".")
129 |             if len(parts) >= 2:
    |                              ^
130 |                 return f"{parts[0]}.{parts[1]}"
131 |             return version
    |

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:136:30
    |
134 |             # Oracle: 11.2.0.1.0 -> 11.2
135 |             parts = version.split(".")
136 |             if len(parts) >= 2:
    |                              ^
137 |                 return f"{parts[0]}.{parts[1]}"
138 |             return version
    |

ERA001 Found commented-out code
   --> app/utils/version_parser.py:140:9
    |
138 |             return version
139 |
140 |         # 默认情况:取前两个部分
    |         ^^^^^^^^^^^^^^^^^^^^^^^
141 |         parts = version.split(".")
142 |         if len(parts) >= 2:
    |
help: Remove commented-out code

PLR2004 Magic value used in comparison, consider replacing `2` with a constant variable
   --> app/utils/version_parser.py:142:26
    |
140 |         # 默认情况:取前两个部分
141 |         parts = version.split(".")
142 |         if len(parts) >= 2:
    |                          ^
143 |             return f"{parts[0]}.{parts[1]}"
144 |         return version
    |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/classification_forms.py:20:9
   |
18 |     form_definition = CLASSIFICATION_FORM_DEFINITION
19 |
20 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
21 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:20:41
   |
18 |     form_definition = CLASSIFICATION_FORM_DEFINITION
19 |
20 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
21 |         """解析成功后的重定向地址.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:20:41
   |
18 |     form_definition = CLASSIFICATION_FORM_DEFINITION
19 |
20 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
21 |         """解析成功后的重定向地址.
   |

ANN202 Missing return type annotation for private function `_success_redirect_kwargs`
  --> app/views/classification_forms.py:32:9
   |
30 |         return url_for("account_classification.index")
31 |
32 |     def _success_redirect_kwargs(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^
33 |         """获取重定向的额外参数.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:32:40
   |
30 |         return url_for("account_classification.index")
31 |
32 |     def _success_redirect_kwargs(self, instance):
   |                                        ^^^^^^^^
33 |         """获取重定向的额外参数.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:32:40
   |
30 |         return url_for("account_classification.index")
31 |
32 |     def _success_redirect_kwargs(self, instance):
   |                                        ^^^^^^^^
33 |         """获取重定向的额外参数.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:44:35
   |
42 |         return {}
43 |
44 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
45 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:44:35
   |
42 |         return {}
43 |
44 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
45 |         """获取成功消息.
   |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/classification_forms.py:67:9
   |
65 |     form_definition = CLASSIFICATION_RULE_FORM_DEFINITION
66 |
67 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
68 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:67:41
   |
65 |     form_definition = CLASSIFICATION_RULE_FORM_DEFINITION
66 |
67 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
68 |         """解析成功后的重定向地址.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:67:41
   |
65 |     form_definition = CLASSIFICATION_RULE_FORM_DEFINITION
66 |
67 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
68 |         """解析成功后的重定向地址.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/classification_forms.py:79:35
   |
77 |         return url_for("account_classification.index")
78 |
79 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
80 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/classification_forms.py:79:35
   |
77 |         return url_for("account_classification.index")
78 |
79 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
80 |         """获取成功消息.
   |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/credential_forms.py:19:9
   |
17 |     form_definition = CREDENTIAL_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
20 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/credential_forms.py:19:41
   |
17 |     form_definition = CREDENTIAL_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
20 |         """解析成功后的重定向地址.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/credential_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/credential_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/instance_forms.py:19:9
   |
17 |     form_definition = INSTANCE_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
20 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/instance_forms.py:19:41
   |
17 |     form_definition = INSTANCE_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
20 |         """解析成功后的重定向地址.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/instance_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/instance_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

D205 1 blank line required between summary line and description
 --> app/views/mixins/resource_forms.py:1:1
  |
1 | / """通用资源表单视图.
2 | | ------------------
3 | | 集成 GET/POST 逻辑,依赖 ResourceFormDefinition 与 BaseResourceService.
4 | | """
  | |___^
5 |
6 |   from __future__ import annotations
  |
help: Insert single blank line

ANN003 Missing type annotation for `**kwargs`
  --> app/views/mixins/resource_forms.py:58:51
   |
56 |     # HTTP Methods
57 |     # ------------------------------------------------------------------ #
58 |     def get(self, resource_id: int | None = None, **kwargs) -> str:
   |                                                   ^^^^^^^^
59 |         """GET 请求处理,显示表单.
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/views/mixins/resource_forms.py:73:52
   |
71 |         return render_template(self.form_definition.template, **context)
72 |
73 |     def post(self, resource_id: int | None = None, **kwargs) -> str | Response:
   |                                                    ^^^^^^^^
74 |         """POST 请求处理,提交表单.
   |

ANN202 Missing return type annotation for private function `_load_resource`
   --> app/views/mixins/resource_forms.py:102:9
    |
100 |     # Helpers
101 |     # ------------------------------------------------------------------ #
102 |     def _load_resource(self, resource_id: int | None):
    |         ^^^^^^^^^^^^^^
103 |         """加载资源对象.
    |
help: Add return type annotation

ANN001 Missing type annotation for function argument `req`
   --> app/views/mixins/resource_forms.py:136:32
    |
134 |         return None
135 |
136 |     def _extract_payload(self, req) -> Mapping[str, Any]:
    |                                ^^^
137 |         """提取请求负载数据.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `resource`
   --> app/views/mixins/resource_forms.py:152:19
    |
150 |     def _build_context(
151 |         self,
152 |         resource: Any | None,
    |                   ^^^^^^^^^^
153 |         form_data: Mapping[str, Any] | None,
154 |         errors: str | None = None,
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/views/mixins/resource_forms.py:185:51
    |
183 |         return base_context
184 |
185 |     def _resolve_success_redirect(self, instance: Any) -> str:
    |                                                   ^^^
186 |         """解析成功后的重定向地址.
    |

ARG002 Unused method argument: `instance`
   --> app/views/mixins/resource_forms.py:200:40
    |
198 |         return url_for(endpoint, **self._success_redirect_kwargs(instance))
199 |
200 |     def _success_redirect_kwargs(self, instance: Any) -> dict[str, Any]:
    |                                        ^^^^^^^^
201 |         """获取重定向的额外参数.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/views/mixins/resource_forms.py:200:50
    |
198 |         return url_for(endpoint, **self._success_redirect_kwargs(instance))
199 |
200 |     def _success_redirect_kwargs(self, instance: Any) -> dict[str, Any]:
    |                                                  ^^^
201 |         """获取重定向的额外参数.
    |

ARG002 Unused method argument: `instance`
   --> app/views/mixins/resource_forms.py:212:35
    |
210 |         return {}
211 |
212 |     def get_success_message(self, instance: Any) -> str:
    |                                   ^^^^^^^^
213 |         """获取成功消息.
    |

ANN401 Dynamically typed expressions (typing.Any) are disallowed in `instance`
   --> app/views/mixins/resource_forms.py:212:45
    |
210 |         return {}
211 |
212 |     def get_success_message(self, instance: Any) -> str:
    |                                             ^^^
213 |         """获取成功消息.
    |

ANN202 Missing return type annotation for private function `_load_resource`
  --> app/views/password_forms.py:19:9
   |
17 |     form_definition = CHANGE_PASSWORD_FORM_DEFINITION
18 |
19 |     def _load_resource(self, resource_id):
   |         ^^^^^^^^^^^^^^
20 |         """加载用户资源.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `resource_id`
  --> app/views/password_forms.py:19:30
   |
17 |     form_definition = CHANGE_PASSWORD_FORM_DEFINITION
18 |
19 |     def _load_resource(self, resource_id):
   |                              ^^^^^^^^^^^
20 |         """加载用户资源.
   |

ARG002 Unused method argument: `resource_id`
  --> app/views/password_forms.py:19:30
   |
17 |     form_definition = CHANGE_PASSWORD_FORM_DEFINITION
18 |
19 |     def _load_resource(self, resource_id):
   |                              ^^^^^^^^^^^
20 |         """加载用户资源.
   |

ANN002 Missing type annotation for `*args`
  --> app/views/scheduler_forms.py:23:19
   |
21 |     form_definition = SCHEDULER_JOB_FORM_DEFINITION
22 |
23 |     def get(self, *args, **kwargs) -> Never:
   |                   ^^^^^
24 |         """GET 请求处理(不支持).
   |

ARG002 Unused method argument: `args`
  --> app/views/scheduler_forms.py:23:20
   |
21 |     form_definition = SCHEDULER_JOB_FORM_DEFINITION
22 |
23 |     def get(self, *args, **kwargs) -> Never:
   |                    ^^^^
24 |         """GET 请求处理(不支持).
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/views/scheduler_forms.py:23:26
   |
21 |     form_definition = SCHEDULER_JOB_FORM_DEFINITION
22 |
23 |     def get(self, *args, **kwargs) -> Never:
   |                          ^^^^^^^^
24 |         """GET 请求处理(不支持).
   |

ARG002 Unused method argument: `kwargs`
  --> app/views/scheduler_forms.py:23:28
   |
21 |     form_definition = SCHEDULER_JOB_FORM_DEFINITION
22 |
23 |     def get(self, *args, **kwargs) -> Never:
   |                            ^^^^^^
24 |         """GET 请求处理(不支持).
   |

ANN002 Missing type annotation for `*args`
  --> app/views/scheduler_forms.py:36:20
   |
34 |         raise NotFoundError(msg)
35 |
36 |     def post(self, *args, **kwargs) -> Never:
   |                    ^^^^^
37 |         """POST 请求处理(不支持).
   |

ARG002 Unused method argument: `args`
  --> app/views/scheduler_forms.py:36:21
   |
34 |         raise NotFoundError(msg)
35 |
36 |     def post(self, *args, **kwargs) -> Never:
   |                     ^^^^
37 |         """POST 请求处理(不支持).
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/views/scheduler_forms.py:36:27
   |
34 |         raise NotFoundError(msg)
35 |
36 |     def post(self, *args, **kwargs) -> Never:
   |                           ^^^^^^^^
37 |         """POST 请求处理(不支持).
   |

ARG002 Unused method argument: `kwargs`
  --> app/views/scheduler_forms.py:36:29
   |
34 |         raise NotFoundError(msg)
35 |
36 |     def post(self, *args, **kwargs) -> Never:
   |                             ^^^^^^
37 |         """POST 请求处理(不支持).
   |

ANN003 Missing type annotation for `**kwargs`
  --> app/views/scheduler_forms.py:49:32
   |
47 |         raise NotFoundError(msg)
48 |
49 |     def put(self, job_id: str, **kwargs) -> Response:
   |                                ^^^^^^^^
50 |         """PUT 请求处理,更新定时任务.
   |

ARG002 Unused method argument: `kwargs`
  --> app/views/scheduler_forms.py:49:34
   |
47 |         raise NotFoundError(msg)
48 |
49 |     def put(self, job_id: str, **kwargs) -> Response:
   |                                  ^^^^^^
50 |         """PUT 请求处理,更新定时任务.
   |

BLE001 Do not catch blind exception: `Exception`
  --> app/views/scheduler_forms.py:78:16
   |
76 |         except (NotFoundError, ValidationError, SystemError):
77 |             raise
78 |         except Exception as exc:
   |                ^^^^^^^^^
79 |             return jsonify_unified_error_message(message="任务更新失败", extra={"exception": str(exc)})
   |

ANN202 Missing return type annotation for private function `_load_resource`
  --> app/views/scheduler_forms.py:81:9
   |
79 |             return jsonify_unified_error_message(message="任务更新失败", extra={"exception": str(exc)})
80 |
81 |     def _load_resource(self, job_id):
   |         ^^^^^^^^^^^^^^
82 |         """加载任务资源.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `job_id`
  --> app/views/scheduler_forms.py:81:30
   |
79 |             return jsonify_unified_error_message(message="任务更新失败", extra={"exception": str(exc)})
80 |
81 |     def _load_resource(self, job_id):
   |                              ^^^^^^
82 |         """加载任务资源.
   |

ANN202 Missing return type annotation for private function `_resolve_success_redirect`
  --> app/views/tag_forms.py:19:9
   |
17 |     form_definition = TAG_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
20 |         """解析成功后的重定向地址.
   |
help: Add return type annotation

ANN001 Missing type annotation for function argument `instance`
  --> app/views/tag_forms.py:19:41
   |
17 |     form_definition = TAG_FORM_DEFINITION
18 |
19 |     def _resolve_success_redirect(self, instance):
   |                                         ^^^^^^^^
20 |         """解析成功后的重定向地址.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/tag_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/tag_forms.py:33:35
   |
31 |         return super()._resolve_success_redirect(instance)
32 |
33 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
34 |         """获取成功消息.
   |

ANN001 Missing type annotation for function argument `instance`
  --> app/views/user_forms.py:19:35
   |
17 |     form_definition = USER_FORM_DEFINITION
18 |
19 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
20 |         """获取成功消息.
   |

ARG002 Unused method argument: `instance`
  --> app/views/user_forms.py:19:35
   |
17 |     form_definition = USER_FORM_DEFINITION
18 |
19 |     def get_success_message(self, instance) -> str:
   |                                   ^^^^^^^^
20 |         """获取成功消息.
   |

INP001 File `migrations/env.py` is part of an implicit namespace package. Add an `__init__.py`.
--> migrations/env.py:1:1

ANN201 Missing return type annotation for public function `get_engine`
  --> migrations/env.py:22:5
   |
22 | def get_engine():
   |     ^^^^^^^^^^
23 |     """获取当前 Flask 应用绑定的 SQLAlchemy Engine。
   |
help: Add return type annotation

D400 First line should end with a period
  --> migrations/env.py:23:5
   |
22 |   def get_engine():
23 | /     """获取当前 Flask 应用绑定的 SQLAlchemy Engine。
24 | |
25 | |     函数首先尝试兼容 Flask-SQLAlchemy < 3 的 get_engine 写法,若失败则回退到
26 | |     v3 及以上版本提供的 engine 属性。
27 | |
28 | |     Args:
29 | |         None.
30 | |
31 | |     Returns:
32 | |         Engine: 供 Alembic 使用的 SQLAlchemy Engine 实例。
33 | |
34 | |     Raises:
35 | |         RuntimeError: 当 Flask 应用尚未初始化迁移扩展时可能抛出。
36 | |     """
   | |_______^
37 |       try:
38 |           # this works with Flask-SQLAlchemy<3 and Alchemical
   |
help: Add period

D415 First line should end with a period, question mark, or exclamation point
  --> migrations/env.py:23:5
   |
22 |   def get_engine():
23 | /     """获取当前 Flask 应用绑定的 SQLAlchemy Engine。
24 | |
25 | |     函数首先尝试兼容 Flask-SQLAlchemy < 3 的 get_engine 写法,若失败则回退到
26 | |     v3 及以上版本提供的 engine 属性。
27 | |
28 | |     Args:
29 | |         None.
30 | |
31 | |     Returns:
32 | |         Engine: 供 Alembic 使用的 SQLAlchemy Engine 实例。
33 | |
34 | |     Raises:
35 | |         RuntimeError: 当 Flask 应用尚未初始化迁移扩展时可能抛出。
36 | |     """
   | |_______^
37 |       try:
38 |           # this works with Flask-SQLAlchemy<3 and Alchemical
   |
help: Add closing punctuation

D413 [*] Missing blank line after last section ("Raises")
  --> migrations/env.py:34:5
   |
32 |         Engine: 供 Alembic 使用的 SQLAlchemy Engine 实例。
33 |
34 |     Raises:
   |     ^^^^^^
35 |         RuntimeError: 当 Flask 应用尚未初始化迁移扩展时可能抛出。
36 |     """
   |
help: Add blank line after "Raises"

ANN201 Missing return type annotation for public function `get_engine_url`
  --> migrations/env.py:45:5
   |
45 | def get_engine_url():
   |     ^^^^^^^^^^^^^^
46 |     """生成数据库连接串,供 Alembic 配置使用。
   |
help: Add return type annotation

D400 First line should end with a period
  --> migrations/env.py:46:5
   |
45 |   def get_engine_url():
46 | /     """生成数据库连接串,供 Alembic 配置使用。
47 | |
48 | |     优先使用 SQLAlchemy 2.0 的 render_as_string 保留密码,否则退化为 str(url)。
49 | |
50 | |     Args:
51 | |         None.
52 | |
53 | |     Returns:
54 | |         str: 经过百分号转义的数据库连接串。
55 | |
56 | |     Raises:
57 | |         RuntimeError: 当获取 Engine 失败时抛出。
58 | |     """
   | |_______^
59 |       try:
60 |           return get_engine().url.render_as_string(hide_password=False).replace(
   |
help: Add period

D415 First line should end with a period, question mark, or exclamation point
  --> migrations/env.py:46:5
   |
45 |   def get_engine_url():
46 | /     """生成数据库连接串,供 Alembic 配置使用。
47 | |
48 | |     优先使用 SQLAlchemy 2.0 的 render_as_string 保留密码,否则退化为 str(url)。
49 | |
50 | |     Args:
51 | |         None.
52 | |
53 | |     Returns:
54 | |         str: 经过百分号转义的数据库连接串。
55 | |
56 | |     Raises:
57 | |         RuntimeError: 当获取 Engine 失败时抛出。
58 | |     """
   | |_______^
59 |       try:
60 |           return get_engine().url.render_as_string(hide_password=False).replace(
   |
help: Add closing punctuation

D413 [*] Missing blank line after last section ("Raises")
  --> migrations/env.py:56:5
   |
54 |         str: 经过百分号转义的数据库连接串。
55 |
56 |     Raises:
   |     ^^^^^^
57 |         RuntimeError: 当获取 Engine 失败时抛出。
58 |     """
   |
help: Add blank line after "Raises"

ERA001 Found commented-out code
  --> migrations/env.py:68:1
   |
66 | # add your model's MetaData object here
67 | # for 'autogenerate' support
68 | # from myapp import mymodel
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
69 | # target_metadata = mymodel.Base.metadata
70 | config.set_main_option("sqlalchemy.url", get_engine_url())
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> migrations/env.py:69:1
   |
67 | # for 'autogenerate' support
68 | # from myapp import mymodel
69 | # target_metadata = mymodel.Base.metadata
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
70 | config.set_main_option("sqlalchemy.url", get_engine_url())
71 | target_db = current_app.extensions["migrate"].db
   |
help: Remove commented-out code

ERA001 Found commented-out code
  --> migrations/env.py:75:1
   |
73 | # other values from the config, defined by the needs of env.py,
74 | # can be acquired:
75 | # my_important_option = config.get_main_option("my_important_option")
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
76 | # ... etc.
   |
help: Remove commented-out code

ANN201 Missing return type annotation for public function `get_metadata`
  --> migrations/env.py:79:5
   |
79 | def get_metadata():
   |     ^^^^^^^^^^^^
80 |     """获取迁移需要的元数据对象。
   |
help: Add return type annotation

D400 First line should end with a period
  --> migrations/env.py:80:5
   |
79 |   def get_metadata():
80 | /     """获取迁移需要的元数据对象。
81 | |
82 | |     当项目维护多个 metadata 时,优先选择默认键 None 对应的 metadata。
83 | |
84 | |     Args:
85 | |         None.
86 | |
87 | |     Returns:
88 | |         MetaData: 用于自动生成迁移脚本的 SQLAlchemy MetaData。
89 | |
90 | |     Raises:
91 | |         RuntimeError: 当 Flask 应用未正确初始化数据库扩展时抛出。
92 | |     """
   | |_______^
93 |       if hasattr(target_db, "metadatas"):
94 |           return target_db.metadatas[None]
   |
help: Add period

D415 First line should end with a period, question mark, or exclamation point
  --> migrations/env.py:80:5
   |
79 |   def get_metadata():
80 | /     """获取迁移需要的元数据对象。
81 | |
82 | |     当项目维护多个 metadata 时,优先选择默认键 None 对应的 metadata。
83 | |
84 | |     Args:
85 | |         None.
86 | |
87 | |     Returns:
88 | |         MetaData: 用于自动生成迁移脚本的 SQLAlchemy MetaData。
89 | |
90 | |     Raises:
91 | |         RuntimeError: 当 Flask 应用未正确初始化数据库扩展时抛出。
92 | |     """
   | |_______^
93 |       if hasattr(target_db, "metadatas"):
94 |           return target_db.metadatas[None]
   |
help: Add closing punctuation

D413 [*] Missing blank line after last section ("Raises")
  --> migrations/env.py:90:5
   |
88 |         MetaData: 用于自动生成迁移脚本的 SQLAlchemy MetaData。
89 |
90 |     Raises:
   |     ^^^^^^
91 |         RuntimeError: 当 Flask 应用未正确初始化数据库扩展时抛出。
92 |     """
   |
help: Add blank line after "Raises"

D400 First line should end with a period
   --> migrations/env.py:99:5
    |
 98 |   def run_migrations_offline() -> None:
 99 | /     """以离线模式运行数据库迁移。
100 | |
101 | |     离线模式仅依赖数据库 URL,不需要真实 Engine/DBAPI,适合在 CI 中生成 SQL。
102 | |
103 | |     Args:
104 | |         None.
105 | |
106 | |     Returns:
107 | |         None: 迁移命令执行完毕即可返回。
108 | |
109 | |     Raises:
110 | |         SQLAlchemyError: 当 Alembic 配置失败时抛出。
111 | |     """
    | |_______^
112 |       url = config.get_main_option("sqlalchemy.url")
113 |       context.configure(
    |
help: Add period

D415 First line should end with a period, question mark, or exclamation point
   --> migrations/env.py:99:5
    |
 98 |   def run_migrations_offline() -> None:
 99 | /     """以离线模式运行数据库迁移。
100 | |
101 | |     离线模式仅依赖数据库 URL,不需要真实 Engine/DBAPI,适合在 CI 中生成 SQL。
102 | |
103 | |     Args:
104 | |         None.
105 | |
106 | |     Returns:
107 | |         None: 迁移命令执行完毕即可返回。
108 | |
109 | |     Raises:
110 | |         SQLAlchemyError: 当 Alembic 配置失败时抛出。
111 | |     """
    | |_______^
112 |       url = config.get_main_option("sqlalchemy.url")
113 |       context.configure(
    |
help: Add closing punctuation

D413 [*] Missing blank line after last section ("Raises")
   --> migrations/env.py:109:5
    |
107 |         None: 迁移命令执行完毕即可返回。
108 |
109 |     Raises:
    |     ^^^^^^
110 |         SQLAlchemyError: 当 Alembic 配置失败时抛出。
111 |     """
    |
help: Add blank line after "Raises"

D400 First line should end with a period
   --> migrations/env.py:122:5
    |
121 |   def run_migrations_online() -> None:
122 | /     """以在线模式运行数据库迁移。
123 | |
124 | |     在线模式会创建 Engine 并获取连接,适合直接对数据库执行变更。
125 | |
126 | |     Args:
127 | |         None.
128 | |
129 | |     Returns:
130 | |         None: 迁移执行完成后返回。
131 | |
132 | |     Raises:
133 | |         SQLAlchemyError: 当数据库连接或迁移执行失败时抛出。
134 | |     """
    | |_______^
135 |
136 |       # this callback is used to prevent an auto-migration from being generated
    |
help: Add period

D415 First line should end with a period, question mark, or exclamation point
   --> migrations/env.py:122:5
    |
121 |   def run_migrations_online() -> None:
122 | /     """以在线模式运行数据库迁移。
123 | |
124 | |     在线模式会创建 Engine 并获取连接,适合直接对数据库执行变更。
125 | |
126 | |     Args:
127 | |         None.
128 | |
129 | |     Returns:
130 | |         None: 迁移执行完成后返回。
131 | |
132 | |     Raises:
133 | |         SQLAlchemyError: 当数据库连接或迁移执行失败时抛出。
134 | |     """
    | |_______^
135 |
136 |       # this callback is used to prevent an auto-migration from being generated
    |
help: Add closing punctuation

D413 [*] Missing blank line after last section ("Raises")
   --> migrations/env.py:132:5
    |
130 |         None: 迁移执行完成后返回。
131 |
132 |     Raises:
    |     ^^^^^^
133 |         SQLAlchemyError: 当数据库连接或迁移执行失败时抛出。
134 |     """
    |
help: Add blank line after "Raises"

ANN001 Missing type annotation for function argument `_context`
   --> migrations/env.py:139:37
    |
137 |     # when there are no changes to the schema
138 |     # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
139 |     def process_revision_directives(_context, _revision, directives) -> None:
    |                                     ^^^^^^^^
140 |         """在自动迁移期间剔除空的升级操作."""
141 |         if getattr(config.cmd_opts, "autogenerate", False):
    |

ANN001 Missing type annotation for function argument `_revision`
   --> migrations/env.py:139:47
    |
137 |     # when there are no changes to the schema
138 |     # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
139 |     def process_revision_directives(_context, _revision, directives) -> None:
    |                                               ^^^^^^^^^
140 |         """在自动迁移期间剔除空的升级操作."""
141 |         if getattr(config.cmd_opts, "autogenerate", False):
    |

ANN001 Missing type annotation for function argument `directives`
   --> migrations/env.py:139:58
    |
137 |     # when there are no changes to the schema
138 |     # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
139 |     def process_revision_directives(_context, _revision, directives) -> None:
    |                                                          ^^^^^^^^^^
140 |         """在自动迁移期间剔除空的升级操作."""
141 |         if getattr(config.cmd_opts, "autogenerate", False):
    |

INP001 File `nginx/gunicorn/gunicorn-dev.conf.py` is part of an implicit namespace package. Add an `__init__.py`.
--> nginx/gunicorn/gunicorn-dev.conf.py:1:1

INP001 File `nginx/gunicorn/gunicorn-prod.conf.py` is part of an implicit namespace package. Add an `__init__.py`.
--> nginx/gunicorn/gunicorn-prod.conf.py:1:1

D100 Missing docstring in public module
--> nginx/gunicorn/gunicorn-prod.conf.py:1:1

Found 1107 errors.
[*] 22 fixable with the `--fix` option (13 hidden fixes can be enabled with the `--unsafe-fixes` option).
