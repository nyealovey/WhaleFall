# 当前周期 `period_end` 语义修复方案

## 0. 执行摘要

- **问题**：`PeriodCalculator.get_current_period()` 将 `period_end` 固定为“今天”，与历史周期（自然结束日）不一致，导致前端查询不到当前周期记录、同一周期数据每天变化。
- **目标**：让当前周期的 `period_end` 回归“自然结束日”（可能是未来时间），与历史周期保持一致语义。
- **关键调整**：
  1. 修改 `get_current_period()` 返回自然周期（周日 / 月末 / 季末）。
  2. 更新依赖当前周期的 API 与前端查询，允许 `period_end` 是未来日期。
  3. 迁移既有聚合数据，将当前周期的 `period_end` 批量修正。

预计工作量约 **4 小时**（含迁移脚本与测试），风险等级 **中低**。

---

## 1. 背景与现状

| 周期 | `get_last_period()` | `get_current_period()`（现状） |
|------|---------------------|--------------------------------|
| weekly | 自然周（周一至周日） | 周一至“今天” |
| monthly | 自然月 | 月初至“今天” |
| quarterly | 自然季 | 季初至“今天” |

### 已观察的问题
1. **语义冲突**：同一 `period_type` 在历史与当前两个维度上含义不同。
2. **数据抖动**：每天触发“统计当前周期”，同一记录的 `period_end` 都会更新为当天日期。
3. **查询缺口**：前端以 `end_date=today` 过滤，无法拿到 `period_end > today` 的记录。

---

## 2. 目标状态

| 周期 | 新的 `get_current_period()` | 备注 |
|------|-----------------------------|------|
| weekly | 本周一 ～ 本周日（可能未来） | 与历史周一致 |
| monthly | 本月 1 日 ～ 本月最后一天 | 与历史月一致 |
| quarterly | 本季度首日 ～ 季末日 | 与历史季一致 |

后端与前端统一理解：**`period_end` 表示该周期的自然结束日期，可能尚未到达。**

---

## 3. 实施方案

### 3.1 后端逻辑调整
- **文件**：`app/services/aggregation/calculator.py`
- **改动**：
  - 重写 `get_current_period()`，各周期均返回自然结束日；
  - 给 docstring 补充“可能是未来日期”的说明；
  - 保持 `get_last_period()` / `get_previous_period()` 不变。
- **影响范围**：
  - `DatabaseSizeAggregationService.aggregate_current_period()` 等所有“当前周期”调用路径；
  - 依赖 `PeriodCalculator` 的其他服务自动继承新行为。

### 3.2 API 与服务层
- 复核当前周期 API（如 `/api/aggregate-current`）的响应体，确认新增的 `period_end` 语义无需额外字段即可告知调用方。
- 调整任何基于“今天”写死过滤条件的查询逻辑（例如 `<= today`），改为根据返回的 `period_end` 进行比较或直接接受未来日期。
- 若有缓存标识等衍生逻辑，也需改为使用自然结束日期。

### 3.3 前端与调用方
- “统计当前周期”按钮在调用 API 时直接使用后端返回的 `period_start/end`，避免自行裁剪。
- 查询接口（列表、图表）允许 `period_end` 大于“今天”；若需要筛选“已结束周期”，应显式以 `period_end <= today` 作为条件，而非默认行为。
- 更新使用说明或客户端文档，提示 `period_end` 可能是未来日期。

### 3.4 数据迁移
- **脚本思路**：
  1. 找出 `period_end = CURRENT_DATE` 且 `period_type` 为 `weekly/monthly/quarterly` 的记录；
  2. 根据 `period_type` 与 `period_start` 计算其自然结束日；
  3. 批量更新 `period_end` 和 `updated_at`；
  4. 对比更新前后的记录数与 hash 校验，确保无遗漏。
- **执行顺序**：先在预发环境验证（含回归查询结果），再在生产执行。
- **回滚准备**：保留迁移前的 `period_end` 快照，必要时恢复。

---

## 4. 验证计划

| 项目 | 验证点 |
|------|--------|
| 单元测试 | `PeriodCalculator.get_current_period()` 覆盖各周期、闰月、跨年场景 |
| 集成测试 | 手动触发 `/api/aggregate-current`，确认返回 `period_end` 为自然结束日，并且数据库写入稳定 |
| 回归测试 | 历史周期接口不受影响；查询带 `period_end > today` 时仍能拿到当前周期数据 |
| 数据检查 | 迁移后抽样核对多条记录的 `period_end` 是否正确，确认不存在重复或缺失 |

---

## 5. 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 迁移脚本更新错误 | 高 | 先做 dry-run，逐批提交；生成差异报告 |
| 前端漏改过滤逻辑 | 中 | 提供调试脚本及 QA 用例，验证“当前周期”视图 |
| 第三方调用方未同步 | 中 | 发布前邮件/公告通知，注明 `period_end` 变更 |
| 时区差异导致自然结束日不一致 | 低 | 确保所有计算使用 `time_utils.now_china()` |

---

## 6. 回滚策略

1. **代码**：通过 `git revert` 回退 `PeriodCalculator` 及相关调用改动。
2. **数据**：迁移前备份（或导出）受影响记录；回滚时根据备份恢复 `period_end` 与 `updated_at`。
3. **前端**：若上线后暂时无法同步调整，可临时在查询层加入 fallback（`min(period_end, today)`），但必须在最终修复后移除。

---

## 7. 时间评估

| 任务 | 预计耗时 |
|------|----------|
| 代码改动与单元测试 | 1.5 h |
| 数据迁移脚本 & 预发验证 | 1.0 h |
| 前端/查询逻辑梳理与回归 | 1.0 h |
| 预留缓冲（沟通、灰度观察） | 0.5 h |

---

## 8. 附录：示例对比

假设今天为 2024-10-31（周四）：

| 周期 | 旧实现结果 | 新实现结果 | 说明 |
|------|------------|------------|------|
| weekly | `2024-10-28` ～ `2024-10-31` | `2024-10-28` ～ `2024-11-03` | 周日是未来日期 |
| monthly | `2024-10-01` ～ `2024-10-31` | 不变 | 10 月末恰好是今天 |
| quarterly | `2024-10-01` ～ `2024-10-31` | `2024-10-01` ～ `2024-12-31` | 季度自然结束日 |

---

**文档版本**: 2.0  
**最后更新**: 2024-11-02  
**作者**: Codex  
**状态**: 待审核
