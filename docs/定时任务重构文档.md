# 定时任务系统重构文档

## 一、问题诊断

### 1.1 当前定时任务概览

系统目前有三大类定时任务：

| 任务类型 | 任务名称 | 执行频率 | 主要功能 | 会话记录 |
|---------|---------|---------|---------|---------|
| **账户同步** | `sync_accounts` | 每30分钟 | 同步数据库账户信息 | ❌ **有问题** |
| **容量同步** | `collect_database_sizes` | 每天凌晨3点 | 采集数据库容量信息 | ✅ 正常 |
| **聚合统计** | `calculate_database_size_aggregations` | 每天凌晨4点 | 计算日/周/月/季度统计 | ✅ 正常 |

### 1.2 账户同步问题根因

**问题现象**：账户同步任务执行后，`sync_instance_records` 表中没有记录

**根本原因**：
```python
# app/tasks/account_sync_tasks.py 第 48 行
result = account_sync_service.sync_accounts(
    instance,
    sync_type=SyncOperationType.SCHEDULED_TASK.value,
    session_id=session.session_id,  # ❌ 传递了 session_id
)
```

当传递 `session_id` 参数时，`account_sync_service.sync_accounts()` 会调用 `_sync_with_existing_session()` 方法，该方法**只执行同步逻辑，不会更新同步记录**。

**对比容量同步的正确实现**：
```python
# app/tasks/capacity_collection_tasks.py
# ✅ 容量同步在任务层直接管理会话记录
sync_session_service.start_instance_sync(record.id)
collector = DatabaseSizeCollectorService(instance)
# ... 执行同步 ...
sync_session_service.complete_instance_sync(record.id, ...)
```

### 1.3 架构对比

| 任务 | 会话创建 | 记录管理 | 状态更新 | 问题 |
|-----|---------|---------|---------|------|
| **账户同步** | 任务层 | ❌ 服务层（被跳过） | ❌ 不完整 | 传递 session_id 导致跳过记录管理 |
| **容量同步** | 任务层 | ✅ 任务层 | ✅ 完整 | 无 |
| **聚合统计** | 任务层 | ✅ 任务层 | ✅ 完整 | 无 |

---

## 二、重构方案（方案A）

### 2.1 核心思路

**参考容量同步模式，将会话记录管理从服务层移到任务层**

- 任务层：负责会话创建、记录管理、状态更新
- 协调器层：负责实际的同步逻辑（连接、同步、断开）
- 服务层：保留单实例同步功能（用于手动触发）

### 2.2 重构前后对比

#### 重构前（有问题）

```python
# ❌ 当前实现
def sync_accounts(manual_run: bool = False, created_by: int | None = None, **kwargs):
    # 1. 创建会话
    session = sync_session_service.create_session(...)
    records = sync_session_service.add_instance_records(...)
    
    for instance in instances:
        # 2. 调用服务层（传递 session_id）
        result = account_sync_service.sync_accounts(
            instance,
            sync_type=SyncOperationType.SCHEDULED_TASK.value,
            session_id=session.session_id,  # ❌ 导致跳过记录管理
        )
        
        # 3. 手动更新记录（但 result 中没有足够的信息）
        if result.get("success"):
            sync_session_service.complete_instance_sync(...)
```

#### 重构后（正确）

```python
# ✅ 重构后实现
def sync_accounts(manual_run: bool = False, created_by: int | None = None, **kwargs):
    # 1. 创建会话
    session = sync_session_service.create_session(...)
    records = sync_session_service.add_instance_records(...)
    
    for i, instance in enumerate(instances):
        record = records[i]
        
        # 2. 开始实例同步
        sync_session_service.start_instance_sync(record.id)
        
        # 3. 直接使用协调器执行同步
        coordinator = AccountSyncCoordinator(instance)
        try:
            if not coordinator.connect():
                sync_session_service.fail_instance_sync(record.id, "连接失败")
                continue
            
            # 生成临时 session_id 用于权限记录
            temp_session_id = f"{session.session_id}_{instance.id}"
            summary = coordinator.sync_all(session_id=temp_session_id)
            
            # 4. 更新实例记录
            inventory = summary.get("inventory", {})
            permissions = summary.get("permissions", {})
            
            sync_session_service.complete_instance_sync(
                record.id,
                items_synced=permissions.get("updated", 0) + permissions.get("created", 0),
                items_created=inventory.get("created", 0),
                items_updated=permissions.get("updated", 0),
                items_deleted=inventory.get("deactivated", 0),
                sync_details={"inventory": inventory, "permissions": permissions}
            )
        finally:
            coordinator.disconnect()
```

---

## 三、实施步骤

### 3.1 重构代码

#### 步骤1：备份当前文件

```bash
cp app/tasks/account_sync_tasks.py app/tasks/account_sync_tasks.py.backup
```

#### 步骤2：修改 `app/tasks/account_sync_tasks.py`

```python
# ✅ 重构后实现
def sync_accounts(manual_run: bool = False, created_by: int | None = None, **kwargs):
    """账户同步任务"""
    app = create_app()
    with app.app_context():
        sync_logger = get_sync_logger()
        
        try:
            # 1. 获取活跃实例
            instances = Instance.query.filter_by(is_active=True).all()
            if not instances:
                sync_logger.info("没有找到启用的数据库实例")
                return
            
            # 2. 创建同步会话
            session = sync_session_service.create_session(
                sync_type=SyncOperationType.MANUAL_TASK.value if manual_run else SyncOperationType.SCHEDULED_TASK.value,
                sync_category=SyncCategory.ACCOUNT.value,
                created_by=created_by,
            )
            
            # 3. 添加实例记录
            instance_ids = [inst.id for inst in instances]
            records = sync_session_service.add_instance_records(
                session.session_id, 
                instance_ids,
                sync_category=SyncCategory.ACCOUNT.value
            )
            session.total_instances = len(instances)
            
            total_synced = 0
            total_failed = 0
            
            # 4. 遍历实例执行同步
            for i, instance in enumerate(instances):
                record = records[i] if i < len(records) else None
                if not record:
                    continue
                
                try:
                    # 4.1 开始实例同步
                    sync_session_service.start_instance_sync(record.id)
                    
                    # 4.2 创建协调器并执行同步（不传 session_id）
                    coordinator = AccountSyncCoordinator(instance)
                    
                    try:
                        # 连接数据库
                        if not coordinator.connect():
                            error_msg = f"无法连接到实例 {instance.name}"
                            sync_session_service.fail_instance_sync(record.id, error_msg)
                            total_failed += 1
                            continue
                        
                        # 执行同步（生成临时 session_id 用于权限记录）
                        temp_session_id = f"{session.session_id}_{instance.id}"
                        summary = coordinator.sync_all(session_id=temp_session_id)
                        
                        # 4.3 提取同步结果
                        inventory = summary.get("inventory", {})
                        permissions = summary.get("permissions", {})
                        
                        # 4.4 更新实例记录
                        sync_session_service.complete_instance_sync(
                            record.id,
                            items_synced=permissions.get("updated", 0) + permissions.get("created", 0),
                            items_created=inventory.get("created", 0),
                            items_updated=permissions.get("updated", 0),
                            items_deleted=inventory.get("deactivated", 0),
                            sync_details={
                                "inventory": inventory,
                                "permissions": permissions,
                            }
                        )
                        
                        total_synced += 1
                        
                        sync_logger.info(
                            f"实例 {instance.name} 同步成功",
                            instance_id=instance.id,
                            session_id=session.session_id,
                            inventory=inventory,
                            permissions=permissions,
                        )
                        
                    finally:
                        coordinator.disconnect()
                    
                except Exception as exc:
                    total_failed += 1
                    sync_session_service.fail_instance_sync(record.id, str(exc))
                    sync_logger.error(
                        f"实例 {instance.name} 同步异常",
                        instance_id=instance.id,
                        error=str(exc),
                        exc_info=True,
                    )
            
            # 5. 更新会话状态
            session.successful_instances = total_synced
            session.failed_instances = total_failed
            session.status = "completed" if total_failed == 0 else "failed"
            session.completed_at = time_utils.now()
            db.session.commit()
            
            sync_logger.info(
                "账户同步任务完成",
                session_id=session.session_id,
                total_instances=len(instances),
                total_synced=total_synced,
                total_failed=total_failed,
            )
            
        except Exception as exc:
            if "session" in locals() and session:
                session.status = "failed"
                session.completed_at = time_utils.now()
                session.failed_instances = len(instances)
                db.session.commit()
            
            sync_logger.error(
                "账户同步任务失败",
                error=str(exc),
                exc_info=True,
            )
            raise
```

**方案B：修改服务层逻辑（不推荐）**

修改 `account_sync_service.py` 的 `_sync_with_existing_session()` 方法，使其也能管理记录。但这会破坏服务层的职责单一性。

### 3.2 统一的任务模式

重构后，三大任务将采用统一的执行模式：

```python
# 统一的定时任务模板
def task_template(manual_run: bool = False, created_by: int | None = None):
    """定时任务统一模板"""
    app = create_app()
    with app.app_context():
        sync_logger = get_sync_logger()
        session = None
        
        try:
            # 1. 获取目标实例
            instances = Instance.query.filter_by(is_active=True).all()
            if not instances:
                return
            
            # 2. 创建同步会话
            session = sync_session_service.create_session(
                sync_type=...,
                sync_category=...,
                created_by=created_by,
            )
            
            # 3. 添加实例记录
            records = sync_session_service.add_instance_records(...)
            session.total_instances = len(instances)
            
            total_synced = 0
            total_failed = 0
            
            # 4. 遍历实例执行任务
            for i, instance in enumerate(instances):
                record = records[i]
                
                try:
                    # 4.1 开始实例同步
                    sync_session_service.start_instance_sync(record.id)
                    
                    # 4.2 执行具体业务逻辑
                    result = execute_business_logic(instance)
                    
                    # 4.3 更新实例记录
                    if result["success"]:
                        sync_session_service.complete_instance_sync(
                            record.id,
                            items_synced=...,
                            sync_details=...
                        )
                        total_synced += 1
                    else:
                        sync_session_service.fail_instance_sync(
                            record.id,
                            error_message=...
                        )
                        total_failed += 1
                        
                except Exception as exc:
                    total_failed += 1
                    sync_session_service.fail_instance_sync(record.id, str(exc))
            
            # 5. 更新会话状态
            session.successful_instances = total_synced
            session.failed_instances = total_failed
            session.status = "completed" if total_failed == 0 else "failed"
            session.completed_at = time_utils.now()
            db.session.commit()
            
        except Exception as exc:
            if session:
                session.status = "failed"
                session.completed_at = time_utils.now()
                db.session.commit()
            raise
```

---

## 四、实施计划

### 4.1 重构步骤

#### 阶段一：修复账户同步（高优先级）

1. **备份当前代码**
   ```bash
   cp app/tasks/account_sync_tasks.py app/tasks/account_sync_tasks.py.backup
   ```

2. **重构 `sync_accounts()` 函数**
   - 移除对 `account_sync_service.sync_accounts()` 的依赖
   - 直接使用 `AccountSyncCoordinator` 执行同步
   - 在任务层管理会话记录

3. **测试验证**
   - 手动触发账户同步任务
   - 检查 `sync_sessions` 和 `sync_instance_records` 表
   - 验证会话记录是否正确创建

#### 阶段二：优化服务层（中优先级）

1. **简化 `AccountSyncService`**
   - 保留 `_sync_single_instance()` 用于单实例同步
   - 移除 `_sync_with_session()` 和 `_sync_with_existing_session()`
   - 简化 `sync_accounts()` 方法的逻辑分支

2. **更新调用方**
   - 检查所有调用 `account_sync_service.sync_accounts()` 的地方
   - 确保单实例同步仍然正常工作

#### 阶段三：文档和监控（低优先级）

1. **更新开发文档**
   - 记录统一的任务模式
   - 添加会话管理最佳实践

2. **添加监控指标**
   - 任务执行成功率
   - 会话记录完整性
   - 同步耗时统计

### 4.2 测试清单

#### 功能测试

- [ ] 定时任务自动执行账户同步
- [ ] 手动触发账户同步任务
- [ ] 单实例账户同步（实例详情页）
- [ ] 批量账户同步
- [ ] 容量同步任务（回归测试）
- [ ] 聚合统计任务（回归测试）

#### 数据验证

- [ ] `sync_sessions` 表记录正确
- [ ] `sync_instance_records` 表记录正确
- [ ] `account_permissions` 表的 `session_id` 正确
- [ ] 同步详情 `sync_details` 字段完整

#### 异常场景

- [ ] 数据库连接失败
- [ ] 部分实例同步失败
- [ ] 任务执行超时
- [ ] 并发同步冲突

### 4.3 回滚方案

如果重构后出现问题，可以快速回滚：

```bash
# 恢复备份文件
cp app/tasks/account_sync_tasks.py.backup app/tasks/account_sync_tasks.py

# 重启应用
make dev restart-flask
```

---

## 五、风险评估

### 5.1 技术风险

| 风险 | 影响 | 概率 | 缓解措施 |
|-----|------|------|---------|
| 会话记录不完整 | 中 | 低 | 充分测试，参考容量同步实现 |
| 性能下降 | 低 | 低 | 重构不改变核心逻辑，性能影响可忽略 |
| 并发冲突 | 中 | 低 | 保持现有的任务调度配置 |
| 数据不一致 | 高 | 低 | 使用事务保证原子性 |

### 5.2 业务风险

| 风险 | 影响 | 概率 | 缓解措施 |
|-----|------|------|---------|
| 同步失败 | 高 | 低 | 保留原有的错误处理逻辑 |
| 历史数据丢失 | 高 | 极低 | 只修改新增记录的逻辑 |
| 用户体验下降 | 中 | 低 | 保持相同的执行频率和方式 |

---

## 六、预期收益

### 6.1 功能改进

- ✅ **修复账户同步会话记录问题**：所有同步任务都能正确记录会话
- ✅ **统一任务管理模式**：三大任务采用相同的实现模式
- ✅ **提升可追溯性**：完整的同步历史记录

### 6.2 代码质量

- ✅ **职责更清晰**：任务层管理会话，服务层专注业务
- ✅ **减少重复代码**：统一的任务模板
- ✅ **更易维护**：新增任务可以复用模板

### 6.3 运维改进

- ✅ **更好的监控**：完整的会话记录支持监控告警
- ✅ **问题排查更容易**：详细的同步日志和状态
- ✅ **数据分析支持**：完整的历史数据用于分析

---

## 七、附录

### 7.1 相关文件清单

```
app/
├── tasks/
│   ├── account_sync_tasks.py          # ❌ 需要重构
│   ├── capacity_collection_tasks.py   # ✅ 参考实现
│   └── capacity_aggregation_tasks.py  # ✅ 参考实现
├── services/
│   ├── account_sync/
│   │   ├── coordinator.py             # 保持不变
│   │   └── account_sync_service.py    # 可选优化
│   └── sync_session_service.py        # 保持不变
└── scheduler.py                        # 保持不变
```

### 7.2 关键代码对比

#### 当前实现（有问题）

```python
# app/tasks/account_sync_tasks.py
result = account_sync_service.sync_accounts(
    instance,
    sync_type=SyncOperationType.SCHEDULED_TASK.value,
    session_id=session.session_id,  # ❌ 导致跳过记录管理
)
```

#### 重构后实现（正确）

```python
# app/tasks/account_sync_tasks.py
coordinator = AccountSyncCoordinator(instance)
try:
    if not coordinator.connect():
        sync_session_service.fail_instance_sync(record.id, "连接失败")
        continue
    
    temp_session_id = f"{session.session_id}_{instance.id}"
    summary = coordinator.sync_all(session_id=temp_session_id)
    
    sync_session_service.complete_instance_sync(
        record.id,
        items_synced=...,
        sync_details=summary
    )
finally:
    coordinator.disconnect()
```

### 7.3 参考资料

- **容量同步实现**：`app/tasks/capacity_collection_tasks.py`
- **聚合统计实现**：`app/tasks/capacity_aggregation_tasks.py`
- **会话服务文档**：`app/services/sync_session_service.py`
- **协调器文档**：`app/services/account_sync/coordinator.py`

---

## 八、总结

### 8.1 核心问题

账户同步任务在调用 `account_sync_service.sync_accounts()` 时传递了 `session_id`，导致服务层跳过了会话记录的管理，使得同步历史无法被正确记录。

### 8.2 解决方案

将会话记录管理从服务层移到任务层，直接使用 `AccountSyncCoordinator` 执行同步，参考容量同步和聚合统计的实现模式。

### 8.3 实施建议

1. **优先修复账户同步**：这是当前的主要问题
2. **保持执行方式不变**：不改变调度配置和执行频率
3. **充分测试验证**：确保会话记录正确且不影响现有功能
4. **准备回滚方案**：备份代码，确保可以快速恢复

---

**文档版本**：v1.0  
**创建日期**：2025-11-04  
**最后更新**：2025-11-04  
**维护者**：开发团队
